#+SEQ_TODO:       TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:           write(w) update(u) fix(f) verify(v) noexport(n)
#+EXPORT_EXCLUDE_TAGS: noexport

* thi.ng.geom.meshio
** TODO make CLJS compatible
** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/meshio.cljx
  (ns thi.ng.geom.meshio
    (:require
     [thi.ng.common.data.byteutils :as b]
     [thi.ng.geom.core :as g]
     [thi.ng.geom.gmesh :as gm]
     [thi.ng.geom.triangle :as t])
    ,#+clj
    (:import
     [java.io OutputStream InputStream]))
#+END_SRC
** Configuration parameters
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/meshio.cljx
  (def ^:dynamic *precision* 5)
#+END_SRC
** STL
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/meshio.cljx
  (defn write-stl
    "Writes the given mesh as binary STL to output stream. Mesh is
    automatically tessellated into triangles."
    [^OutputStream stream {:keys [fnormals faces]}]
    (let [faces (mapcat gm/tessellate-face faces)]
      (.write stream #+clj (byte-array 80) #+cljs (into-array (repeat 80 0)))
      (b/write-int32-le stream (count faces))
      (doseq [[a b c :as f] faces]
        (b/write-vec3-le stream (or (get fnormals f) (g/normal3* f)))
        (b/write-vec3-le stream a)
        (b/write-vec3-le stream b)
        (b/write-vec3-le stream c)
        (b/write-int16-le stream 0))
      stream))
  
  (defn read-stl
    "Returns binary STL inputstream as mesh."
    [^InputStream stream]
    (.read stream #+clj (byte-array 80) #+cljs (make-array 80))
    (loop [mesh (gm/gmesh), i (b/read-int32-le stream)]
      (if (pos? i)
        (let [_ (b/read-vec3-le stream)
              a (b/read-vec3-le stream)
              b (b/read-vec3-le stream)
              c (b/read-vec3-le stream)
              _ (b/read-int16-le stream)]
          (recur (gm/add-face mesh [a b c]) (dec i)))
        mesh)))
  
  (defn read-stl-vertices
    "Reads all vertices from given STL input stream. A target collection
    can be specified optionally. If none is given, a set of unique
    vertices is returned."
    ([^InputStream stream]
       (read-stl-vertices stream #{}))
    ([^InputStream stream vert-pool]
       (.read stream #+clj (byte-array 80) #+cljs (make-array 80))
       (loop [vertices vert-pool, nf (b/read-int32-le stream)]
         (if (zero? nf)
           vertices
           (let [_ (b/read-vec3-le stream)
                 a (b/read-vec3-le stream)
                 b (b/read-vec3-le stream)
                 c (b/read-vec3-le stream)
                 _ (b/read-int16-le stream)]
             (recur (conj vertices a b c) (dec nf)))))))
#+END_SRC
** PLY
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/meshio.cljx
  (defn write-ply
    "Writes the given mesh as binary PLY to output stream. For
    compatibility with external tools mesh should already have been
    tessellated before calling this fn."
    [^OutputStream stream {:keys [vertices vnormals faces]}]
    (let [vertices (keys vertices)
          vindex (zipmap vertices (range))
          fhead #+clj (byte-array 1) #+cljs (make-array 1)
          write-props (fn [props]
                        (doseq [p props]
                          (b/write-str-bytes
                           stream (str "property float32 " p "\n"))))
          write-vindex (fn [face]
                         (doseq [v face]
                           (b/write-int32-le stream (get vindex v))))]
      (doto stream
        (b/write-str-bytes "ply\n")
        (b/write-str-bytes "format binary_little_endian 1.0\n")
        (b/write-str-bytes (str "element vertex " (count vertices) "\n")))
      (write-props ['x 'y 'z])
      (when (seq vnormals) (write-props ['nx 'ny 'nz]))
      (doto stream
        (b/write-str-bytes (str "element face " (count faces) "\n"))
        (b/write-str-bytes "property list uint8 uint32 vertex_indices\n")
        (b/write-str-bytes "end_header\n"))
      (doseq [v vertices]
        (b/write-vec3-le stream v)
        (when (seq vnormals)
          (b/write-vec3-le stream (get vnormals v))))
      (doseq [f faces]
        (aset-byte fhead 0 (byte (count f)))
        (.write stream fhead)
        (write-vindex f))
      stream))
#+END_SRC
** OBJ
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/meshio.cljx
  (defn write-obj
    [^OutputStream stream {:keys [vertices vnormals faces]}]
    (let [vertices (keys vertices)
          has-vnormals? (not (nil? (seq vnormals)))
          fmt-fn (fn [prefix]
                   ,#+clj (let [ff (str "%1." *precision* "f ")
                               ff (str prefix " " ff ff ff "\n")]
                           #(format ff %1 %2 %3))
                   ,#+cljs #(str
                            prefix " "
                            (.toFixed (js/Number. %1) *precision*) " "
                            (.toFixed (js/Number. %2) *precision*) " "
                            (.toFixed (js/Number. %3) *precision*) "\n"))
          fmt-vertex (fmt-fn "v")
          fmt-vnormal (fmt-fn "vn")
          fmt-fvert (if has-vnormals? #(str % "//" %2 " ") #(str % " "))
          fmt-face (if has-vnormals?
                     (fn [verts normals]
                       (str "f " (apply str (map fmt-fvert verts normals)) "\n"))
                     (fn [verts] (str "f " (apply str (map fmt-fvert verts)) "\n")))
          vindex (zipmap vertices (range))
          nindex (zipmap (vals vnormals) (range))]
      (doseq [[x y z] vertices]
        (b/write-str-bytes
         stream (fmt-vertex (double x) (double y) (double z))))
      (doseq [[x y z] (vals vnormals)]
        (b/write-str-bytes stream (fmt-vnormal (double x) (double y) (double z))))
      (b/write-str-bytes stream "g\n")
      (doseq [fverts faces]
        (b/write-str-bytes
         stream
         (if has-vnormals?
           (fmt-face
            (map #(inc (get vindex %)) fverts)
            (map #(inc (get nindex (get vnormals %))) fverts))
           (fmt-face (map #(inc (get vindex %)) fverts)))))
      stream))
#+END_SRC
** OFF
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/meshio.cljx
  (defn write-off
    [^OutputStream stream {:keys [vertices faces]}]
    (let [vertices (keys vertices)
          fmt-vertex
          ,#+clj (let [ff (str "%1." *precision* "f ")
                      ff (str ff ff ff "\n")]
                  #(format ff %1 %2 %3))
          ,#+cljs #(str (.toFixed (js/Number. %1) *precision*) " "
                       (.toFixed (js/Number. %2) *precision*) " "
                       (.toFixed (js/Number. %3) *precision*) "\n")
          vindex (zipmap vertices (range))]
      (b/write-str-bytes stream "OFF\n")
      (b/write-str-bytes stream (str (count vertices) " " (count faces) " 0\n"))
      (doseq [[x y z] vertices]
        (b/write-str-bytes
         stream (fmt-vertex (double x) (double y) (double z))))
      (doseq [fverts faces]
        (b/write-str-bytes
         stream
         (str (count fverts) " "
              (apply str (map #(str (vindex %) " ") fverts))
              "\n")))))
#+END_SRC
