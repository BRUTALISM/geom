#+SEQ_TODO:       TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:           write(w) update(u) fix(f) verify(v) noexport(n)
#+EXPORT_EXCLUDE_TAGS: noexport

* thi.ng.geom.meshio
** TODO make CLJS compatible
** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/meshio.cljx
  (ns thi.ng.geom.meshio
    (:require
     [thi.ng.common.data.byteutils :as b]
     [thi.ng.geom.core :as g]
     [thi.ng.geom.mesh :as m]
     [thi.ng.geom.triangle :as t])
    ,#+clj
    (:import
     [java.io OutputStream InputStream]))
#+END_SRC
** Configuration parameters
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/meshio.cljx
  (def ^:dynamic *precision* 5)
#+END_SRC
** STL
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/meshio.cljx
  (defn write-stl
    [^OutputStream stream {:keys [fnormals faces]}]
    #+clj (.write stream (byte-array 80))
    (b/write-int32-le stream (count faces))
    (doseq [[a b c :as f] faces]
      (b/write-vec3-le stream (or (get fnormals f) (g/normal3* f)))
      (b/write-vec3-le stream a)
      (b/write-vec3-le stream b)
      (b/write-vec3-le stream c)
      (b/write-int16-le stream 0))
    stream)

  (defn read-stl
    [^InputStream stream]
    #+clj (.read stream (byte-array 80))
    (let [nf (b/read-int32-le stream)
          mesh (m/mesh3)]
      (loop [[v e f] (m/begin-edit mesh) i nf]
        (if (zero? i)
          (m/commit-edit mesh [v e f])
          (let [_ (b/read-vec3-le stream)
                a (b/read-vec3-le stream)
                b (b/read-vec3-le stream)
                c (b/read-vec3-le stream)
                _ (b/read-int16-le stream)]
            (recur (m/add-face! [v e f] [a b c]) (dec i)))))))

  (defn read-stl-vertices
    [^InputStream stream]
    #+clj (.read stream (byte-array 80))
    (loop [vertices #{} nf (b/read-int32-le stream)]
      (if (zero? nf)
        vertices
        (let [_ (b/read-vec3-le stream)
              a (b/read-vec3-le stream)
              b (b/read-vec3-le stream)
              c (b/read-vec3-le stream)
              _ (b/read-int16-le stream)]
          (recur (conj vertices a b c) (dec nf))))))
#+END_SRC
** PLY
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/meshio.cljx
  (defn write-ply
    [^OutputStream stream {:keys [vertices vnormals faces]}]
    (let [vertices (keys vertices)
          vindex (zipmap vertices (range))
          fhead #+clj (byte-array [(byte 0)]) #+cljs (into-array [0])
          write-props (fn [props]
                        (doseq [p props]
                          (b/write-str-bytes
                           stream (str "property float32 " p "\n"))))
          write-vindex (fn [face]
                         (doseq [v face]
                           (b/write-int32-le stream (get vindex v))))]
      (doto stream
        (b/write-str-bytes "ply\n")
        (b/write-str-bytes "format binary_little_endian 1.0\n")
        (b/write-str-bytes (str "element vertex " (count vertices) "\n")))
      (write-props ['x 'y 'z])
      (when (seq vnormals) (write-props ['nx 'ny 'nz]))
      (doto stream
        (b/write-str-bytes (str "element face " (count faces) "\n"))
        (b/write-str-bytes "property list uint8 uint32 vertex_indices\n")
        (b/write-str-bytes "end_header\n"))
      (doseq [v vertices]
        (b/write-vec3-le stream v)
        (when (seq vnormals)
          (b/write-vec3-le stream (get vnormals v))))
      (doseq [f faces]
        (aset-byte fhead 0 (byte (count f)))
        (.write stream fhead)
        (write-vindex f))
      stream))
#+END_SRC
** OBJ
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/meshio.cljx
  (defn write-obj
    [^OutputStream stream {:keys [vertices vnormals faces]}]
    (let [vertices (keys vertices)
          has-vnormals? (not (nil? (seq vnormals)))
          fmt-fn
          #+clj (fn [prefix]
                  (let [ff (str "%1." *precision* "f ")
                        ff (str prefix " " ff ff ff "\n")]
                    #(format ff %1 %2 %3)))
          #+cljs (fn [prefix]
                   #(str prefix " "
                         (.toFixed (js/Number. %1) *precision*) " "
                         (.toFixed (js/Number. %2) *precision*) " "
                         (.toFixed (js/Number. %3) *precision*) "\n"))
          fmt-vertex (fmt-fn "v")
          fmt-vnormal (fmt-fn "vn")
          fmt-face
          #+clj (if has-vnormals?
                  #(format "f %d//%d %d//%d %d//%d\n" %1 %2 %3 %4 %5 %6)
                  #(format "f %d %d %d\n" %1 %2 %3))
          #+cljs (if has-vnormals?
                   (fn [a b c d e f] (str "f " a "//" b " " c "//" d " " e "//" f "\n"))
                   (fn [a b c] (str "f " a " " b " " c "\n")))
          vindex (zipmap vertices (range))
          nindex (zipmap (vals vnormals) (range))]
      (doseq [[x y z] vertices]
        (b/write-str-bytes
         stream (fmt-vertex (double x) (double y) (double z))))
      (doseq [[x y z] (vals vnormals)]
        (b/write-str-bytes stream (fmt-vnormal (double x) (double y) (double z))))
      (b/write-str-bytes stream "g\n")
      (doseq [[a b c] faces]
        (b/write-str-bytes
         stream
         (if has-vnormals?
           (fmt-face
            (inc (get vindex a))
            (inc (get nindex (get vnormals a)))
            (inc (get vindex b))
            (inc (get nindex (get vnormals b)))
            (inc (get vindex c))
            (inc (get nindex (get vnormals c))))
           (fmt-face
            (inc (get vindex a))
            (inc (get vindex b))
            (inc (get vindex c))))))
      stream))
#+END_SRC
** OFF
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/meshio.cljx
  (defn write-off
    [^OutputStream stream {:keys [vertices faces]}]
    (let [vertices (keys vertices)
          prc *precision*
          fmt-vertex
          #+clj (let [ff (str "%1." prc "f ")
                      ff (str ff ff ff "\n")]
                  #(format ff %1 %2 %3))
          #+cljs #(str (.toFixed (js/Number. %1) prc) " "
                       (.toFixed (js/Number. %2) prc) " "
                       (.toFixed (js/Number. %3) prc) "\n")
          vindex (zipmap vertices (range))]
      (b/write-str-bytes stream "OFF\n")
      (b/write-str-bytes stream (str (count vertices) " " (count faces) " 0\n"))
      (doseq [[x y z] vertices]
        (b/write-str-bytes stream (fmt-vertex (double x) (double y) (double z))))
      (doseq [[a b c] faces]
        (b/write-str-bytes
         stream (str "3 " (vindex a) " " (vindex b) " " (vindex c) "\n")))))
#+END_SRC
