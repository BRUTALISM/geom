* JOGL examples

** Example 1

#+BEGIN_SRC clojure :tangle ../../babel/examples/jogl/ex01.clj :mkdirp yes :padline no
  (ns thi.ng.geom.examples.jogl.ex01
    (:import
     [com.jogamp.opengl GL3 GLAutoDrawable]
     [com.jogamp.newt.event MouseEvent KeyEvent])
    (:require
     [thi.ng.math.core :as m]
     [thi.ng.geom.core :as g]
     [thi.ng.geom.aabb :as a]
     [thi.ng.geom.attribs :as attr]
     [thi.ng.geom.vector :as v]
     [thi.ng.geom.matrix :as mat]
     [thi.ng.geom.gl.core :as gl]
     [thi.ng.geom.gl.arcball :as arc]
     [thi.ng.geom.gl.buffers :as buf]
     [thi.ng.geom.gl.shaders :as sh]
     [thi.ng.geom.gl.glmesh :as glm]
     [thi.ng.geom.gl.jogl.core :as jogl]
     [thi.ng.geom.gl.jogl.constants :as glc]
     [clojure.pprint :refer [pprint]]
     [clojure.java.io :as io]))

  (def app (atom nil))

  (def shader
    {:vs "
  void main() {
    vCol = vec4(position.xy * 0.5 + 0.5, fract(time), 1.0);
    vUV = uv;
    gl_Position = proj * view * model * vec4(position, 1.0);
  }"
     :fs "out vec4 outCol;

  void main() {
    outCol = vCol * texture(tex, vUV);
  }"
     :version  330
     :attribs  {:position :vec3
                :uv       :vec2}
     :varying  {:vCol     :vec4
                :vUV      :vec2}
     :uniforms {:model [:mat4 mat/M44]
                :view  :mat4
                :proj  :mat4
                :tex   [:sampler2D 0]
                :time  :float}
     :state    {:depth-test true}})

  (defn init
    [^GLAutoDrawable drawable]
    (let [^GL3 gl (.. drawable getGL getGL3)
          tex     (buf/load-texture gl {:src (io/file "dev-resources/cubev.png")})
          model   (-> (a/aabb 1)
                      (g/center)
                      (g/as-mesh {:mesh    (glm/gl-mesh 12 #{:uv})
                                  :attribs {:uv (attr/face-attribs (attr/uv-cube-map-v 256 false))}})
                      (gl/as-gl-buffer-spec {})
                      (assoc :shader (sh/make-shader-from-spec gl shader))
                      (assoc-in [:shader :state :tex] tex)
                      (gl/make-buffers-in-spec gl glc/static-draw))]
      (pprint model)
      (swap! app assoc
             :model   model
             :arcball (arc/arcball {}))))

  (defn display
    [^GLAutoDrawable drawable t]
    (let [^GL3 gl (.. drawable getGL getGL3)
          {:keys [shader] :as spec} (:model @app)
          unis    (:uniforms shader)
          t       (* 0.25 t)
          view    (arc/get-view (:arcball @app))]
      (doto gl
        (gl/clear-color-and-depth-buffer 0.3 0.3 0.3 1.0 1.0)
        (gl/draw-with-shader
         (update spec :uniforms assoc
                 :view view
                 :time t)))))

  (defn dispose [_] (jogl/stop-animator (:anim @app)))

  (defn resize
    [_ x y w h]
    (swap! app assoc-in [:model :uniforms :proj] (mat/perspective 45 (/ w h) 0.1 10))
    (swap! app update :arcball arc/resize w h))

  (defn key-pressed
    [^KeyEvent e]
    (condp = (.getKeyCode e)
      KeyEvent/VK_ESCAPE (jogl/destroy-window (:window @app))
      nil))

  (defn mouse-moved
    [^MouseEvent e] (swap! app assoc :mouse-pos (v/vec2 (.getX e) (.getY e))))

  (defn mouse-pressed
    [^MouseEvent e] (swap! app update :arcball arc/down (.getX e) (.getY e)))

  (defn mouse-dragged
    [^MouseEvent e] (swap! app update :arcball arc/drag (.getX e) (.getY e)))

  (defn wheel-moved
    [^MouseEvent e deltas] (swap! app update :arcball arc/zoom-delta (nth deltas 1)))

  (defn -main
    [& args]
    (reset!
     app
     (jogl/gl-window
      {:profile       :gl3
       :samples       4
       :double-buffer true
       :fullscreen    false
       :events        {:init    init
                       :display display
                       :resize  resize
                       :keys    {:press key-pressed}
                       :mouse   {:move  mouse-moved
                                 :press mouse-pressed
                                 :drag  mouse-dragged
                                 :wheel wheel-moved}}}))
    nil)
#+END_SRC
** Example 2

#+BEGIN_SRC clojure :tangle ../../babel/examples/jogl/ex02.clj :mkdirp yes :padline no
  (ns thi.ng.geom.examples.jogl.ex02
    (:import
     [com.jogamp.opengl GL3 GLAutoDrawable]
     [com.jogamp.newt.event MouseEvent KeyEvent])
    (:require
     [thi.ng.math.core :as m]
     [thi.ng.color.core :as col]
     [thi.ng.geom.core :as g]
     [thi.ng.geom.sphere :as s]
     [thi.ng.geom.attribs :as attr]
     [thi.ng.geom.vector :as v]
     [thi.ng.geom.matrix :as mat]
     [thi.ng.geom.gl.core :as gl]
     [thi.ng.geom.gl.camera :as cam]
     [thi.ng.geom.gl.buffers :as buf]
     [thi.ng.geom.gl.shaders :as sh]
     [thi.ng.geom.gl.shaders.lambert :as lambert]
     [thi.ng.geom.gl.shaders.phong :as phong]
     [thi.ng.geom.gl.shaders.image :as image]
     [thi.ng.geom.gl.glmesh :as glm]
     [thi.ng.geom.gl.jogl.core :as jogl]
     [thi.ng.geom.gl.jogl.constants :as glc]
     [thi.ng.glsl.core :as glsl]
     [thi.ng.glsl.vertex :as vertex]
     [thi.ng.glsl.lighting :as light]
     [clojure.pprint :refer [pprint]]
     [clojure.java.io :as io]))

  (def app (atom nil))

  (defn init
    [^GLAutoDrawable drawable]
    (let [^GL3 gl     (.. drawable getGL getGL3)
          view-rect   (gl/get-viewport-rect gl)
          main-shader (sh/make-shader-from-spec gl (assoc phong/shader-spec :version 330))
          img-shader  (sh/make-shader-from-spec gl (assoc image/shader-spec :version 330))
          fbo-size    512
          fbo-tex     (buf/make-texture
                       gl {:width  fbo-size
                           :height fbo-size
                           :filter glc/linear
                           :wrap   glc/clamp-to-edge})
          fbo         (buf/make-fbo-with-attachments
                       gl {:tex fbo-tex
                           :width fbo-size
                           :height fbo-size
                           :depth? true})
          image       (image/make-shader-spec
                       gl {:state    {:tex   fbo-tex
                                      :blend false}
                           :shader   img-shader
                           :viewport view-rect
                           :width    256
                           :height   256})
          model       (-> (s/sphere 1)
                          (g/as-mesh
                           {:mesh    (glm/indexed-gl-mesh 2048 #{#_:col :vnorm})
                            :attribs {;;:col (fn [_ _ v _] (col/rgba (m/madd (m/normalize v) 0.5 0.5)))
                                      :vnorm (fn [_ _ v _] (m/normalize v))}
                            :res 24})
                          (gl/as-gl-buffer-spec {})
                          (cam/apply (cam/perspective-camera {:eye (v/vec3 0 0 3) :aspect 1.0}))
                          (update :uniforms merge
                                  {:lightPos [0 2 2]
                                   :shininess 10
                                   :wrap 1
                                   :ambientCol [0 0.15 0.5]
                                   :diffuseCol [0.8 0.05 0.25]})
                          (assoc :shader main-shader)
                          (gl/make-buffers-in-spec gl glc/static-draw))]
      (pprint model)
      (swap! app assoc
             :model    model
             :fbo      fbo
             :fbo-size fbo-size
             :image    image)))

  (defn display
    [^GLAutoDrawable drawable t]
    (let [^GL3 gl (.. drawable getGL getGL3)
          {:keys [model fbo fbo-size image width height]} @app
          {:keys [shader] :as spec} model
          t       (* 0.25 t)
          model   (-> mat/M44 (g/rotate-x t) (g/rotate-y (* t 2)))]
      (gl/bind fbo)
      (doto gl
        (gl/set-viewport 0 0 fbo-size fbo-size)
        (gl/clear-color-and-depth-buffer col/GRAY 1)
        (gl/enable glc/cull-face)
        ;;(.glPolygonMode glc/front-and-back glc/line)
        (gl/draw-with-shader (assoc-in spec [:uniforms :model] model)))
      (gl/unbind fbo)
      (doto gl
        (gl/set-viewport 0 0 width height)
        (gl/clear-color-and-depth-buffer col/BLACK 1)
        (gl/disable glc/cull-face)
        ;;(.glPolygonMode glc/front-and-back glc/fill)
        (image/draw image))))

  (defn resize
    [_ x y w h]
    (swap! app assoc :width w :height h))

  (defn dispose [_] (jogl/stop-animator (:anim @app)))

  (defn key-pressed
    [^KeyEvent e]
    (condp = (.getKeyCode e)
      KeyEvent/VK_ESCAPE (jogl/destroy-window (:window @app))
      nil))

  (defn -main
    [& args]
    (reset!
     app
     (jogl/gl-window
      {:profile       :gl3
       :samples       4
       :double-buffer true
       :fullscreen    false
       :events        {:init    init
                       :display display
                       :dispose dispose
                       :resize  resize
                       :keys    {:press key-pressed}}}))
    nil)
#+END_SRC
