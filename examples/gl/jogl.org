* JOGL examples

** Example 1

#+BEGIN_SRC clojure :tangle ../../babel/examples/jogl/ex01.clj :mkdirp yes :padline no
  (ns thi.ng.geom.examples.jogl.ex01
    (:import
     [com.jogamp.opengl GL3 GLAutoDrawable]
     [com.jogamp.opengl.util Animator]
     [com.jogamp.newt.opengl GLWindow]
     [com.jogamp.newt.event MouseEvent KeyEvent])
    (:require
     [thi.ng.math.core :as m]
     [thi.ng.geom.core :as g]
     [thi.ng.geom.aabb :as a]
     [thi.ng.geom.attribs :as attr]
     [thi.ng.geom.vector :as v]
     [thi.ng.geom.matrix :as mat]
     [thi.ng.geom.gl.core :as gl]
     [thi.ng.geom.gl.buffers :as buf]
     [thi.ng.geom.gl.camera :as cam]
     [thi.ng.geom.gl.shaders :as sh]
     [thi.ng.geom.gl.glmesh :as glm]
     [thi.ng.geom.gl.jogl.core :as jogl]
     [thi.ng.geom.gl.jogl.constants :as glc]
     [clojure.pprint :refer [pprint]]
     [clojure.java.io :as io]))

  (def app (atom nil))

  (def shader
    {:vs "
  void main() {
    vCol = vec4(position.xy * 0.5 + 0.5, fract(time), 1.0);
    vUV = uv;
    gl_Position = proj * view * model * vec4(position, 1.0);
  }"
     :fs "out vec4 outCol;

  void main() {
    outCol = vCol * texture(tex, vUV);
  }"
     :version  330
     :attribs  {:position :vec3
                :uv       :vec2}
     :varying  {:vCol     :vec4
                :vUV      :vec2}
     :uniforms {:model :mat4
                :view  :mat4
                :proj  :mat4
                :tex   :sampler2D
                :time  :float}
     :state    {:depth-test true}})

  (defn init
    [^GLAutoDrawable drawable]
    (let [^GL3 gl (.. drawable getGL getGL3)
          tex     (buf/load-texture gl {:src (io/file "dev-resources/cubev.png")})
          spec    (-> (a/aabb 1)
                      (g/center)
                      (g/as-mesh {:mesh (glm/gl-mesh 12 #{:uv})
                                  :attribs {:uv (attr/face-attribs (attr/uv-cube-map-v 256 false))}})
                      (gl/as-gl-buffer-spec {})
                      (assoc :shader (sh/make-shader-from-spec gl shader))
                      (assoc-in [:shader :state :tex] tex)
                      (gl/make-buffers-in-spec gl glc/static-draw))]
      (pprint spec)
      (swap! app assoc
             :spec spec
             :zoom 1)))

  (defn display
    [^GLAutoDrawable drawable t]
    (let [^GL3 gl (.. drawable getGL getGL3)
          {:keys [shader vao] :as spec} (:spec @app)
          unis    (:uniforms shader)
          t       (* 0.25 t)
          model   (-> mat/M44 (g/rotate-x t) (g/rotate-y (* t 1.5)))
          view    (mat/look-at (v/vec3 0 0 (* 3 (:zoom @app))) (v/vec3) (v/vec3 0 1 0))]
      (doto gl
        (gl/clear-color-and-depth-buffer 0.3 0.3 0.3 1.0 1.0)
        (gl/draw-with-shader
         (update spec :uniforms assoc
                 :model model
                 :view view
                 :time t)))))

  (defn resize
    [_ x y w h]
    (swap! app assoc :width w :height h)
    (swap! app assoc-in [:spec :uniforms :proj]
           (mat/perspective 45 (/ w h) 0.1 10)))

  (defn key-pressed
    [^KeyEvent e]
    (condp = (.getKeyCode e)
      KeyEvent/VK_ESCAPE (jogl/dispose-window (:window @app) (:anim @app))
      nil))

  (defn mouse-moved
    [^MouseEvent e] (prn (.getX e) (.getY e)))

  (defn mousewheel-moved
    [^MouseEvent e deltas]
    (swap! app update :zoom
           #(m/clamp (+ % (* (nth deltas 1) 0.01)) 0.5 2)))

  (defn -main
    [& args]
    (reset!
     app
     (jogl/gl-window
      {:profile       :gl3
       :samples       4
       :double-buffer true
       :fullscreen    false
       :events        {:init    init
                       :display display
                       :resize  resize
                       :keys    {:press key-pressed}
                       :mouse   {:move  mouse-moved
                                 :wheel mousewheel-moved}}})))
#+END_SRC
