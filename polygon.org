* thi.ng.geom.polygon
** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  (ns thi.ng.geom.polygon
    (:require
     [thi.ng.common.data.core :as d]
     [thi.ng.common.math.core :as m :refer [PI HALF_PI THREE_HALVES_PI *eps*]]
     [thi.ng.geom.core :as g :refer [vec2 vec3]]
     [thi.ng.geom.triangle :as t]
     [thi.ng.geom.mesh :as mesh]
     [thi.ng.geom.types :as types])
    #+clj
    (:import
     [thi.ng.geom.types Circle Line2 Rect Polygon]))
#+END_SRC
** Constructor
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  (defn polygon
    ([points] (thi.ng.geom.types.Polygon. (vec (map vec2 points)) []))
    ([p & more] (thi.ng.geom.types.Polygon. (vec (map vec2 (cons p more))) [])))
#+END_SRC
** Type specific functions
*** Sutherland-Hodgeman convex clipping
 - http://en.wikipedia.org/wiki/Sutherland-Hodgman_algorithm
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  (defn clip-convex*
    [verts bounds]
    (let [verts (conj verts (first verts))
          bc (g/centroid bounds)
          ec-pos (fn [e p q] (:p (g/intersect-line e (thi.ng.geom.types.Line2. p q))))]
      (loop [cedges (g/edges bounds) points verts clipped []]
        (if-let [ce (first cedges)]
          (let [sign (g/classify-point ce bc)
                clipped (reduce
                         (fn [clipped [p q]]
                           (if (= sign (g/classify-point ce p))
                             (if (= sign (g/classify-point ce q))
                               (conj clipped q)
                               (conj clipped (ec-pos ce p q)))
                             (if (= sign (g/classify-point ce q))
                               (conj clipped (ec-pos ce p q) q)
                               clipped)))
                         [] (d/successive-nth 2 points))
                clipped (if (and (pos? (count clipped))
                                 (not (m/delta= (first clipped) (peek clipped))))
                          (conj clipped (first clipped))
                          clipped)]
            (recur (rest cedges) clipped points))
          (distinct (butlast points))))))
#+END_SRC
*** Convex hull
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  (defn- h-segment
    [verts [px py :as p] pred theta ps]
    (let [[q] (reduce
               (fn [state [qx qy :as q]]
                 (if (pred qy py)
                   (let [d (m/abs-diff theta (g/heading-xy (vec2 (- qx px) (- qy py))))]
                     (if (< d (state 1)) [q d] state))
                   state))
               [nil HALF_PI] ps)]
      (if q
        (recur (conj verts q) q pred theta (d/all-after q ps))
        verts)))

  (defn convex-hull*
    [points]
    (let [[p & more :as ps] (sort-by first points)
          rps (reverse ps)]
      (butlast
       (reduce
        (fn [v [pred t ps]] (h-segment v (peek v) pred t (d/all-after (peek v) ps)))
        [p] [[<= THREE_HALVES_PI more] [>= 0.0 more]
             [>= HALF_PI rps] [<= PI rps]]))))
#+END_SRC
*** TODO complete porting
#+BEGIN_SRC clojure
  ;; :tangle babel/src-cljx/thi/ng/geom/polygon.cljx

  (defn delta-contains
    [points p eps]
    (some #(m/delta= p % eps) points))

  (defn crossed-edge?
    [e a b]
    (let [{t :type ua :ua} (g/intersect-line e {:p a :q b})]
      (and (= :intersect t) (m/in-range? 0.01 0.99 ua))))

  (defn tesselate
    [poly]
    (let [m (apply mesh2 (triangulate (:points poly)))
          assoc-bounds #(assoc! % %2 (g/bounding-rect* %2))
          fbounds (reduce assoc-bounds (transient {}) (:faces m))
          [m] (reduce
               (fn [[m fbounds] e]
                 (let [eb (g/bounds e)
                       faces (filter
                              (fn [[a b c :as f]]
                                (and (r/intersect-rect? eb (get fbounds f))
                                     (or (crossed-edge? e a b)
                                         (crossed-edge? e b c)
                                         (crossed-edge? e c a))))
                              (:faces m))
                       [m nf] (slice-with m e faces)
                       fbounds (reduce assoc-bounds fbounds nf)]
                   [m fbounds]))
               [m fbounds] (g/edges poly))]
      (keep-faces m #(g/contains-point? poly (t/centroid2 %)))))
#+END_SRC
** Protocol implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  (extend-type thi.ng.geom.types.Polygon
#+END_SRC
*** PGraph
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  g/PGraph
  (vertices
   [this] (:points this))
  (edges
   [{points :points}]
   (g/edges* #(thi.ng.geom.types.Line2. (% 0) (% 1))
             (concat points [(first points)])))
  (vertex-neighbors
   [this v] (d/neighbors v (g/vertices this)))
  (vertex-valence
   [this v] (if ((set (g/vertices this)) (vec2 v)) 2 0))
#+END_SRC
*** PShape
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  g/PShape
  (area
   [{points :points}]
   (->> points
        (d/rotate-left 1)
        (reduce (fn [[a p] v] [(+ a (g/cross p v)) v]) [0.0 (first points)])
        first
        (* 0.5)))
  (bounds
   [this] (g/bounding-rect* (:points this)))
  (center
   ([this] (g/center this [0.0 0.0]))
   ([this o]
      (let [d (g/sub o (g/centroid this))
            p (->> this
                   :points
                   (map #(g/add d %))
                   (vec))]
        (thi.ng.geom.types.Polygon. p []))))
  (centroid
   [{points :points :as this}]
   (let [c (->> points
                (d/rotate-left 1)
                (reduce (fn [[c p] v] [(g/madd (g/add p v) (g/cross p v) c) v])
                        [(vec2) (first points)])
                (first))]
     (g/scale c (/ 1.0 (* 6 (g/area this))))))
  (width
   [this] (g/axis-range* 0 (:points this)))
  (height
   [this] (g/axis-range* 1 (:points this)))
  (depth [this] 0)
#+END_SRC
*** PShape2
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  g/PShape2
  (bounding-circle
   [this] (g/bounding-circle* (g/centroid this) (:points this)))
  (circumference
   [{points :points}]
   (d/reduce-pairs + g/dist (concat points [(first points)])))
#+END_SRC
*** PBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  g/PBoundary
  (classify-point
   [this p] nil) ; TODO
  (closest-point
   [this p] (g/closest-point* (g/edges this) p))
  (contains-point?
   [{points :points} p]
   (if (some #{p} points) true
       (let [[x y] p]
         (first
          (reduce
           (fn [[in [px py]] [vx vy]]
             (if (and (or (and (< vy y) (>= py y)) (and (< py y) (>= vy y)))
                      (< (+ vx (* (/ (- y vy) (- py vy)) (- px vx))) x))
               [(not in) [vx vy]] [in [vx vy]]))
           [false (last points)] points)))))
#+END_SRC
*** PSampleable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  g/PSampleable
  (point-at
   [{points :points} t] (g/point-at* t (conj points (first points))))
  (random-point
   [this] (g/point-at this (m/random)))
  (random-point-inside [this] nil) ; TODO
  (sample-uniform
   [{points :points} udist include-last?]
   (g/sample-uniform* udist include-last? (conj points (first points))))
#+END_SRC
*** PTessellateable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  g/PTessellateable
  (tessellate
   [{points :points :as this}]
   (-> points
       (g/tessellate* (g/centroid this))
       (map #(thi.ng.geom.types.Triangle2. (% 0) (% 1) (% 2)))))
#+END_SRC
*** PExtrudeable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  g/PExtrudeable
  (extrude
   [{points :points :as this}
    {:keys [depth scale top? bottom?] :or {depth 1.0 scale 1.0 top? true bottom? true}}]
   (let [tpoints (if (= 1.0 scale) points (:points (g/scale-size this scale)))
         [points tpoints] (if (pos? (g/area this))
                            [(reverse points) (reverse tpoints)]
                            [points tpoints])
         off (vec3 0 0 depth)
         c (g/centroid this)
         bottom (->> points
                     (g/tessellate* c)
                     (map (fn [[a b c]] [(vec3 a) (vec3 b) (vec3 c)])))
         top (->> tpoints
                  (g/tessellate* c)
                  (map (fn [[a b c]] [(g/add off a) (g/add off b) (g/add off c)])))]
     (apply mesh/mesh3
            (concat
             (when bottom? (map (fn [[a b c]] [b a c]) bottom))
             (mapcat (fn [[a1 _ b1] [a2 _ b2]] [[b1 a1 a2] [b2 b1 a2]]) bottom top)
             (when top? top)))))
#+END_SRC
*** PTransformable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  g/PTransformable
  (scale
   ([this s] (thi.ng.geom.types.Polygon. (vec (map #(g/scale % s) (:points this))) []))
   ([this a b] (thi.ng.geom.types.Polygon. (vec (map #(g/scale % a b) (:points this))) [])))
  (scale-size
   [this s]
   (let [c (g/centroid this)]
     (thi.ng.geom.types.Polygon.
      (vec (map #(-> % (g/sub c) (g/madd s c)) (:points this))) [])))
  (translate
   [this t]
   (thi.ng.geom.types.Polygon. (vec (map #(g/add % t) (:points this))) []))
#+END_SRC
*** End of implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  )
#+END_SRC
