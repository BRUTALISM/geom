* thi.ng.geom.polygon
** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  (ns thi.ng.geom.polygon
    (:require
     [thi.ng.common.data.core :as d]
     [thi.ng.common.math.core :as m :refer [PI HALF_PI THREE_HALVES_PI *eps*]]
     [thi.ng.geom.core :as g :refer [vec2 vec3]]
     [thi.ng.geom.line :as l]
     [thi.ng.geom.triangle :as t]
     [thi.ng.geom.rect :as r]
     [thi.ng.geom.delaunay :as dl]
     [thi.ng.geom.mesh :as mesh]
     [thi.ng.geom.types :as types])
    #+clj
    (:import
     [thi.ng.geom.types Circle Line2 Rect Polygon]))
#+END_SRC
** Constructor
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  (defn polygon
    ([points] (thi.ng.geom.types.Polygon. (mapv vec2 points) []))
    ([p & more] (thi.ng.geom.types.Polygon. (mapv vec2 (cons p more)) [])))
#+END_SRC
** Type specific functions
*** Sutherland-Hodgeman convex clipping
 - http://en.wikipedia.org/wiki/Sutherland-Hodgman_algorithm
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  (defn clip-convex*
    [verts bounds]
    (let [verts (conj verts (first verts))
          bc (g/centroid bounds)
          ec-pos (fn [e p q] (:p (g/intersect-line e (thi.ng.geom.types.Line2. p q))))]
      (loop [cedges (g/edges bounds) points verts clipped []]
        (if-let [ce (first cedges)]
          (let [sign (g/classify-point ce bc)
                clipped (reduce
                         (fn [clipped [p q]]
                           (if (= sign (g/classify-point ce p))
                             (if (= sign (g/classify-point ce q))
                               (conj clipped q)
                               (conj clipped (ec-pos ce p q)))
                             (if (= sign (g/classify-point ce q))
                               (conj clipped (ec-pos ce p q) q)
                               clipped)))
                         [] (d/successive-nth 2 points))
                clipped (if (and (pos? (count clipped))
                                 (not (m/delta= (first clipped) (peek clipped))))
                          (conj clipped (first clipped))
                          clipped)]
            (recur (rest cedges) clipped points))
          (distinct (butlast points))))))
#+END_SRC
*** Convex hull
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  (defn- h-segment
    [verts [px py :as p] pred theta ps]
    (let [[q] (reduce
               (fn [state [qx qy :as q]]
                 (if (pred qy py)
                   (let [d (m/abs-diff theta (g/heading-xy (vec2 (- qx px) (- qy py))))]
                     (if (< d (state 1)) [q d] state))
                   state))
               [nil HALF_PI] ps)]
      (if q
        (recur (conj verts q) q pred theta (d/all-after q ps))
        verts)))

  (defn convex-hull*
    [points]
    (let [[p & more :as ps] (sort-by first points)
          rps (reverse ps)]
      (butlast
       (reduce
        (fn [v [pred t ps]] (h-segment v (peek v) pred t (d/all-after (peek v) ps)))
        [p] [[<= THREE_HALVES_PI more] [>= 0.0 more]
             [>= HALF_PI rps] [<= PI rps]]))))
#+END_SRC
*** Tessellation
**** TODO move delta-contains into core
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  (defn delta-contains
    [points p eps]
    (some #(m/delta= p % eps) points))

  (defn snip
    [points a b c nv verts]
    (let [[ax ay] a [bx by] b [cx cy] c
          cp (- (* (- bx ax) (- cy ay)) (* (- by ay) (- cx ax)))]
      (when (< m/*eps* cp)
        (not (some #(t/contains-point2* a b c %)
                   (disj (set (map points (subvec verts 0 nv))) a b c))))))

  (defn tessellate*
    [p]
    (let [[points area] (if (instance? thi.ng.geom.types.Polygon p)
                          [(:points p) (g/area p)] [(vec p) (g/area (polygon p))])
          nv (count points)
          verts (vec (if (pos? area) (range nv) (range (dec nv) -1 -1)))]
      (loop [result [], verts verts, v (dec nv), nv nv, cnt (dec (* 2 nv))]
        (if (= nv 2)
          result
          (when (pos? cnt)
            (let [u (if (<= nv v) 0 v)
                  v (inc u) v (if (<= nv v) 0 v)
                  w (inc v) w (if (<= nv w) 0 w)
                  a (points (verts u))
                  b (points (verts v))
                  c (points (verts w))]
              (if (snip points a b c nv verts)
                (let [result (conj result [a b c])
                      verts (vec (concat (subvec verts 0 v) (subvec verts (inc v))))
                      nv (dec nv)]
                  (recur result verts v nv (* 2 nv)))
                (recur result verts v nv (dec cnt)))))))))
#+END_SRC
** Protocol implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  (extend-type thi.ng.geom.types.Polygon
#+END_SRC
*** PGraph
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  g/PGraph
  (vertices
   [this] (:points this))
  (edges
   [{points :points}]
   (g/edges* #(thi.ng.geom.types.Line2. (% 0) (% 1))
             (concat points [(first points)])))
  (vertex-neighbors
   [this v] (d/neighbors v (g/vertices this)))
  (vertex-valence
   [this v] (if ((set (g/vertices this)) (vec2 v)) 2 0))
#+END_SRC
*** PShape
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  g/PShape
  (area
   [{points :points}]
   (->> points
        (d/rotate-left 1)
        (reduce (fn [[a p] v] [(+ a (g/cross p v)) v]) [0.0 (first points)])
        first
        (* 0.5)))
  (bounds
   [this] (g/bounding-rect* (:points this)))
  (center
   ([this] (g/center this [0.0 0.0]))
   ([this o]
      (let [d (g/sub o (g/centroid this))
            p (->> this
                   :points
                   (map #(g/add d %))
                   (vec))]
        (thi.ng.geom.types.Polygon. p []))))
  (centroid
   [{points :points :as this}]
   (let [c (->> points
                (d/rotate-left 1)
                (reduce (fn [[c p] v] [(g/madd (g/add p v) (g/cross p v) c) v])
                        [(vec2) (first points)])
                (first))]
     (g/scale c (/ 1.0 (* 6 (g/area this))))))
  (width
   [this] (g/axis-range* 0 (:points this)))
  (height
   [this] (g/axis-range* 1 (:points this)))
  (depth [this] 0)
#+END_SRC
*** PShape2
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  g/PShape2
  (bounding-circle
   [this] (g/bounding-circle* (g/centroid this) (:points this)))
  (circumference
   [{points :points}]
   (d/reduce-pairs + g/dist (concat points [(first points)])))
#+END_SRC
*** PBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  g/PBoundary
  (classify-point
   [this p] nil) ; TODO
  (closest-point
   [this p] (g/closest-point* (g/edges this) p))
  (contains-point?
   [{points :points} p]
   (if (some #{p} points) true
       (let [[x y] p]
         (first
          (reduce
           (fn [[in [px py]] [vx vy]]
             (if (and (or (and (< vy y) (>= py y)) (and (< py y) (>= vy y)))
                      (< (+ vx (* (/ (- y vy) (- py vy)) (- px vx))) x))
               [(not in) [vx vy]] [in [vx vy]]))
           [false (last points)] points)))))
#+END_SRC
*** PSampleable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  g/PSampleable
  (point-at
   [{points :points} t] (g/point-at* t (conj points (first points))))
  (random-point
   [this] (g/point-at this (m/random)))
  (random-point-inside [this] nil) ; TODO
  (sample-uniform
   [{points :points} udist include-last?]
   (g/sample-uniform* udist include-last? (conj points (first points))))
#+END_SRC
*** PTessellateable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  g/PTessellateable
  (tessellate
   [this] (map #(thi.ng.geom.types.Triangle2. (% 0) (% 1) (% 2)) (tessellate* this)))
#+END_SRC
*** PExtrudeable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  g/PExtrudeable
  (extrude
      [{points :points :as this}
       {:keys [depth offset scale top? bottom?] :or {depth 1.0 scale 1.0 top? true bottom? true}}]
      (let [points (if (neg? (g/area this)) (reverse points) points)
            tpoints (if (= 1.0 scale) points (:points (g/scale-size (polygon points) scale)))
            off (or offset (vec3 0 0 depth))
            points3 (mapv #(vec3 %) points)
            tpoints3 (mapv #(g/add off %) tpoints)]
        (mesh/into-mesh
         (mesh/mesh3) nil
         (concat
          (when bottom?
            (->> points
                 (tessellate*)
                 (map (fn [[a b c]] [(vec3 b) (vec3 a) (vec3 c)]))))
          (mapcat (fn [[a1 b1] [a2 b2]] [[a1 b1 a2] [b1 b2 a2]])
                  (d/successive-nth 2 (conj points3 (points3 0)))
                  (d/successive-nth 2 (conj tpoints3 (tpoints3 0))))
          (when top?
            (->> tpoints
                 (tessellate*)
                 (map (fn [[a b c]] [(g/add off a) (g/add off b) (g/add off c)]))))))))
#+END_SRC
*** PTransformable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  g/PTransformable
  (scale
   ([this s] (thi.ng.geom.types.Polygon. (mapv #(g/scale % s) (:points this)) []))
   ([this a b] (thi.ng.geom.types.Polygon. (mapv #(g/scale % a b) (:points this)) [])))
  (scale-size
   [this s]
   (let [c (g/centroid this)]
     (thi.ng.geom.types.Polygon.
      (mapv #(-> % (g/sub c) (g/madd s c)) (:points this)) [])))
  (translate
   [this t]
   (thi.ng.geom.types.Polygon. (mapv #(g/add % t) (:points this)) []))
#+END_SRC
*** End of implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  )
#+END_SRC
