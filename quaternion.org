#+SEQ_TODO:       TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:           Write(w) Update(u) Fix(f) Check(c) noexport(n)
#+EXPORT_EXCLUDE_TAGS: noexport

* Quaternion
** Implementation
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core/quat.cljx
  (deftype Quaternion [^double x ^double y ^double z ^double w _meta]
#+END_SRC
*** Clojure protocols
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core/quat.cljx
    ,#+clj clojure.lang.IObj
    ,#+clj (meta [_] _meta)
    ,#+clj (withMeta [_ m*] (Quaternion. x y z w m*))
    ,#+cljs IMeta
    ,#+cljs (-meta [_] _meta)
    ,#+cljs IWithMeta
    ,#+cljs (-with-meta [_ m*] (Quaternion. x y z w m*))
#+END_SRC
******
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core/quat.cljx
    PTransform
    (scale [_ s]
      (Quaternion. (clojure.core/* x s) (clojure.core/* y s) (clojure.core/* z s) (clojure.core/* w s) _meta))
#+END_SRC
*** PMatrix
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core/quat.cljx
  PMathOps
  (+ [_ q]
     (let [q ^Quaternion q]
       (Quaternion. (clojure.core/+ x (.-x q)) (clojure.core/+ y (.-y q)) (clojure.core/+ z (.-z q)) (clojure.core/+ w (.-w q)) _meta)))
  (- [_ q]
     (let [q ^Quaternion q]
       (Quaternion. (clojure.core/- x (.-x q)) (clojure.core/- y (.-y q)) (clojure.core/- z (.-z q)) (clojure.core/- w (.-w q)) _meta)))
  (clojure.core/* [_ q]
     (let [q ^Quaternion q
           qx (.-x q) qy (.-y q) qz (.-z q) qw (.-w q)]
       (Quaternion.
        (clojure.core/- (clojure.core/+ (clojure.core/+ (clojure.core/* x qw) (clojure.core/* w qx)) (clojure.core/* y qz)) (clojure.core/* z qy))
        (clojure.core/- (clojure.core/+ (clojure.core/+ (clojure.core/* y qw) (clojure.core/* w qy)) (clojure.core/* z qx)) (clojure.core/* x qz))
        (clojure.core/- (clojure.core/+ (clojure.core/+ (clojure.core/* z qw) (clojure.core/* w qz)) (clojure.core/* x qy)) (clojure.core/* y qx))
        (clojure.core/- (clojure.core/- (clojure.core/- (clojure.core/* w qw) (clojure.core/* x qx)) (clojure.core/* y qy)) (clojure.core/* z qz))
        _meta)))
#+END_SRC
*** PDotProduct
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core/quat.cljx  
  PDotProduct
  (dot [_ q]
    (let [q ^Quaternion q]
      (clojure.core/+ (clojure.core/+ (clojure.core/+ (clojure.core/* x (.-x q)) (clojure.core/* y (.-y q))) (clojure.core/* z (.-z q))) (clojure.core/* w (.-w q)))))
#+END_SRC
*** PMagnitude
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core/quat.cljx
  PMagnitude
  (mag-squared [_]
    (clojure.core/+ (clojure.core/+ (clojure.core/+ (clojure.core/* x x) (clojure.core/* y y)) (clojure.core/* z z)) (clojure.core/* w w)))
  (mag [_]
    (Math/sqrt (clojure.core/+ (clojure.core/+ (clojure.core/+ (clojure.core/* x x) (clojure.core/* y y)) (clojure.core/* z z)) (clojure.core/* w w))))
#+END_SRC
*** PNormalize
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core/quat.cljx
  PNormalize
  (normalize [_]
    (let [mag (clojure.core/+ (clojure.core/+ (clojure.core/+ (clojure.core/* x x) (clojure.core/* y y)) (clojure.core/* z z)) (clojure.core/* w w))]
      (if (> mag *eps*)
        (let [m (/ mag)]
          (Quaternion. (clojure.core/* x m) (clojure.core/* y m) (clojure.core/* z m) (clojure.core/* w m) _meta))
        _)))
#+END_SRC
*** PInvert
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core/quat.cljx
  PInvert
  (invert [_]
    (let [d (mag-squared _)
          d (if (zero? d) 0.0 (/ d))
          id (clojure.core/- d)]
      (Quaternion. (clojure.core/* x id) (clojure.core/* y id) (clojure.core/* z id) (clojure.core/* w d) _meta)))
#+END_SRC
*** PInterpolate
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core/quat.cljx
  PInterpolate
  (mix [_ q] (mix _ q 0.5))
  (mix [_ q t]
    (let [d (dot _ q)]
      (if (>= (m/abs d) 1.0)
        _
        (let [theta (Math/acos d)
              stheta (Math/sqrt (clojure.core/- 1.0 (clojure.core/* d d)))
              [a b] (if (< (m/abs stheta) 0.001)
                      [0.5 0.5]
                      [(/ (Math/sin (clojure.core/* theta (clojure.core/- 1.0 t))) stheta)
                       (/ (Math/sin (clojure.core/* theta t)) stheta)])
              q ^Quaternion q]
          (Quaternion.
           (m/madd x a (clojure.core/* (.-x q) b))
           (m/madd y a (clojure.core/* (.-y q) b))
           (m/madd z a (clojure.core/* (.-z q) b))
           (m/madd w a (clojure.core/* (.-w q) b))
           _meta)))))
#+END_SRC
*** PMatrixConvert
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core/quat.cljx
  PMatrixConvert
  (as-matrix [_]
    (let [x2 (clojure.core/+ x x) y2 (clojure.core/+ y y) z2 (clojure.core/+ z z)
          xx (clojure.core/* x x2) xy (clojure.core/* x y2) xz (clojure.core/* x z2)
          yy (clojure.core/* y y2) yz (clojure.core/* y z2) zz (clojure.core/* z z2)
          wx (clojure.core/* w x2) wy (clojure.core/* w y2) wz (clojure.core/* w z2)]
      (Matrix44.
       (clojure.core/- 1.0 (clojure.core/+ yy zz)) (clojure.core/+ xy wz) (clojure.core/- xz wy) 0.0
       (clojure.core/- xy wz) (clojure.core/- 1.0 (clojure.core/+ xx zz)) (clojure.core/+ yz wx) 0.0
       (clojure.core/+ xz wy) (clojure.core/- yz wx) (clojure.core/- 1.0 (clojure.core/+ xx yy)) 0.0
       0.0 0.0 0.0 1.0)))
#+END_SRC
*** PVectorTransform
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core/quat.cljx
  PVectorTransform
  (transform-vector [_ [vx vy vz :as v]]
    (let [ix (clojure.core/- (clojure.core/+ (clojure.core/* w vx) (clojure.core/* y vz)) (clojure.core/* z vy))
          iy (clojure.core/- (clojure.core/+ (clojure.core/* w vy) (clojure.core/* z vx)) (clojure.core/* x vz))
          iz (clojure.core/- (clojure.core/+ (clojure.core/* w vz) (clojure.core/* x vy)) (clojure.core/* y vx))
          iw (clojure.core/- (clojure.core/- (clojure.core/* (clojure.core/- x) vx) (clojure.core/* y vy)) (clojure.core/* z vz))]
      (Vec3.
       (clojure.core/- (clojure.core/+ (clojure.core/+ (clojure.core/* ix w) (clojure.core/* iw (clojure.core/- x))) (clojure.core/* iy (clojure.core/- z))) (clojure.core/* iz (clojure.core/- y)))
       (clojure.core/- (clojure.core/+ (clojure.core/+ (clojure.core/* iy w) (clojure.core/* iw (clojure.core/- y))) (clojure.core/* iz (clojure.core/- x))) (clojure.core/* ix (clojure.core/- z)))
       (clojure.core/- (clojure.core/+ (clojure.core/+ (clojure.core/* iz w) (clojure.core/* iw (clojure.core/- z))) (clojure.core/* ix (clojure.core/- y))) (clojure.core/* iy (clojure.core/- x)))
       (meta v))))
#+END_SRC
*** End of implementation
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core/quat.cljx
    )
#+END_SRC
** Constructors
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core/quat.cljx
  (defn quat
    ([[x y z] w] (Quaternion. x y z w nil))
    ([[x y z w]] (Quaternion. x y z w nil))
    ([x y z w] (Quaternion. x y z w nil)))
  
  (defn quat-from-axis-angle
    [axis theta]
    (let [theta (clojure.core/* theta 0.5)]
      (quat (normalize (vec3 axis) (Math/sin theta)) (Math/cos theta))))
  
  (defn quat-from-euler
    [^double pitch ^double yaw ^double roll]
    (let [pitch (clojure.core/* pitch 0.5) yaw (clojure.core/* yaw 0.5) roll (clojure.core/* roll 0.5)
          sp (Math/sin pitch) cp (Math/cos pitch)
          sy (Math/sin yaw) cy (Math/cos yaw)
          sr (Math/sin roll) cr (Math/cos roll)
          spsy (clojure.core/* sp sy) cpcy (clojure.core/* cp cy)]
      (Quaternion.
       (clojure.core/- (clojure.core/* sr cpcy) (clojure.core/* cr spsy))
       (clojure.core/+ (clojure.core/* (clojure.core/* cr sp) cy) (clojure.core/* (clojure.core/* sr cp) sy))
       (clojure.core/- (clojure.core/* (clojure.core/* cr cp) sy) (clojure.core/* (clojure.core/* sr sp) cy))
       (clojure.core/+ (clojure.core/* cr cpcy) (clojure.core/* sr spsy))
       nil)))
  
  (defn quat-from-matrix44
    [^Matrix44 m]
    (let [trace (clojure.core/+ (clojure.core/+ (.-m00 m) (.-m11 m)) (.-m22 m))]
      (if (pos? trace)
        (let [s (Math/sqrt (clojure.core/+ 1.0 trace))
              w (clojure.core/* s 0.5)
              s (/ -0.5 s)]
          (Quaternion.
           (m/madd (.-m21 m) s (.-m12 m))
           (m/madd (.-m02 m) s (.-m20 m))
           (m/madd (.-m10 m) s (.-m01 m))
           w nil))
        (let [[i mi] (if (> (.-m11 m) (.-m00 m))
                       [1 (.-m11 m)] [0 (.-m00 m)])
              [i mi] (if (> (.-m22 m) mi)
                       [2 (.-m22 m)] [i mi])]
          (condp = i
            0 (let [s (Math/sqrt (clojure.core/+ 1.0 (clojure.core/+ (clojure.core/- mi (.-m11 m)) (.-m22 m))))
                    x (clojure.core/* s 0.5)
                    s (/ 0.5 s)]
                (Quaternion. ; i=0 j=1 k=2
                 x
                 (clojure.core/* (clojure.core/+ (.-m10 m) (.-m01 m)) s)
                 (clojure.core/* (clojure.core/+ (.-m20 m) (.-m02 m)) s)
                 (clojure.core/* (clojure.core/- (.-m21 m) (.-m12 m)) s) nil))
            1 (let [s (Math/sqrt (clojure.core/+ 1.0 (clojure.core/+ (clojure.core/- mi (.-m22 m)) (.-m00 m))))
                    x (clojure.core/* s 0.5)
                    s (/ 0.5 s)]
                (Quaternion. ; i=1 j=2 k=0
                 (clojure.core/* (clojure.core/+ (.-m10 m) (.-m01 m)) s)
                 x
                 (clojure.core/* (clojure.core/+ (.-m12 m) (.-m21 m)) s)
                 (clojure.core/* (clojure.core/- (.-m20 m) (.-m02 m)) s) nil))
            2 (let [s (Math/sqrt (clojure.core/+ 1.0 (clojure.core/+ (clojure.core/- mi (.-m00 m)) (.-m11 m))))
                    x (clojure.core/* s 0.5)
                    s (/ 0.5 s)]
                (Quaternion. ; i=2 j=0 k=1
                 (clojure.core/* (clojure.core/+ (.-m20 m) (.-m02 m)) s)
                 (clojure.core/* (clojure.core/+ (.-m21 m) (.-m12 m)) s)
                 x
                 (clojure.core/* (clojure.core/- (.-m01 m) (.-m10 m)) s) nil)))))))
  
  (defn alignment-quat
    [target forward]
    (let [target (normalize target)
          forward (normalize forward)
          axis (cross forward target)
          len (mag axis)
          theta (Math/atan2 len (dot forward target))]
      (quat-from-axis-angle axis theta)))
#+END_SRC
