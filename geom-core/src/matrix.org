#+SETUPFILE: ../../src/setup.org

* Namespace: thi.ng.geom.core.matrix

** Namespace declaration                                           :noexport:
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/matrix.cljx :mkdirp yes :padline no
  (ns thi.ng.geom.core.matrix
    (:require
     [thi.ng.geom.core.api :as api]
     [thi.ng.geom.core.vector :as v]
     [thi.ng.common.math.core :as m :refer [*eps* PI TWO_PI]]
     ,#+clj [thi.ng.macromath.core :as mm]
     ,#+clj [thi.ng.geom.core.macros :as gmc])
    ,#+cljs
    (:require-macros
     [thi.ng.macromath.core :as mm]
     [thi.ng.geom.core.macros :as gmc])
    ,#+clj
    (:import
     [thi.ng.geom.core.vector Vec2 Vec3]))
#+END_SRC

#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/matrix.cljx
  (declare M32 M44)
#+END_SRC

** Matrix macros
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/macros.clj :mkdirp yes :padline no
  (ns thi.ng.geom.core.macros
    (:require [thi.ng.macromath.core :as mm]))

  (defmacro det-item
    [a b c d, e f g h, i j k l, m n o p]
    `(+ (mm/sub (mm/mul ~a ~b ~c ~d)
             (mm/mul ~e ~f ~g ~h)
             (mm/mul ~i ~j ~k ~l))
        (mm/mul ~m ~n ~o ~p)))
  
  (defmacro inv-item
    [a b c d e f g]
    `(* (mm/msubadd ~a ~b ~c ~d ~e ~f) ~g))
#+END_SRC

** Matrix implementations
*** 3x2 Matrix (Affine 2D transform)
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/matrix.cljx
  (defrecord Matrix32
    #+clj  [^double m00 ^double m01 ^double m02
            ^double m10 ^double m11 ^double m12]
    #+cljs [m00 m01 m02 m10 m11 m12]
#+END_SRC
**** PMathOps
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/matrix.cljx
  api/PMathOps
  (*
   [_ m]
   (let [m ^Matrix32 m]
     (Matrix32.
      (mm/madd m00 (.-m00 m) m01 (.-m10 m))
      (mm/madd m00 (.-m01 m) m01 (.-m11 m))
      (mm/madd m00 (.-m02 m) m01 (.-m12 m) m02)
      (mm/madd m10 (.-m00 m) m11 (.-m10 m))
      (mm/madd m10 (.-m01 m) m11 (.-m11 m))
      (mm/madd m10 (.-m02 m) m11 (.-m12 m) m12))))
#+END_SRC
**** PDeterminant
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/matrix.cljx
  api/PDeterminant
  (determinant
   [_] (mm/msub m00 m11 m01 m10))
#+END_SRC
**** PInvert
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/matrix.cljx
  api/PInvert
  (invert
   [_]
   (let [d (api/determinant _)]
     (when-not (zero? d)
       (Matrix32.
        (mm/div m11 d) (- (mm/div m01 d)) (mm/div (mm/msub m01 m12 m11 m02) d)
        (- (mm/div m10 d)) (mm/div m00 d) (mm/div (mm/msub m10 m02 m00 m12) d)))))
#+END_SRC
**** PRotate, PScale, PTranslate, PTransform
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/matrix.cljx
  api/PRotate
  (rotate
   [_ theta]
   (let [s (Math/sin theta), c (Math/cos theta)]
     (api/* _ (Matrix32. c (- s) 0.0, s c 0.0))))

  api/PScale
  (scale
   [_ s]
   (api/* _ (Matrix32.
             (if (number? s) s (s 0)) 0.0 0.0
             0.0 (if (number? s) s (s 1)) 0.0)))
  (scale
   [_ sx sy]
   (if (number? sx)
     (if (number? sy)
       (api/* _ (Matrix32. sx 0.0 0.0, 0.0 sy 0.0))
       (api/* _ (Matrix32. (mm/mul sx (sy 0)) 0.0 0.0, 0.0 (mm/mul sx (sy 1)) 0.0)))
     (if (number? sy)
       (api/* _ (Matrix32. (mm/mul sy (sx 0)) 0.0 0.0, 0.0 (mm/mul sy (sx 1)) 0.0))
       (api/* _ (Matrix32. (mm/mul (sx 0) (sy 0)) 0.0 0.0, 0.0 (mm/mul (sx 1) (sy 1)) 0.0)))))

  api/PShear
  (shear
   [_ s]
   (api/* _ (Matrix32.
             1.0 (if (number? s) s (s 0)) 0.0,
             (if (number? s) s (s 1)) 1.0 0.0)))
  (shear
   [_ sx sy]
   (api/* _ (Matrix32. 1.0 sx 0.0, sy 1.0 0.0)))

  api/PTranslate
  (translate
   [_ t]
   (api/* _ (Matrix32.
             1.0 0.0 (if (number? t) t (t 0))
             0.0 1.0 (if (number? t) t (t 1)))))
  (translate
   [_ tx ty]
   (if (number? tx)
     (if (number? ty)
       (api/* _ (Matrix32. 1.0 0.0 tx, 0.0 1.0 ty))
       (api/* _ (Matrix32. 1.0 0.0 (mm/mul tx (ty 0)), 0.0 1.0 (mm/mul tx (ty 1)))))
     (if (number? ty)
       (api/* _ (Matrix32. 1.0 0.0 (mm/mul ty (tx 0)), 0.0 1.0 (mm/mul ty (tx 1))))
       (api/* _ (Matrix32. 1.0 0.0 (mm/mul (tx 0) (ty 0)), 0.0 1.0 (mm/mul (tx 1) (ty 1)))))))

  api/PTransform
  (transform
   [_ matrix] (api/* _ matrix))
#+END_SRC
**** PVectorTransform
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/matrix.cljx
  api/PVectorTransform
  (transform-vector
   [_ [x y :as v]]
   (thi.ng.geom.core.vector.Vec2.
    (mm/madd x m00 y m01 m02)
    (mm/madd x m10 y m11 m12)))
#+END_SRC
**** End of implementations
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/matrix.cljx
  )
#+END_SRC
*** 4x4 Matrix
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/matrix.cljx
  (defrecord Matrix44
    #+clj  [^double m00 ^double m01 ^double m02 ^double m03
            ^double m10 ^double m11 ^double m12 ^double m13
            ^double m20 ^double m21 ^double m22 ^double m23
            ^double m30 ^double m31 ^double m32 ^double m33]
    #+cljs [m00 m01 m02 m03
            m10 m11 m12 m13
            m20 m21 m22 m23
            m30 m31 m32 m33]
#+END_SRC
**** PMathOps
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/matrix.cljx
  api/PMathOps
  (*
   [_ m]
   (let [^Matrix44 m m]
     (Matrix44.
      (mm/madd m00 (.-m00 m) m01 (.-m10 m) m02 (.-m20 m) m03 (.-m30 m))
      (mm/madd m00 (.-m01 m) m01 (.-m11 m) m02 (.-m21 m) m03 (.-m31 m))
      (mm/madd m00 (.-m02 m) m01 (.-m12 m) m02 (.-m22 m) m03 (.-m32 m))
      (mm/madd m00 (.-m03 m) m01 (.-m13 m) m02 (.-m23 m) m03 (.-m33 m))

      (mm/madd m10 (.-m00 m) m11 (.-m10 m) m12 (.-m20 m) m13 (.-m30 m))
      (mm/madd m10 (.-m01 m) m11 (.-m11 m) m12 (.-m21 m) m13 (.-m31 m))
      (mm/madd m10 (.-m02 m) m11 (.-m12 m) m12 (.-m22 m) m13 (.-m32 m))
      (mm/madd m10 (.-m03 m) m11 (.-m13 m) m12 (.-m23 m) m13 (.-m33 m))

      (mm/madd m20 (.-m00 m) m21 (.-m10 m) m22 (.-m20 m) m23 (.-m30 m))
      (mm/madd m20 (.-m01 m) m21 (.-m11 m) m22 (.-m21 m) m23 (.-m31 m))
      (mm/madd m20 (.-m02 m) m21 (.-m12 m) m22 (.-m22 m) m23 (.-m32 m))
      (mm/madd m20 (.-m03 m) m21 (.-m13 m) m22 (.-m23 m) m23 (.-m33 m))

      (mm/madd m30 (.-m00 m) m31 (.-m10 m) m32 (.-m20 m) m33 (.-m30 m))
      (mm/madd m30 (.-m01 m) m31 (.-m11 m) m32 (.-m21 m) m33 (.-m31 m))
      (mm/madd m30 (.-m02 m) m31 (.-m12 m) m32 (.-m22 m) m33 (.-m32 m))
      (mm/madd m30 (.-m03 m) m31 (.-m13 m) m32 (.-m23 m) m33 (.-m33 m)))))
#+END_SRC
**** PDeterminant
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/matrix.cljx
  api/PDeterminant
  (determinant
   [_]
   (reduce
    +
    [(gmc/det-item m30 m21 m12 m03 m20 m31 m12 m03 m30 m11 m22 m03 m10 m31 m22 m03)
     (gmc/det-item m20 m11 m32 m03 m10 m21 m32 m03 m30 m21 m02 m13 m20 m31 m02 m13)
     (gmc/det-item m30 m01 m22 m13 m00 m31 m22 m13 m20 m01 m32 m13 m00 m21 m32 m13)
     (gmc/det-item m30 m11 m02 m23 m10 m31 m02 m23 m30 m01 m12 m23 m00 m31 m12 m23)
     (gmc/det-item m10 m01 m32 m23 m00 m11 m32 m23 m20 m11 m02 m33 m10 m21 m02 m33)
     (gmc/det-item m20 m01 m12 m33 m00 m21 m12 m33 m10 m01 m22 m33 m00 m11 m22 m33)]))
#+END_SRC
**** PInvert
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/matrix.cljx
  api/PInvert
  (invert
   [_]
   (let [n00 (mm/msub m00 m11 m01 m10)
         n01 (mm/msub m00 m12 m02 m10)
         n02 (mm/msub m00 m13 m03 m10)
         n03 (mm/msub m01 m12 m02 m11)
         n04 (mm/msub m01 m13 m03 m11)
         n05 (mm/msub m02 m13 m03 m12)
         n06 (mm/msub m20 m31 m21 m30)
         n07 (mm/msub m20 m32 m22 m30)
         n08 (mm/msub m20 m33 m23 m30)
         n09 (mm/msub m21 m32 m22 m31)
         n10 (mm/msub m21 m33 m23 m31)
         n11 (mm/msub m22 m33 m23 m32)
         d (mm/add
            (mm/sub
             (mm/add
              (mm/add
               (mm/msub n00 n11 n01 n10)
               (mm/mul n02 n09))
              (mm/mul n03 n08))
             (mm/mul n04 n07))
            (mm/mul n05 n06))]
     (when-not (zero? d)
       (let [invd (mm/div 1.0 d)]
         (Matrix44.
          (gmc/inv-item m11 n11 m12 n10 m13 n09 invd)
          (gmc/inv-item m02 n10 m03 n09 (- m01) n11 invd)
          (gmc/inv-item m31 n05 m32 n04 m33 n03 invd)
          (gmc/inv-item m22 n04 m23 n03 (- m21) n05 invd)
          (gmc/inv-item m12 n08 m13 n07 (- m10) n11 invd)
          (gmc/inv-item m00 n11 m02 n08 m03 n07 invd)
          (gmc/inv-item m32 n02 m33 n01 (- m30) n05 invd)
          (gmc/inv-item m20 n05 m22 n02 m23 n01 invd)
          (gmc/inv-item m10 n10 m11 n08 m13 n06 invd)
          (gmc/inv-item m01 n08 m03 n06 (- m00) n10 invd)
          (gmc/inv-item m30 n04 m31 n02 m33 n00 invd)
          (gmc/inv-item m21 n02 m23 n00 (- m20) n04 invd)
          (gmc/inv-item m11 n07 m12 n06 (- m10) n09 invd)
          (gmc/inv-item m00 n09 m01 n07 m02 n06 invd)
          (gmc/inv-item m31 n01 m32 n00 (- m30) n03 invd)
          (gmc/inv-item m20 n03 m21 n01 m22 n00 invd))))))
#+END_SRC
**** PTranspose
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/matrix.cljx
  api/PTranspose
  (transpose
   [_]
   (Matrix44.
    m00 m10 m20 m30
    m01 m11 m21 m31
    m02 m12 m22 m32
    m03 m13 m23 m33))
#+END_SRC
**** Transformations
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/matrix.cljx
  api/PScale
  (scale
   [_ s]
   (let [[x y z] (if (number? s) [s s s] s)]   
     (api/* _ (assoc M44 :m00 x :m11 y :m22 z))))
  (scale
   [_ x y z]
   (api/* _ (assoc M44 :m00 x :m11 y :m22 z))) ;; TODO add scale vec support
  
  api/PRotate
  (rotate
   [_ theta] (api/rotate-z _ theta))
  
  api/PRotate3D
  (rotate-x
   [_ theta]
   (let [s (Math/sin theta), c (Math/cos theta)]
     (api/* _ (assoc M44 :m11 c :m12 (- s) :m21 s :m22 c))))
  (rotate-y
   [_ theta]
   (let [s (Math/sin theta), c (Math/cos theta)]
     (api/* _ (assoc M44 :m00 c :m02 s :m20 (- s) :m22 c))))
  (rotate-z
   [_ theta]
   (let [s (Math/sin theta), c (Math/cos theta)]
     (api/* _ (assoc M44 :m00 c :m01 (- s) :m10 s :m11 c))))
  (rotate-around-axis
   [_ [x y z] theta]
   (let [theta (- theta)
         s (Math/sin theta), c (Math/cos theta)
         sx (mm/mul s x)
         sy (mm/mul s y)
         sz (mm/mul s z)
         t (mm/sub 1.0 c)
         tx (mm/mul t x)
         ty (mm/mul t y)]
     (api/* _
        (Matrix44.
         (mm/madd tx x c) (mm/madd tx y sz) (mm/msub tx z sy) 0.0
         (mm/msub tx y sz) (mm/madd ty y c) (mm/madd ty z sx) 0.0
         (mm/madd tx z sy) (mm/msub ty z sx) (mm/madd (mm/mul t z) z c) 0.0
         0.0 0.0 0.0 1.0))))
  
  api/PTranslate
  (translate
   [_ t]
   (let [[x y z] (if (number? t) [t t t] t)]   
     (api/* _ (assoc M44 :m03 x :m13 y :m23 z))))
  (translate
   [_ x y z]
   (api/* _ (assoc M44 :m03 x :m13 y :m23 z)))
  
  api/PTransform
  (transform
   [_ matrix] (api/* _ matrix))
#+END_SRC
**** PVectorTransform
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/matrix.cljx
  api/PVectorTransform
  (transform-vector
   [_ [x y z w :as v]]
   (if w
     [(mm/madd x m00 y m01 z m02 w m03)
      (mm/madd x m10 y m11 z m12 w m13)
      (mm/madd x m20 y m21 z m22 w m23)
      (mm/madd x m30 y m31 z m32 w m33)]
     (thi.ng.geom.core.vector.Vec3.
      (mm/madd x m00 y m01 z m02 m03)
      (mm/madd x m10 y m11 z m12 m13)
      (mm/madd x m20 y m21 z m22 m23))))
#+END_SRC
**** End of implementation
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/matrix.cljx
    )
#+END_SRC
*** Constants
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/matrix.cljx
  (def ^:const M32
    (Matrix32.
     1.0 0.0 0.0
     0.0 1.0 0.0))

  (def ^:const M44
    (Matrix44.
     1.0 0.0 0.0 0.0
     0.0 1.0 0.0 0.0
     0.0 0.0 1.0 0.0
     0.0 0.0 0.0 1.0))
#+END_SRC

** Constructors

#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/matrix.cljx
  (defn matrix32
    ([] M32)
    ([[m00 m01 m02 m10 m11 m12]]
       (Matrix32. m00 m01 m02 m10 m11 m12))
    ([m00 m01 m02 m10 m11 m12]
       (Matrix32. m00 m01 m02 m10 m11 m12)))

  (defn matrix44
    ([] M44)
    ([[m00 m01 m02 m03 m10 m11 m12 m13 m20 m21 m22 m23 m30 m31 m32 m33]]
       (Matrix44. m00 m01 m02 m03 m10 m11 m12 m13 m20 m21 m22 m23 m30 m31 m32 m33))
    ([m00 m01 m02 m03 m10 m11 m12 m13 m20 m21 m22 m23 m30 m31 m32 m33]
       (Matrix44. m00 m01 m02 m03 m10 m11 m12 m13 m20 m21 m22 m23 m30 m31 m32 m33)))
#+END_SRC

** Matrix functions

#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/matrix.cljx
  (defn frustum
    "Sets up a viewing frustum, shaped like a truncated pyramid with the
    camera where the tip of the pyramid would be.
    This emulates the OpenGL function glFrustum()."
    [l t r b n f]
    (let [dx (- r l)
          dy (- t b)
          dz (- f n)]
      (Matrix44.
       (/ (* 2.0 n) dx) 0.0 (mm/adddiv r l dx) 0.0
       0.0 (/ (* 2.0 n) dy) (mm/adddiv t b dy) 0.0
       0.0 0.0 (- (mm/adddiv f n dz)) (/ (mm/mul -2.0 f n) dz)
       0.0 0.0 -1.0 0.0)))

  (defn frustum-bounds
    [fov aspect near]
    (let [rad (* 0.5 (m/radians fov))
          top (* near (Math/tan rad))
          right (* top aspect)]
      {:left (- right)
       :right right
       :top top
       :bottom (- top)}))

  (defn ortho
    "Returns an orthographic projection matrix, in which objects are the same size no
    matter how far away or nearby they are.
    This emulates the OpenGL function glOrtho()."
    [l t r b n f]
    (let[dx (- r l)
         dy (- t b)
         dz (- f n)]
      (Matrix44.
       (/ 2.0 dx) 0.0 0.0 (- (mm/adddiv r l dx))
       0.0 (/ 2.0 dy) 0.0 (- (mm/adddiv t b dy))
       0.0 0.0 (/ -2.0 dz) (- (mm/adddiv f n dz))
       0.0 0.0 0.0 1.0)))

  (defn perspective
    "Returns a perspective transform matrix, which makes far away objects appear
    smaller than nearby objects. The `aspect` argument should be the width
    divided by the height of your viewport and `fov` is the vertical angle
    of the field of view in degrees.
    This emulates the OpenGL function gluPerspective()."
    [fov aspect near far]
    (let [rad (* 0.5 (m/radians fov))
          cot (/ (Math/cos rad) (Math/sin rad))
          deltaz (- far near)
          a (/ cot aspect)
          b (- (mm/adddiv far near deltaz))
          c (/ (mm/mul -2.0 near far) deltaz)]
      (Matrix44.
       a 0.0 0.0 0.0
       0.0 cot 0.0 0.0
       0.0 0.0 b c
       0.0 0.0 -1.0 0.0)))

  (defn perspective-frustum
    [fov aspect near far]
    (let [{:keys [left right top bottom]} (frustum-bounds fov aspect near)]
      (frustum left top right bottom near far)))

  (defn look-at
    "Returns a matrix that puts the camera at the eye position looking
    toward the target point with the given up direction.
    This emulates the OpenGL function `gluLookAt()`."
    [eye target upvec]
    (let [[fx fy fz :as f] (api/normalize (api/- eye target))
          [sx sy sz :as s] (api/normalize (api/cross upvec f)) ;; FIXME
          [tx ty tz :as t] (api/normalize (api/cross f s))]    ;; FIXME
      (Matrix44.
       sx sy sz (- (api/dot s eye))
       tx ty tz (- (api/dot t eye))
       fx fy fz (- (api/dot f eye))
       0.0 0.0 0.0 1.0)))

  ;; FIXME add arity for pre-computed vpm matrix
  (defn unproject
    "Takes a vec3 in screenspace, view matrix, projection matrix and
    view rect. Returns vector in model space or nil."
    [v vmat pmat {:keys [p width height]}]
    (let [x (mm/msub (- (v 0) (p 0)) (/ 2.0 width) 1.0)
          y (mm/msub (- (v 1) (p 1)) (/ 2.0 height) 1.0)
          z (mm/msub (v 2) 2.0 1.0)
          vpm (api/* pmat vmat)]
      (if (api/invert vpm)
        (let [v' (api/transform-vector vpm [x y z 1.0])]
          (if-not (zero? (v' 3))
            (api/div (v/vec3 v') (v' 3)))))))
#+END_SRC
