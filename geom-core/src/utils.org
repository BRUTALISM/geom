#+SETUPFILE: ../../src/setup.org

* Namespace: thi.ng.geom.core.utils

** Point collection functions

*** Distance & length

#+BEGIN_SRC clojure :noweb-ref dist
  (defn closest-point-coeff
    [p a b]
    (let [d (g/- b a)]
      (/ (g/dot (g/- p a) d) (g/mag-squared d))))

  (defn closest-point-on-line
    [p a b]
    (g/mix a b (closest-point-coeff p a b)))

  (defn closest-point-on-segment
    [p a b]
    (let [t (closest-point-coeff p a b)]
      (cond
       (<= t 0.0) a
       (>= t 1.0) b
       :default (g/mix a b t))))

  (defn closest-point-on-segments
    [p segments]
    (let [[a & more] (map #(apply closest-point-on-segment p %) segments)]
      (loop [c a, d (g/dist-squared p a), more more]
        (if more
          (let [q (first more)
                d' (g/dist-squared p q)]
            (if (< d' d)
              (recur q d' (next more))
              (recur c d (next more))))
          c))))

  (defn max-dist
    [c points]
    (->> points
         (map #(g/dist-squared c %))
         (reduce max)
         (Math/sqrt)))

  (defn arc-length-index
    [points]
    (->> points
         (d/successive-nth 2)
         (map #(g/dist (% 0) (% 1)))
         (reductions + 0)
         (vec)))

  (defn arc-length
    [points]
    (d/reduce-pairs + g/dist points))
#+END_SRC

*** Centroid & centering

#+BEGIN_SRC clojure :noweb-ref center
  (defn centroid
    [[x & xs :as coll]]
    (case (count coll)
      0 nil
      1 x
      2 (g/mix x (first xs))
      3 (g/div (+ x (nth xs 0) (nth xs 1)) 3.0)
      4 (g/addm (+ x (first xs) (nth xs 1)) (nth xs 2) 0.25)
      (/ ((if (v/vec2? x) v/vec2-op-seq v/vec3-op-seq) + x xs)
         (count coll))))

  (defn center
    ([coll]
       (center (centroid coll) (vec2) coll))
    ([c' coll]
       (center (centroid coll) c' coll))
    ([c c' coll]
       (let [d (- c' c)] (mapv #(+ % d) coll))))
#+END_SRC

*** Bounds

#+BEGIN_SRC clojure :noweb-ref bounds
  (defn bounding-rect
    [[x & xs :as coll]]
    (let [c (count coll)]
      (cond
       (> c 1) (let [p (v/vec2-op-seq min x xs)
                     q (v/vec2-op-seq max x xs)
                     [w h] (- q p)]
                 [p w h])
       (= c 1) [x 0.0 0.0]
       :default nil)))

  (defn bounding-box
    [[x & xs :as coll]]
    (let [c (count coll)]
      (cond
       (> c 1) (let [p (v/vec3-op-seq min x xs)
                     q (v/vec3-op-seq max x xs)]
                 [p (- q p)])
       (= c 1) [x (vec3)]
       :default nil)))

  (defn radial-bounds
    [ctor c r-or-points]
    [(ctor c)
     (if (coll? r-or-points)
       (max-dist c r-or-points)
       r-or-points)])

  (defn axis-bounds
    [axis coll]
    (let [xs (map #(nth % axis) coll)]
      [(reduce min xs) (reduce max xs)]))

  (defn axis-range
    [axis coll]
    (- (apply - (axis-bounds axis coll))))
#+END_SRC

*** Polyline & curve sampling

#+BEGIN_SRC clojure :noweb-ref sample
  (defn point-at*
    [points idx total t i]
    (let [ct (* t total)
          i (int (loop [i i] (if (>= ct (idx i)) (recur (inc i)) i)))
          i1 (dec i)
          pi (idx i1)]
      [(g/mix (nth points i1) (nth points i)
              (mm/subdiv ct pi (idx i) pi))
       i]))

  (defn point-at
    ([t points] (point-at t points nil))
    ([t points idx]
       (when (m/in-range? 0.0 1.0 t)
         (let [n (count points)
               t (double t)]
           (cond
            (== 0 n) nil
            (== 1 n) (first points)
            (== 1.0 t) (last points)
            :default
            (let [idx (or idx (arc-length-index points))]
              (first (point-at* points idx (peek idx) t 1))))))))

  (defn sample-uniform*
    [udist include-last? points]
    (let [idx (arc-length-index points)
          total (peek idx)
          delta (/ udist total)
          samples (loop [t 0.0, i 1, acc []]
                    (if (< t 1.0)
                      (let [[p i] (point-at* points idx total t i)]
                        (recur (+ t delta) i (conj acc p)))
                      acc))]
      (if include-last?
        (conj samples (last points))
        samples)))

  (defn sample-uniform
    [udist include-last? points]
    (let [n (count points)]
      (cond
       (== 0 n) nil
       (== 1 n) [(first points)]
       :default (sample-uniform* udist include-last? points))))

  (defn sample-segment-with-res
    [a b res include-b?]
    (let [ls (for [t (m/norm-range res)] (g/mix a b t))]
      (if include-b? ls (butlast ls))))
#+END_SRC

*** Tessellation

#+BEGIN_SRC clojure :noweb-ref tessellate
  (defn tessellate-with-point
    ([points] (tessellate-with-point (centroid points) points))
    ([c points]
       (->> [(first points)]
            (concat points)
            (d/successive-nth 2)
            (map #(vector c (% 0) (% 1))))))

  (defn tessellate-with-first
    [points]
    (if (> (count points) 3)
      (let [[v0 & more] points]
        (map (fn [[a b]] [v0 a b]) (d/successive-nth 2 more)))
      [points]))

  (defn tessellate-3
    [points]
    (condp = (count points)
      3 [points]
      4 (let [[a b c d] points] [[a b c] [a c d]])
      (tessellate-with-point points)))

  (defn tessellate-max4
    [points]
    (if (<= (count points) 4)
      [points]
      (tessellate-with-point points)))
#+END_SRC

** Normals

#+BEGIN_SRC clojure :noweb-ref normals
  (defn ortho-normal
    ([[a b c]] (g/normalize (g/cross (g/- b a) (g/- c a))))
    ([a b] (g/normalize (g/cross a b)))
    ([a b c] (g/normalize (g/cross (g/- b a) (g/- c a)))))

  (defn norm-sign2
    [[ax ay] [bx by] [cx cy]]
    (- (mm/subm bx ax cy ay) (mm/subm cx ax by ay)))

  (defn norm-sign3
    [a b c] (g/mag (g/cross (g/- b a) (g/- c a))))
#+END_SRC


** Complete namespace definition                                   :noexport:
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/utils.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.core.utils
    (:require
     [thi.ng.geom.core :as g]
     [thi.ng.geom.core.vector :as v :refer [vec2 vec3]]
     [thi.ng.common.data.core :as d]
     [thi.ng.common.math.core :as m]
     ,#+clj [thi.ng.macromath.core :as mm])
    ,#+cljs
    (:require-macros
     [thi.ng.macromath.core :as mm])
    ,#+clj
    (:import
     [thi.ng.geom.core.vector Vec2 Vec3]))

  <<dist>>

  <<center>>

  <<bounds>>

  <<sample>>

  <<tessellate>>

  <<normals>>
#+END_SRC
