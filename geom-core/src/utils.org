#+SETUPFILE: ../../src/setup.org

* Namespace: thi.ng.geom.core.utils

** Point collection functions

*** Distance & length

#+BEGIN_SRC clojure :noweb-ref dist
  (defn closest-point-coeff
    [p a b]
    (let [d (g/- b a)]
      (/ (g/dot (g/- p a) d) (g/mag-squared d))))

  (defn closest-point-on-line
    [p a b]
    (g/mix a b (closest-point-coeff p a b)))

  (defn closest-point-on-segment
    [p a b]
    (let [t (closest-point-coeff p a b)]
      (cond
       (<= t 0.0) a
       (>= t 1.0) b
       :default (g/mix a b t))))

  (defn closest-point-on-segments
    [p segments]
    (let [[a & more] (map #(apply closest-point-on-segment p %) segments)]
      (loop [c a, d (g/dist-squared p a), more more]
        (if more
          (let [q (first more)
                d' (g/dist-squared p q)]
            (if (< d' d)
              (recur q d' (next more))
              (recur c d (next more))))
          c))))

  (defn closest-line-between
    [a1 b1 a2 b2]
    (let [p43 (g/- b2 a2)]
      (if-not (m/delta= [0 0 0] p43 *eps*)
        (let [p21 (g/- b1 a1)]
          (if-not (m/delta= [0 0 0] p21 *eps*)
            (let [p13 (g/- a1 a2)
                  d1343 (g/dot p13 p43)
                  d4321 (g/dot p43 p21)
                  d1321 (g/dot p13 p21)
                  d4343 (g/dot p43 p43)
                  d2121 (g/dot p21 p21)
                  d (mm/msub d2121 d4343 d4321 d4321)]
              (if (m/delta= 0.0 d *eps*)
                {:type :parallel}
                (let [n (mm/msub d1343 d4321 d1321 d4343)
                      ua (/ n d)
                      ub (/ (mm/madd d4321 ua d1343) d4343)]
                  {:type :intersect
                   :a (g/madd p21 ua a1) :b (g/madd p43 ub a2)
                   :ua ua :ub ub}))))))))

  (defn max-dist
    [c points]
    (->> points
         (map #(g/dist-squared c %))
         (reduce max)
         (Math/sqrt)))

  (defn arc-length-index
    [points]
    (->> points
         (d/successive-nth 2)
         (map #(g/dist (% 0) (% 1)))
         (reductions + 0)
         (vec)))

  (defn arc-length
    [points]
    (d/reduce-pairs + g/dist points))
#+END_SRC

*** Centroid & centering

#+BEGIN_SRC clojure :noweb-ref center
  (defn centroid
    [[x & xs :as coll]]
    (case (count coll)
      0 nil
      1 x
      2 (g/mix x (first xs))
      (g/addm x xs (/ 1.0 (count coll)))))

  (defn center
    ([c' coll]
       (center (centroid coll) c' coll))
    ([c c' coll]
       (let [d (- c' c)] (mapv #(g/+ % d) coll))))

  (defn scale-size
    ([s coll] (scale-size (centroid coll) s coll))
    ([c s coll] (mapv #(-> % (g/- c) (g/madd s c)) coll)))
#+END_SRC

*** Bounds

#+BEGIN_SRC clojure :noweb-ref bounds
  (defn bounds*
    [f zero [x & xs :as coll]]
    (let [c (count coll)]
      (cond
       (> c 1) (let [p (f min x xs)
                     q (f max x xs)]
                 [p (g/- q p)])
       (= c 1) [x zero]
       :default nil)))

  (defn bounding-rect
    [points]
    (bounds* v/vec2-op-seq V2 points))

  (defn bounding-box
    [points]
    (bounds* v/vec3-op-seq V3 points))

  (defn radial-bounds
    [ctor c r-or-points]
    [(ctor c)
     (if (coll? r-or-points)
       (max-dist c r-or-points)
       r-or-points)])

  (defn axis-bounds
    [axis coll]
    (let [xs (map #(nth % axis) coll)]
      [(reduce min xs) (reduce max xs)]))

  (defn axis-range
    [axis coll]
    (- (apply - (axis-bounds axis coll))))

  (defn delta-contains
    [points p eps]
    (some #(m/delta= p % eps) points))
#+END_SRC

*** Sampling

#+BEGIN_SRC clojure :noweb-ref sample
  (defn from-barycentric
    [points weights]
    (reduce g/+ (map g/* points weights)))

  (defn point-at*
    [points idx total t i]
    (let [ct (* t total)
          i (int (loop [i i] (if (>= ct (idx i)) (recur (inc i)) i)))
          i1 (dec i)
          pi (idx i1)]
      [(g/mix (nth points i1) (nth points i)
              (mm/subdiv ct pi (idx i) pi))
       i]))

  (defn point-at
    ([t points] (point-at t points nil))
    ([t points idx]
       (when (m/in-range? 0.0 1.0 t)
         (let [n (count points)
               t (double t)]
           (cond
            (== 0 n) nil
            (== 1 n) (first points)
            (== 1.0 t) (last points)
            :default
            (let [idx (or idx (arc-length-index points))]
              (first (point-at* points idx (peek idx) t 1))))))))

  (defn sample-uniform*
    [udist include-last? points]
    (let [idx (arc-length-index points)
          total (peek idx)
          delta (/ udist total)
          samples (loop [t 0.0, i 1, acc []]
                    (if (< t 1.0)
                      (let [[p i] (point-at* points idx total t i)]
                        (recur (+ t delta) (int i) (conj acc p)))
                      acc))]
      (if include-last?
        (conj samples (last points))
        samples)))

  (defn sample-uniform
    [udist include-last? points]
    (let [n (count points)]
      (cond
       (== 0 n) nil
       (== 1 n) [(first points)]
       :default (sample-uniform* udist include-last? points))))

  (defn sample-segment-with-res
    [a b res include-b?]
    (let [ls (for [t (m/norm-range res)] (g/mix a b t))]
      (if include-b? ls (butlast ls))))
#+END_SRC

*** Tessellation

#+BEGIN_SRC clojure :noweb-ref tessellate
  (defn tessellate-with-point
    ([points] (tessellate-with-point (centroid points) points))
    ([c points]
       (->> [(first points)]
            (concat points)
            (d/successive-nth 2)
            (map #(vector c (% 0) (% 1))))))

  (defn tessellate-with-first
    [points]
    (if (> (count points) 3)
      (let [[v0 & more] points]
        (map (fn [[a b]] [v0 a b]) (d/successive-nth 2 more)))
      [points]))

  (defn tessellate-3
    [points]
    (condp = (count points)
      3 [points]
      4 (let [[a b c d] points] [[a b c] [a c d]])
      (tessellate-with-point points)))

  (defn tessellate-max4
    [points]
    (if (<= (count points) 4)
      [points]
      (tessellate-with-point points)))
#+END_SRC

** Normals

#+BEGIN_SRC clojure :noweb-ref normals
  (defn ortho-normal
    ([[a b c]] (g/normalize (g/cross (g/- b a) (g/- c a))))
    ([a b] (g/normalize (g/cross a b)))
    ([a b c] (g/normalize (g/cross (g/- b a) (g/- c a)))))
#+END_SRC

** Triangles

#+BEGIN_SRC clojure :noweb-ref triangles
  (defn norm-sign2
    [[ax ay] [bx by] [cx cy]]
    (- (mm/subm bx ax cy ay) (mm/subm cx ax by ay)))

  (defn norm-sign3
    [a b c] (g/mag (g/cross (g/- b a) (g/- c a))))

  (defn tri-area2
    [a b c] (* 0.5 (norm-sign2 a b c)))

  (defn tri-area3
    [a b c] (* 0.5 (norm-sign3 a b c)))

  (defn clockwise2?
    [a b c] (neg? (norm-sign2 a b c)))

  (defn clockwise3?
    [a b c] (neg? (norm-sign3 a b c)))
#+END_SRC

** Intersections

#+BEGIN_SRC clojure :noweb-ref isec
  (defn intersect-circle-circle?
    ([{p :p r1 :r} {q :p r2 :r}]
       (intersect-circle-circle? p r1 q r2))
    ([p r1 q r2]
       (let [delta (g/- q p)
             d (g/mag delta)]
         (when (and (<= d (+ r1 r2)) (>= d (m/abs (- r1 r2))))
           (let [a (/ (+ (- (* r1 r1) (* r2 r2)) (* d d)) (* 2.0 d))
                 invd (/ 1.0 d)
                 p (g/madd delta (* a invd) p)
                 h (Math/sqrt (- (* r1 r1) (* a a)))
                 perp (g/* (g/normal delta) (* h invd))]
             [(g/+ p perp) (g/- p perp)])))))
#+END_SRC

#+BEGIN_SRC clojure :noweb-ref isec
  (defn intersect-rect-rect?
    ([{[px py] :p [w h] :size} {[qx qy] :p [qw qh] :size}]
       (not (or (> px (+ qx qw)) (> qx (+ px w)) (> py (+ qy qh)) (> qy (+ py h)))))
    ([[px1 py1] [qx1 qy1] [px2 py2] [qx2 qy2]]
       (not (or (> px1 qx2) (> px2 qx1) (> py1 qy2) (> py2 qy1)))))
#+END_SRC

#+BEGIN_SRC clojure :noweb-ref isec
  (defn intersect-aabb-aabb?
    ([{pa :p sa :size} {pb :p sb :size}]
       (every?
        #(and (<= (pa %) (+ (pb %) (sb %))) (<= (pb %) (+ (pa %) (sa %)))) [0 1 2]))
    ([pa pb qa qb]
       (every? #(and (<= (pa %) (qb %)) (<= (pb %) (qa %))) [0 1 2])))
#+END_SRC

Graphics Gems 2 / SO:
http://stackoverflow.com/questions/4578967

Also works for rect/circle...

#+BEGIN_SRC clojure :noweb-ref isec
  (defn intersect-aabb-sphere?
    ([{p :p sz :size} {s :p r :r}]
       (intersect-aabb-sphere? p (g/+ p sz) s r))
    ([p q c r]
       (let [sq #(* % %)
             ds (mapv
                 (fn [x1 x2 sx]
                   (if (< sx x1) (sq (- sx x1)) (if (> sx x2) (sq (- sx x2)) 0.0)))
                 p q c)]
         (<= (apply + ds) (* r r)))))
#+END_SRC

#+BEGIN_SRC clojure :noweb-ref isec
  (defn intersect-sphere-sphere?
    ([{p1 :p r1 :r} {p2 :p r2 :r}]
       (intersect-sphere-sphere? p1 r1 p2 r2))
    ([p1 r1 p2 r2]
       (<= (g/dist-squared p1 p2) (mm/addm r1 r1 r2 r2))))
#+END_SRC

** Complete namespace definition                                   :noexport:
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/utils.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.core.utils
    (:require
     [thi.ng.geom.core :as g]
     [thi.ng.geom.core.vector :as v :refer [vec2 vec3 V2 V3]]
     [thi.ng.common.data.core :as d]
     [thi.ng.common.math.core :as m :refer [*eps*]]
     ,#+clj [thi.ng.macromath.core :as mm])
    ,#+cljs
    (:require-macros
     [thi.ng.macromath.core :as mm])
    ,#+clj
    (:import
     [thi.ng.geom.core.vector Vec2 Vec3]))

  <<dist>>

  <<center>>

  <<bounds>>

  <<sample>>

  <<tessellate>>

  <<normals>>

  <<triangles>>

  <<isec>>
#+END_SRC
