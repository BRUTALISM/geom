#+SETUPFILE: ../../src/setup.org

* Namespace: thi.ng.geom.core.intersect

** Intersections

#+BEGIN_SRC clojure :noweb-ref isec
  (defn intersect-circle-circle?
    ([{p :p r1 :r} {q :p r2 :r}]
       (intersect-circle-circle? p r1 q r2))
    ([p r1 q r2]
       (let [delta (g/- q p)
             d (g/mag delta)]
         (when (and (<= d (+ r1 r2)) (>= d (m/abs (- r1 r2))))
           (let [a (/ (+ (- (* r1 r1) (* r2 r2)) (* d d)) (* 2.0 d))
                 invd (/ 1.0 d)
                 p (g/madd delta (* a invd) p)
                 h (Math/sqrt (- (* r1 r1) (* a a)))
                 perp (g/* (g/normal delta) (* h invd))]
             [(g/+ p perp) (g/- p perp)])))))
#+END_SRC

#+BEGIN_SRC clojure :noweb-ref isec
  (defn intersect-rect-rect?
    ([{[px py] :p [w h] :size} {[qx qy] :p [qw qh] :size}]
       (not (or (> px (+ qx qw)) (> qx (+ px w)) (> py (+ qy qh)) (> qy (+ py h)))))
    ([[px1 py1] [qx1 qy1] [px2 py2] [qx2 qy2]]
       (not (or (> px1 qx2) (> px2 qx1) (> py1 qy2) (> py2 qy1)))))
#+END_SRC

#+BEGIN_SRC clojure :noweb-ref isec
  (defn intersect-aabb-aabb?
    ([{pa :p sa :size} {pb :p sb :size}]
       (every?
        #(and (<= (pa %) (+ (pb %) (sb %))) (<= (pb %) (+ (pa %) (sa %)))) [0 1 2]))
    ([pa pb qa qb]
       (every? #(and (<= (pa %) (qb %)) (<= (pb %) (qa %))) [0 1 2])))
#+END_SRC

Source:
Graphics Gems 2 / SO:
http://stackoverflow.com/questions/4578967

Also works for rect/circle...

#+BEGIN_SRC clojure :noweb-ref isec
  (defn intersect-aabb-sphere?
    ([{p :p sz :size} {s :p r :r}]
       (intersect-aabb-sphere? p (g/+ p sz) s r))
    ([p q c r]
       (let [sq #(* % %)
             ds (mapv
                 (fn [x1 x2 sx]
                   (if (< sx x1) (sq (- sx x1)) (if (> sx x2) (sq (- sx x2)) 0.0)))
                 p q c)]
         (<= (apply + ds) (* r r)))))
#+END_SRC

#+BEGIN_SRC clojure :noweb-ref isec
  (defn intersect-sphere-sphere?
    ([{p1 :p r1 :r} {p2 :p r2 :r}]
       (intersect-sphere-sphere? p1 r1 p2 r2))
    ([p1 r1 p2 r2]
       (<= (g/dist-squared p1 p2) (mm/addm r1 r2 r1 r2))))
#+END_SRC

#+BEGIN_SRC clojure :noweb-ref isec
  (defn intersect-ray-sphere?
    ([{rp :p dir :dir} {p :p r :r}]
       (intersect-ray-sphere? rp dir p r))
    ([rp dir p r]
     (let [q (g/- p rp)
           ds (g/mag-squared q)
           v (- (g/dot q dir))
           d (mm/msub r r (- ds (* v v)))]
       (if (>= d 0.0)
         (let [d (Math/sqrt d)
               a (+ v d)
               b (- v d)]
           (if-not (and (< a 0) (< b 0))
             (if (and (> a 0) (> b 0))
               (if (> a b) [b a] [a b])
               (if (> b 0) [b a] [a b]))
             [a b]))))))
#+END_SRC
Source: http://geomalgorithms.com/a06-_intersect-2.html

#+BEGIN_SRC clojure :noweb-ref isec 
  (defn intersect-ray-triangle3?
    [p d a b c]
    (let [u (g/- b a)
          v (g/- c a)
          n (g/cross u v)]
      (if (m/delta= V3 n)
        {:type :degenerate}
        (let [w0 (g/- p a)
              a' (- (g/dot n w0))
              b' (g/dot n d)]
          (if (m/delta= 0.0 b')
            (if (m/delta= 0.0 a')
              {:type :same-plane}
              {:type :no-intersect})
            (let [r (/ a' b')]
              (if (< r 0.0)
                {:type :no-intersect}
                (let [i (g/madd d r p)
                      [u v w] (gu/triangle-barycentric-coords a b c i u v)]
                  (if (and (>= u 0.0) (>= w 0.0) (m/in-range? 0.0 1.0 v))
                    {:type :intersect :p i}
                    {:type :no-intersect :p i})))))))))
#+END_SRC

#+BEGIN_SRC clojure :noweb-ref isec
  (defn intersect-line2-line2?
    [[px1 py1 :as p] [qx1 qy1 :as q]
     [px2 py2 :as lp] [qx2 qy2 :as lq]]
    (let [dx1 (- qx1 px1), dy1 (- qy1 py1)
          dx2 (- qx2 px2), dy2 (- qy2 py2)
          dx12 (- px1 px2), dy12 (- py1 py2)
          denom (mm/msub dy2 dx1 dx2 dy1)
          na (mm/msub dx2 dy12 dy2 dx12)
          nb (mm/msub dx1 dy12 dy1 dx12)]
      (if (zero? denom)
        (if (and (zero? na) (zero? nb))
          (let [ip (gu/closest-point-on-segment lp p q)
                iq (gu/closest-point-on-segment lq p q)]
            (if (or (m/delta= ip lp) (m/delta= iq lq))
              {:type :coincident :p ip :q iq}
              {:type :coincident-no-intersect :p ip :q iq}))
          {:type :parallel})
        (let [ua (/ na denom)
              ub (/ nb denom)
              i (g/mix p q ua)]
          (if (and (>= ua 0.0) (<= ua 1.0) (>= ub 0.0) (<= ub 1.0))
            {:type :intersect :p i :ua ua :ub ub}
            {:type :intersect-outside :p i :ua ua :ub ub})))))
#+END_SRC

#+BEGIN_SRC clojure :noweb-ref isec
  (defn intersect-plane-plane?
    [an aw bn bw]
    (when-not (or (m/delta= aw bw *eps*) (m/delta= an bn *eps*))
      (let [od (g/dot an bn)
            det (/ (mm/madd od od -1))
            u (* (mm/madd bw od (- aw)) det)
            v (* (mm/madd aw od (- bw)) det)]
        {:p (g/madd an u (g/* bn v)) :dir (gu/ortho-normal an bn)})))
#+END_SRC

#+BEGIN_SRC clojure :noweb-ref isec
  (defn intersect-ray-plane?
    [rp dir n w]
    (let [dp (g/dot n dir)
          dn (- (g/dot n rp) w)]
      (if (m/delta= 0.0 dp *eps*)
        {:type (if (zero? dn) :on-plane :parallel)}
        (let [du (- (/ dn dp))
              i (g/madd dir du rp)]
          (if (m/in-range? 0.0 1.0 du)
            {:type :intersect :p i}
            {:type :intersect-outside :p i})))))
#+END_SRC
** Complete namespace definition                                   :noexport:
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/intersect.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.core.intersect
    (:require
     [thi.ng.geom.core :as g]
     [thi.ng.geom.core.utils :as gu]
     [thi.ng.geom.core.vector :as v :refer [vec2 vec3 V2 V3]]
     [thi.ng.common.math.core :as m :refer [*eps*]]
     ,#+clj [thi.ng.macromath.core :as mm])
    ,#+cljs
    (:require-macros
     [thi.ng.macromath.core :as mm]))

  <<isec>>
#+END_SRC
