#+SETUPFILE: ../../src/setup.org

* Namespace: thi.ng.geom.core.vector

For reasons of performance & functionality we decided to define custom
data types for vectors & matrices. Since they implement the necessary
protocols and interfaces, these types can be used much like standard
Clojure vectors/seqs, but also provide implementations for the above
geometry protocols and custom key lookups to enable swizzling.

** Templates

In order to deduplicate shared code between both the 2d/3d vector
versions and theor Clojure & ClojureScript protocol implementations,
we first define a few snippets as re-usable templates, which are
injected in the appropriate places of the code.

*** apply
#+NAME: tpl-apply
#+BEGIN_SRC emacs-lisp :var fn=""
  (replace-regexp-in-string "{{fn}}" fn
  "(condp = (count args)
    1 ({{fn}} _ (first args) nil)
    2 ({{fn}} _ (first args) (second args))
    (err/arity-error! (count args)))")
#+END_SRC
*** assocN
#+BEGIN_SRC clojure :noweb-ref tpl-assoc-n2
  (case (int k)
    0 (Vec2. v y -1 #+clj -1)
    1 (Vec2. x v -1 #+clj -1)
    (err/key-error! k))
#+END_SRC
#+BEGIN_SRC clojure :noweb-ref tpl-assoc-n3
  (case (int k)
    0 (Vec3. v y z -1 #+clj -1)
    1 (Vec3. x v z -1 #+clj -1)
    2 (Vec3. x y v -1 #+clj -1)
    (err/key-error! k))
#+END_SRC
*** containsKey
#+BEGIN_SRC clojure :noweb-ref tpl-contains-key2
  (not (nil? (#{0 1 :x :y} k)))
#+END_SRC
#+BEGIN_SRC clojure :noweb-ref tpl-contains-key3
  (not (nil? (#{0 1 2 :x :y :z} k)))
#+END_SRC
*** nth w/ error
#+BEGIN_SRC clojure :noweb-ref tpl-nth-err2
  (case (int k) 0 x, 1 y, (err/key-error! k))
#+END_SRC
#+BEGIN_SRC clojure :noweb-ref tpl-nth-err3
  (case (int k) 0 x, 1 y, 2 z, (err/key-error! k))
#+END_SRC
*** nth w/ notfound
#+BEGIN_SRC clojure :noweb-ref tpl-nth-nf2
  (case (int k) 0 x, 1 y, nf)
#+END_SRC
#+BEGIN_SRC clojure :noweb-ref tpl-nth-nf3
  (case (int k) 0 x, 1 y, 2 z, nf)
#+END_SRC
*** compare
#+BEGIN_SRC clojure :noweb-ref tpl-compare2
  (if (instance? Vec2 o)
    (let [c (compare x (.-x ^Vec2 o))]
      (if (== 0 c)
        (compare y (.-y ^Vec2 o))
        c))
    (let [c (count o)]
      (if (== 2 c) (compare o _) (- 2 c))))
#+END_SRC
#+BEGIN_SRC clojure :noweb-ref tpl-compare3
  (if (instance? Vec3 o)
    (let [c (compare x (.-x ^Vec3 o))]
      (if (== 0 c)
        (let [c (compare y (.-y ^Vec3 o))]
          (if (== 0 c)
            (compare z (.-z ^Vec3 o))
            c))
        c))
    (let [c (count o)]
      (if (== 3 c) (compare o _) (- 3 c))))
#+END_SRC
*** hashCode
#+BEGIN_SRC clojure :noweb-ref tpl-hashcode2
  (if (== -1 _hashc)
    (set! _hashc
          (-> 31
              (unchecked-add-int (hash x))
              (unchecked-multiply-int 31)
              (unchecked-add-int (hash y))))
    _hashc)
#+END_SRC
#+BEGIN_SRC clojure :noweb-ref tpl-hashcode3
  (if (== -1 _hashc)
    (set! _hashc
          (-> 31
              (unchecked-add-int (hash x))
              (unchecked-multiply-int 31)
              (unchecked-add-int (hash y))
              (unchecked-multiply-int 31)
              (unchecked-add-int (hash z))))
    _hashc)
#+END_SRC
*** hashEq
#+BEGIN_SRC clojure :noweb-ref tpl-hasheq2 :noweb yes
  (if (== -1 _hasheq)
    (set! _hasheq
          (mix-collection-hash
           <<tpl-hashcode2>>
           2))
    _hasheq)
#+END_SRC
#+BEGIN_SRC clojure :noweb-ref tpl-hasheq3 :noweb yes
  (if (== -1 _hasheq)
    (set! _hasheq
          (mix-collection-hash
           <<tpl-hashcode3>>
           3))
    _hasheq)
#+END_SRC
*** rest
#+BEGIN_SRC clojure :noweb-ref tpl-rest2
  (cons y nil)
#+END_SRC
#+BEGIN_SRC clojure :noweb-ref tpl-rest3
  (cons y (cons z nil))
#+END_SRC
*** rseq
#+BEGIN_SRC clojure :noweb-ref tpl-rseq2
  (Vec2. y x -1 #+clj -1)
#+END_SRC
#+BEGIN_SRC clojure :noweb-ref tpl-rseq3
  (Vec3. z y x -1 #+clj -1)
#+END_SRC

*** reduce
#+BEGIN_SRC clojure :noweb-ref tpl-reduce2
  (let [acc (f x y)] (if (reduced? acc) @acc acc))
#+END_SRC
#+BEGIN_SRC clojure :noweb-ref tpl-reduce3
  (let [acc (f x y)]
    (if (reduced? acc)
      @acc
      (let [acc (f acc z)]
        (if (reduced? acc)
          @acc
          acc))))
#+END_SRC
*** reduce w/ init
#+BEGIN_SRC clojure :noweb-ref tpl-reduce2-start
  (let [acc (f start x)]
    (if (reduced? acc)
      @acc
      (let [acc (f acc y)]
        (if (reduced? acc)
          @acc
          acc))))
#+END_SRC
#+BEGIN_SRC clojure :noweb-ref tpl-reduce3-start
  (let [acc (f start x)]
    (if (reduced? acc)
      @acc
      (let [acc (f acc y)]
        (if (reduced? acc)
          @acc
          (let [acc (f acc z)]
            (if (reduced? acc)
              @acc
              acc))))))
#+END_SRC

** 2D
#+BEGIN_SRC clojure :noweb-ref vec2
  (deftype Vec2
    ,#+clj [^double x ^double y
            ^:unsynchronized-mutable _hasheq
            ^:unsynchronized-mutable _hashc]
    ,#+cljs [x y ^:mutable _hasheq]
#+END_SRC
*** Clojure protocols
#+BEGIN_SRC clojure :noweb-ref vec2
  ,#+clj clojure.lang.ILookup
  ,#+clj (valAt
         [_ k] (swizzle2 _ k nil))
  ,#+clj (valAt
         [_ k nf] (swizzle2 _ k nf))

  ,#+clj java.util.concurrent.Callable
  ,#+clj (call
         [_] (.invoke ^clojure.lang.IFn _))
  ,#+clj java.lang.Runnable
  ,#+clj (run
          [_] (.invoke ^clojure.lang.IFn _))

  ,#+clj clojure.lang.IFn
  ,#+clj (invoke
         [_ k] (swizzle2 _ k nil))
  ,#+clj (invoke
         [_ k nf] (swizzle2 _ k nf))
  ,#+clj (applyTo
         [_ args]
         <<tpl-apply(fn="swizzle2")>>)

  ,#+clj clojure.lang.IMapEntry
  ,#+clj java.util.Map$Entry
  ,#+clj (key
         [_] x)
  ,#+clj (getKey
         [_] x)
  ,#+clj (val
         [_] y)
  ,#+clj (getValue
         [_] y)

  ,#+clj clojure.lang.Associative
  ,#+clj clojure.lang.IPersistentVector
  ,#+clj (count
         [_] 2)
  ,#+clj (length
         [_] 2)
  ,#+clj (containsKey
         [_ k] <<tpl-contains-key2>>)
  ,#+clj (entryAt
         [_ k] (clojure.lang.MapEntry. k <<tpl-nth-err2>>))
  ,#+clj (assoc
            [_ k v] (swizzle2-assoc _ k v))
  ,#+clj (assocN
         [_ k v]
         <<tpl-assoc-n2>>)

  ,#+clj java.util.Collection
  ,#+clj (isEmpty
         [_] false)
  ,#+clj (iterator
         [_] (.iterator ^java.util.Collection (list x y)))
  ,#+clj (toArray
         [_] (object-array _))
  ,#+clj (size [_] 2)

  ,#+clj clojure.lang.IEditableCollection
  ,#+clj (asTransient
         [_] (-> (transient clojure.lang.PersistentVector/EMPTY)
                 (conj! x) (conj! y)))

  ,#+clj clojure.lang.IPersistentCollection
  ,#+clj clojure.lang.Indexed
  ,#+clj clojure.lang.Sequential
  ,#+clj clojure.lang.ISeq
  ,#+clj clojure.lang.Seqable
  ,#+clj clojure.lang.Reversible
  ,#+clj (first
         [_] x)
  ,#+clj (next
         [_] (cons y nil))
  ,#+clj (more
         [_] (cons y nil))
  ,#+clj (cons
         [_ z] (vec3 x y z))
  ,#+clj (peek
         [_] y)
  ,#+clj (pop
         [_] [x])
  ,#+clj (rseq
         [_] (Vec2. y x -1 #+clj -1))
  ,#+clj (seq
         [_] _)
  ,#+clj (nth
         [_ k] <<tpl-nth-err2>>)
  ,#+clj (nth
         [_ k nf] <<tpl-nth-nf2>>)
  ,#+clj (equiv
         [_ o]
         (if (instance? Vec2 o)
           (and (clojure.lang.Numbers/equiv x (.-x ^Vec2 o))
                (clojure.lang.Numbers/equiv y (.-y ^Vec2 o)))
           (and (instance? java.util.Collection o)
                (= 2 (count o))
                (clojure.lang.Util/equiv x (first o))
                (clojure.lang.Util/equiv y (nth o 1)))))
  ,#+clj (equals
         [_ o]
         (if (instance? Vec2 o)
           (and (clojure.lang.Util/equals x (.-x ^Vec2 o))
                (clojure.lang.Util/equals y (.-y ^Vec2 o)))
           (and (instance? java.util.Collection o)
                (= 2 (count o))
                (clojure.lang.Util/equals x (first o))
                (clojure.lang.Util/equals y (nth o 1)))))

  ;; http://docs.oracle.com/javase/7/docs/g/java/util/List.html#hashCode()
  ,#+clj (hashCode
         [_]
         <<tpl-hashcode2>>)

  ;; http://clojure.org/data_structures#hash
  ,#+clj clojure.lang.IHashEq
  ,#+clj (hasheq
         [_]
         <<tpl-hasheq2>>)

  ,#+clj Comparable
  ,#+clj (compareTo
         [_ o]
         <<tpl-compare2>>)

  ,#+clj cp/InternalReduce
  ,#+clj (internal-reduce
         [_ f start]
         <<tpl-reduce2-start>>)

  ,#+clj cp/CollReduce
  ,#+clj (coll-reduce
         [_ f]
         <<tpl-reduce2>>)
  ,#+clj (coll-reduce
         [_ f start]
         <<tpl-reduce2-start>>)

  ,#+clj Object
  ,#+clj (toString
         [_]
         (.toString
          ^StringBuilder
          (doto (StringBuilder. "[")
            (.append x)
            (.append " ")
            (.append y)
            (.append "]"))))
#+END_SRC
*** ClojureScript protocols
#+BEGIN_SRC clojure :noweb-ref vec2
  ,#+cljs ICloneable
  ,#+cljs (-clone
          [_] (Vec2. x y -1 #+clj -1))
  
  ,#+cljs ILookup
  ,#+cljs (-lookup
          [_ k] (swizzle2 _ k nil))
  ,#+cljs (-lookup
          [_ k nf] (swizzle2 _ k nf))
  
  ,#+cljs IFn
  ,#+cljs (-invoke
          [_ k] (swizzle2 _ k nil))
  ,#+cljs (-invoke
          [_ k nf] (swizzle2 _ k nf))
  
  ,#+cljs ICounted
  ,#+cljs (-count
          [_] 2)
  
  ,#+cljs IAssociative
  ,#+cljs (-contains-key?
          [_ k] <<tpl-contains-key2>>)
  ,#+cljs (-assoc
          [_ k v] (swizzle2-assoc _ k v))
  
  ,#+cljs IVector
  ,#+cljs (-assoc-n
          [_ k v]
          <<tpl-assoc-n2>>)
  
  ,#+cljs ISequential
  ,#+cljs ISeq
  ,#+cljs (-first
          [_] x)
  ,#+cljs (-rest
          [_] <<tpl-rest2>>)
  
  ,#+cljs INext
  ,#+cljs (-next
          [_] <<tpl-rest2>>)
  
  ,#+cljs ISeqable
  ,#+cljs (-seq
          [_] _)
  
  ,#+cljs IReversible
  ,#+cljs (-rseq
          [_] <<tpl-rseq2>>)
  
  ,#+cljs IIndexed
  ,#+cljs (-nth
          [_ k] <<tpl-nth-err2>>)
  ,#+cljs (-nth
          [_ k nf] <<tpl-nth-nf2>>)
  
  ,#+cljs ICollection
  ,#+cljs (-conj
          [_ z] (vec3 x y z))
  
  ,#+cljs IStack
  ,#+cljs (-peek
          [_] y)
  ,#+cljs (-pop
          [_] [x])
  
  ,#+cljs IComparable
  ,#+cljs (-compare
          [_ o]
          <<tpl-compare2>>)
  
  ,#+cljs IHash
  ,#+cljs (-hash
          [_]
          (if (== -1 _hasheq)
            (set! _hasheq
                  (mix-collection-hash
                   (-> 31 (+ (hash x))
                       (bit-or 0)
                       (imul 31) (+ (hash y))
                       (bit-or 0))
                   2))
            _hasheq))
  
  ,#+cljs IEquiv
  ,#+cljs (-equiv
          [_ o]
          (if (instance? Vec2 o)
            (and (== x (.-x ^Vec2 o)) (== y (.-y ^Vec2 o)))
            (and (sequential? o) (= 2 (count o))
                 (= x (first o)) (= y (nth o 1)))))
  
  ,#+cljs IReduce
  ,#+cljs (-reduce
          [coll f]
          <<tpl-reduce2>>)
  ,#+cljs (-reduce
          [coll f start]
          <<tpl-reduce2-start>>)
  
  ,#+cljs Object
  ,#+cljs (toString
          [_] (str "[" x " " y "]"))
#+END_SRC
*** Transformations
#+BEGIN_SRC clojure :noweb-ref vec2
  g/PScale
  (scale
   [_ a] (vec2-op-1 * _ a 1.0))
  (scale
   [_ a b] (vec2-op-2 * _ a b 1.0 1.0))
  (scale
   [_ a b c] (vec2-op-3 * _ a b c 1.0))
  
  g/PTranslate
  (translate
   [_ a] (vec2-op-1 + _ a 0.0))
  (translate
   [_ a b] (vec2-op-2 + _ a b 0.0 0.0))
  (translate
   [_ a b c] (vec2-op-3 + _ a b c 0.0))
  
  g/PRotate
  (rotate
   [_ theta]
   (let [s (Math/sin theta) c (Math/cos theta)]
     (Vec2. (mm/msub x c y s) (mm/madd x s y c) -1 #+clj -1)))
  g/PRotate3D
  (rotate-x
   [_ theta] (g/rotate-x (vec3 _) theta))
  (rotate-y
   [_ theta] (g/rotate-y (vec3 _) theta))
  (rotate-z
   [_ theta] (vec3 (g/rotate _ theta)))
  (rotate-around-axis
   [_ axis theta] (g/rotate-around-axis (vec3 _) axis theta))
  
  g/PTransform
  (transform
   [_ m] (g/transform-vector m _))
#+END_SRC
*** PMathOps
#+BEGIN_SRC clojure :noweb-ref vec2
  g/PMathOps
  (abs [_] (Vec2. (m/abs x) (m/abs y) -1 #+clj -1))
  (+ [_] _)
  (+ [_ a] (vec2-op-1 + _ a 0.0))
  (+ [_ a b] (vec2-op-2 + _ a b 0.0 0.0))
  (+ [_ a b c] (vec2-op-3 + _ a b c 0.0))
  
  (- [_] (Vec2. (- x) (- y) -1 #+clj -1))
  (- [_ a] (vec2-op-1 - _ a 0.0))
  (- [_ a b] (vec2-op-2 - _ a b 0.0 0.0))
  (- [_ a b c] (vec2-op-3 - _ a b c 0.0))
  
  (* [_] _)
  (* [_ a] (vec2-op-1 * _ a 1.0))
  (* [_ a b] (vec2-op-2 * _ a b 1.0 1.0))
  (* [_ a b c] (vec2-op-3 * _ a b c 1.0))
  
  (div [_] (Vec2. (/ x) (/ y) -1 #+clj -1))
  (div [_ a] (vec2-op-1 / _ a 0.0))
  (div [_ a b] (vec2-op-2 / _ a b 0.0 0.0))
  (div [_ a b c] (vec2-op-3 / _ a b c 0.0))
  
  (madd [_ a b] (vec2-op-2* * + _ a b 1.0 0.0))
  (addm [_ a b] (vec2-op-2* + * _ a b 0.0 1.0))
  (msub [_ a b] (vec2-op-2* * - _ a b 1.0 0.0))
  (subm [_ a b] (vec2-op-2* - * _ a b 0.0 1.0))
#+END_SRC
*** PDeltaEquals
#+BEGIN_SRC clojure :noweb-ref vec2
  m/PDeltaEquals
  (delta=
   [_ v] (m/delta= _ v *eps*))
  (delta=
   [_ v eps]
   (and (sequential? v)
        (== 2 (count v))
        (m/delta= x (first v) eps)
        (m/delta= y (nth v 1) eps)))
#+END_SRC
*** PDotProduct
#+BEGIN_SRC clojure :noweb-ref vec2
  g/PDotProduct
  (dot
   [_ [ax ay]] (mm/madd x ax y ay))
#+END_SRC
*** PCrossProduct
#+BEGIN_SRC clojure :noweb-ref vec2
  g/PCrossProduct
  (cross
   [_ [ax ay]] (mm/msub x ay y ax))
#+END_SRC
*** PLimit
#+BEGIN_SRC clojure :noweb-ref vec2
  g/PLimit
  (limit
   [_ len]
   (if (> (g/mag-squared _) (* len len))
     (g/normalize _ len)
     _))
#+END_SRC
*** PMinMax
#+BEGIN_SRC clojure :noweb-ref vec2
  g/PMinMax
  (min
   [_ [ax ay]]
   (Vec2. (min x ax) (min y ay) -1 #+clj -1))
  (min
   [_ [ax ay] [bx by]]
   (Vec2. (min (min x ax) bx) (min (min y ay) by) -1 #+clj -1))
  (max
   [_ [ax ay]]
   (Vec2. (max x ax) (max y ay) -1 #+clj -1))
  (max
   [_ [ax ay] [bx by]]
   (Vec2. (max (max x ax) bx) (max (max y ay) by) -1 #+clj -1))
#+END_SRC
*** PMagnitude
#+BEGIN_SRC clojure :noweb-ref vec2
  g/PMagnitude
  (mag
   [_]
   (Math/sqrt (mm/madd x x y y)))
  (mag-squared
   [_] (mm/madd x x y y))
#+END_SRC
*** PNormalize
#+BEGIN_SRC clojure :noweb-ref vec2
  g/PNormalize
  (normalize
   [_]
   (let [l (Math/sqrt (mm/madd x x y y))]
     (if (pos? l)
       (Vec2. (/ x l) (/ y l) -1 #+clj -1)
       _)))
  (normalize
   [_ len]
   (let [l (Math/sqrt (mm/madd x x y y))]
     (if (pos? l)
       (let [l (/ len l)] (Vec2. (* x l) (* y l) -1 #+clj -1))
       _)))
  (normalized?
   [_] (m/delta= 1.0 (g/mag-squared _)))
#+END_SRC
*** PNormal
#+BEGIN_SRC clojure :noweb-ref vec2
  g/PNormal
  (normal [_] (Vec2. (- y) x -1 #+clj -1))
#+END_SRC
*** PDistance
#+BEGIN_SRC clojure :noweb-ref vec2
  g/PDistance
  (dist
   [_ a]
   (let [[dx dy] (if (instance? Vec2 a)
                   [(- x (.-x ^Vec2 a)) (- y (.-y ^Vec2 a))]
                   [(- x (first a)) (- y (nth a 1))])]
     (Math/sqrt (mm/madd dx dx dy dy))))
  (dist-squared
   [_ a]
   (let [[dx dy] (if (instance? Vec2 a)
                   [(- x (.-x ^Vec2 a)) (- y (.-y ^Vec2 a))]
                   [(- x (first a)) (- y (nth a 1))])]
     (mm/madd dx dx dy dy)))
#+END_SRC
*** PReflect
#+BEGIN_SRC clojure :noweb-ref vec2
  g/PReflect
  (reflect
   [_ [rx ry :as r]]
    (let [d (* (g/dot _ r) 2.0)]
      (Vec2. (mm/msub rx d x) (mm/msub ry d y) -1 #+clj -1)))
#+END_SRC
*** PInvert
#+BEGIN_SRC clojure :noweb-ref vec2
  g/PInvert
  (invert
   [_] (Vec2. (- x) (- y) -1 #+clj -1))
#+END_SRC
*** PInterpolate
#+BEGIN_SRC clojure :noweb-ref vec2
  g/PInterpolate
  (mix
   [_ a]
   (Vec2.
    (mm/mix x (first a) 0.5)
    (mm/mix y (nth a 1) 0.5)
    -1 #+clj -1))
  (mix
   [_ a t]
   (Vec2.
    (mm/mix x (first a) t)
    (mm/mix y (nth a 1) t)
    -1 #+clj -1))
  (mix
   [_ a b c u v]
   (Vec2.
    (mm/mix x (first a) (first b) (first c) u v)
    (mm/mix y (nth a 1) (nth b 1) (nth c 1) u v)
    -1 #+clj -1))
#+END_SRC
*** PHeading
#+BEGIN_SRC clojure :noweb-ref vec2
  g/PHeading
  (heading
   [_]
   (let [t (Math/atan2 y x)]
     (if (neg? t) (+ t TWO_PI) t)))
  (heading-xy
    [_] (g/heading _))
  (angle-between
   [_ a]
   (let [t (- (g/heading-xy a) (g/heading-xy _))]
     (if (neg? t) (+ t TWO_PI) t)))
  (slope-xy [_] (/ y x))
#+END_SRC
*** PPolar
#+BEGIN_SRC clojure :noweb-ref vec2
  g/PPolar
  (as-polar
   [_] (Vec2. (g/mag _) (g/heading-xy _) -1 #+clj -1))
  (as-cartesian
   [_] (Vec2. (* x (Math/cos y)) (* x (Math/sin y)) -1 #+clj -1))
#+END_SRC
*** End of implementations
#+BEGIN_SRC clojure :noweb-ref vec2
  )
#+END_SRC
*** Override print methods
#+BEGIN_SRC clojure :noweb-ref vec2
  ,#+clj (defmethod clojure.pprint/simple-dispatch Vec2
          [^Vec2 o] ((get-method clojure.pprint/simple-dispatch clojure.lang.IPersistentVector) o))
  ,#+clj (defmethod print-method Vec2
          [^Vec2 o ^java.io.Writer w] (.write w (.toString o)))
#+END_SRC
** 3D
#+BEGIN_SRC clojure :noweb-ref vec3
  (deftype Vec3
    #+clj [^double x ^double y ^double z
           ^:unsynchronized-mutable _hasheq
           ^:unsynchronized-mutable _hashc]
    #+cljs [x y z ^:mutable _hasheq]
#+END_SRC
*** Clojure protocols
#+BEGIN_SRC clojure :noweb-ref vec3
  ,#+clj clojure.lang.ILookup
  ,#+clj (valAt
         [_ k] (swizzle3 _ k nil))
  ,#+clj (valAt
         [_ k nf] (swizzle3 _ k nf))

  ,#+clj java.util.concurrent.Callable
  ,#+clj (call
         [_] (.invoke ^clojure.lang.IFn _))
  ,#+clj java.lang.Runnable
  ,#+clj (run
          [_] (.invoke ^clojure.lang.IFn _))

  ,#+clj clojure.lang.IFn
  ,#+clj (invoke
         [_ k] (swizzle3 _ k nil))
  ,#+clj (invoke
         [_ k nf] (swizzle3 _ k nf))
  ,#+clj (applyTo
         [_ args]
         <<tpl-apply(fn="swizzle3")>>)

  ,#+clj clojure.lang.Associative
  ,#+clj clojure.lang.IPersistentVector
  ,#+clj (count
         [_] 3)
  ,#+clj (length
         [_] 3)
  ,#+clj (containsKey
         [_ k] <<tpl-contains-key3>>)
  ,#+clj (entryAt
         [_ k] (clojure.lang.MapEntry. k <<tpl-nth-err3>>))
  ,#+clj (assoc
            [_ k v] (swizzle3-assoc _ k v))
  ,#+clj (assocN
         [_ k v]
         <<tpl-assoc-n3>>)

  ,#+clj java.util.Collection
  ,#+clj (isEmpty
         [_] false)
  ,#+clj (iterator
         [_] (.iterator ^java.util.Collection (list x y z)))
  ,#+clj (toArray
         [_] (object-array _))
  ,#+clj (size
         [_] 3)

  ,#+clj clojure.lang.IEditableCollection
  ,#+clj (asTransient
         [_] (-> (transient clojure.lang.PersistentVector/EMPTY)
                 (conj! x) (conj! y) (conj! z)))

  ,#+clj clojure.lang.IPersistentCollection
  ,#+clj clojure.lang.Indexed
  ,#+clj clojure.lang.Sequential
  ,#+clj clojure.lang.ISeq
  ,#+clj clojure.lang.Seqable
  ,#+clj clojure.lang.Reversible
  ,#+clj (first
         [_] x)
  ,#+clj (next
         [_] <<tpl-rest3>>)
  ,#+clj (more
         [_] <<tpl-rest3>>)
  ,#+clj (cons
         [_ w] (VectorSeq. 0 4 [x y z w] nil))
  ,#+clj (peek
         [_] z)
  ,#+clj (pop
         [_] (Vec2. x y -1 #+clj -1))
  ,#+clj (rseq
         [_] <<tpl-rseq3>>)
  ,#+clj (seq
         [_] _)
  ,#+clj (nth
         [_ k] <<tpl-nth-err3>>)
  ,#+clj (nth
         [_ k nf] <<tpl-nth-nf3>>)
  ,#+clj (equiv
         [_ o]
         (if (instance? Vec3 o)
           (and (clojure.lang.Numbers/equiv x (.-x ^Vec3 o))
                (clojure.lang.Numbers/equiv y (.-y ^Vec3 o))
                (clojure.lang.Numbers/equiv z (.-z ^Vec3 o)))
           (and (instance? java.util.Collection o)
                (= 3 (count o))
                (clojure.lang.Util/equiv x (first o))
                (clojure.lang.Util/equiv y (nth o 1))
                (clojure.lang.Util/equiv z (nth o 2)))))
  ,#+clj (equals
         [_ o]
         (if (instance? Vec3 o)
           (and (clojure.lang.Util/equals x (.-x ^Vec3 o))
                (clojure.lang.Util/equals y (.-y ^Vec3 o))
                (clojure.lang.Util/equals z (.-z ^Vec3 o)))
           (and (instance? java.util.Collection o)
                (= 3 (count o))
                (clojure.lang.Util/equals x (first o))
                (clojure.lang.Util/equals y (nth o 1))
                (clojure.lang.Util/equals z (nth o 2)))))
  ,#+clj (hashCode
         [_]
         <<tpl-hashcode3>>)

  ,#+clj clojure.lang.IHashEq
  ,#+clj (hasheq
         [_]
         <<tpl-hasheq3>>)

  ,#+clj Comparable
  ,#+clj (compareTo
         [_ o]
         <<tpl-compare3>>)

  ,#+clj cp/InternalReduce
  ,#+clj (internal-reduce
         [_ f start]
         <<tpl-reduce3-start>>)

  ,#+clj cp/CollReduce
  ,#+clj (coll-reduce
         [_ f]
         <<tpl-reduce3>>)
  ,#+clj (coll-reduce
         [_ f start]
         <<tpl-reduce3-start>>)

  ,#+clj Object
  ,#+clj (toString
         [_]
         (.toString
          ^StringBuilder
          (doto (StringBuilder. "[")
            (.append (pr-str x))
            (.append " ")
            (.append (pr-str y))
            (.append " ")
            (.append (pr-str z))
            (.append "]"))))
#+END_SRC
*** ClojureScript protocols
#+BEGIN_SRC clojure :noweb-ref vec3
  ,#+cljs ICloneable
  ,#+cljs (-clone
          [_] (Vec3. x y z -1 #+clj -1))
  
  ,#+cljs ILookup
  ,#+cljs (-lookup
          [_ k] (swizzle3 _ k nil))
  ,#+cljs (-lookup
          [_ k nf] (swizzle3 _ k nf))
  
  ,#+cljs IFn
  ,#+cljs (-invoke
          [_ k] (swizzle3 _ k nil))
  ,#+cljs (-invoke
          [_ k nf] (swizzle3 _ k nf))
  
  ,#+cljs ICounted
  ,#+cljs (-count
          [_] 3)
  
  ,#+cljs IAssociative
  ,#+cljs (-contains-key?
          [_ k] <<tpl-contains-key3>>)
  ,#+cljs (-assoc
          [_ k v] (swizzle3-assoc _ k v))
  
  ,#+cljs IVector
  ,#+cljs (-assoc-n
          [_ k v]
          <<tpl-assoc-n3>>)
  
  ,#+cljs ISequential
  ,#+cljs ISeq
  ,#+cljs (-first
          [_] x)
  ,#+cljs (-rest
          [_] <<tpl-rest3>>)
  
  ,#+cljs INext
  ,#+cljs (-next
          [_] <<tpl-rest3>>)
  
  ,#+cljs ISeqable
  ,#+cljs (-seq
          [_] _)
  
  ,#+cljs IReversible
  ,#+cljs (-rseq
          [_] <<tpl-rseq3>>)
  
  ,#+cljs IIndexed
  ,#+cljs (-nth
          [_ k] <<tpl-nth-err3>>)
  ,#+cljs (-nth
          [_ k nf] <<tpl-nth-nf3>>)
  
  ,#+cljs ICollection
  ,#+cljs (-conj
          [_ w] [x y z w])
  
  ,#+cljs IStack
  ,#+cljs (-peek
          [_] z)
  ,#+cljs (-pop
          [_] (Vec2. x y -1 #+clj -1))
  
  ,#+cljs IComparable
  ,#+cljs (-compare
          [_ o]
          <<tpl-compare3>>)
  
  ,#+cljs IHash
  ,#+cljs (-hash
          [_]
          (if (== -1 _hasheq)
            (set! _hasheq
                  (mix-collection-hash
                   (-> 31 (+ (hash x))
                       (bit-or 0)
                       (imul 31) (+ (hash y))
                       (bit-or 0)
                       (imul 31) (+ (hash z))
                       (bit-or 0))
                   3))
            _hasheq))
  
  ,#+cljs IEquiv
  ,#+cljs (-equiv
          [_ o]
          (if (instance? Vec3 o)
            (and (== x (.-x ^Vec3 o)) (== y (.-y ^Vec3 o)) (== z (.-z ^Vec3 o)))
            (and (sequential? o) (= 3 (count o))
                 (= x (first o)) (= y (nth o 1)) (= z (nth o 2)))))
  
  ,#+cljs IReduce
  ,#+cljs (-reduce
          [coll f]
          <<tpl-reduce3>>)
  ,#+cljs (-reduce
          [coll f start]
          <<tpl-reduce3-start>>)
  
  ,#+cljs Object
  ,#+cljs (toString
          [_] (str "[" x " " y " " z "]"))
#+END_SRC
*** Transformations
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PScale
  (scale
   [_ a] (vec3-op-1 * _ a 1.0))
  (scale
   [_ a b] (vec3-op-2 * * _ a b 1.0 1.0))
  (scale
   [_ a b c] (vec3-op-3 * _ a b c 1.0))
  
  g/PTranslate
  (translate
   [_ a] (vec3-op-1 + _ a 0.0))
  (translate
   [_ a b] (vec3-op-2 + + _ a b 0.0 0.0))
  (translate
   [_ a b c] (vec3-op-3 + _ a b c 0.0))
  
  g/PRotate
  (rotate [_ theta] (g/rotate-z _ theta))
  
  g/PRotate3D
  (rotate-x
   [_ theta]
   (let [s (Math/sin theta) c (Math/cos theta)]
     (Vec3. x (mm/msub y c z s) (mm/madd y s z c) -1 #+clj -1)))
  (rotate-y
   [_ theta]
   (let [s (Math/sin theta) c (Math/cos theta)]
     (Vec3. (mm/madd x c z s) y (mm/msub z c x s) -1 #+clj -1)))
  (rotate-z
   [_ theta]
   (let [s (Math/sin theta) c (Math/cos theta)]
     (Vec3. (mm/msub x c y s) (mm/madd x s y c) z -1 #+clj -1)))
  (rotate-around-axis
   [_ [ax ay az] theta]
   (let [ux (* ax x), uy (* ax y), uz (* ax z)
         vx (* ay x), vy (* ay y), vz (* ay z)
         wx (* az x), wy (* az y), wz (* az z)
         ax2 (* ax ax), ay2 (* ay ay), az2 (* az az)
         s (Math/sin theta), c (Math/cos theta)
         uvw (mm/add ux vy wz)]
     (Vec3.
      (mm/madd uvw ax
               (mm/msub (+ ay2 az2) x (+ vy wz) ax) c
               (mm/subm vz wy s))
  
      (mm/madd uvw ay
               (mm/msub (+ ax2 az2) y (+ ux wz) ay) c
               (mm/subm wx uz s))
  
      (mm/madd uvw az
               (mm/msub (+ ax2 ay2) z (+ ux vy) az) c
               (mm/subm uy vx s))
 -1 #+clj -1)))
  
  g/PTransform
  (transform
   [_ m] (g/transform-vector m _))
#+END_SRC
*** PMathOps
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PMathOps
  (abs [_] (Vec3. (m/abs x) (m/abs y) (m/abs z) -1 #+clj -1))
  (+ [_] _)
  (+ [_ a] (vec3-op-1 + _ a 0.0))
  (+ [_ a b] (vec3-op-2 + + _ a b 0.0 0.0))
  (+ [_ a b c] (vec3-op-3 + _ a b c 0.0))
  
  (- [_] (Vec3. (- x) (- y) (- z) -1 #+clj -1))
  (- [_ a] (vec3-op-1 - _ a 0.0))
  (- [_ a b] (vec3-op-2 - - _ a b 0.0 0.0))
  (- [_ a b c] (vec3-op-3 - _ a b c 0.0))
  
  (* [_] _)
  (* [_ a] (vec3-op-1 * _ a 1.0))
  (* [_ a b] (vec3-op-2 * * _ a b 1.0 1.0))
  (* [_ a b c] (vec3-op-3 * _ a b c 1.0))
  
  (div [_] (Vec3. (/ x) (/ y) (/ z) -1 #+clj -1))
  (div [_ a] (vec3-op-1 / _ a 0.0))
  (div [_ a b] (vec3-op-2 / / _ a b 0.0 0.0))
  (div [_ a b c] (vec3-op-3 / _ a b c 0.0))
  
  (madd [_ a b] (vec3-op-2 * + _ a b 1.0 0.0))
  (addm [_ a b] (vec3-op-2 + * _ a b 0.0 1.0))
  (msub [_ a b] (vec3-op-2 * - _ a b 1.0 0.0))
  (subm [_ a b] (vec3-op-2 - * _ a b 0.0 1.0))
  
  g/PDotProduct
  (dot
   [_ [ax ay az]]
   (mm/madd x ax y ay z az))
  
  g/PCrossProduct
  (cross
   [_ [ax ay az]]
   (Vec3.
    (mm/msub y az ay z)
    (mm/msub z ax az x)
    (mm/msub x ay ax y) -1 #+clj -1))
  
  g/PLimit
  (limit
   [_ len]
   (if (> (g/mag-squared _) (* len len))
     (g/normalize _ len)
     _))
  
  g/PMinMax
  (min
   [_ [ax ay az]]
   (Vec3. (min x ax) (min y ay) (min z az) -1 #+clj -1))
  (min
   [_ [ax ay az] [bx by bz]]
   (Vec3.
    (min (min x ax) bx)
    (min (min y ay) by)
    (min (min z az) bz) -1 #+clj -1))
  (max
   [_ [ax ay az]]
   (Vec3. (max x ax) (max y ay) (max z az) -1 #+clj -1))
  (max
   [_ [ax ay az] [bx by bz]]
   (Vec3.
    (max (max x ax) bx)
    (max (max y ay) by)
    (max (max z az) bz) -1 #+clj -1))
#+END_SRC
*** PDeltaEquals
#+BEGIN_SRC clojure :noweb-ref vec3
  m/PDeltaEquals
  (delta=
   [_ v] (m/delta= _ v *eps*))
  (delta=
   [_ v eps]
   (and (sequential? v)
        (== 3 (count v))
        (m/delta= x (first v) eps)
        (m/delta= y (nth v 1) eps)
        (m/delta= z (nth v 2) eps)))
#+END_SRC
*** PMagnitude
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PMagnitude
  (mag
   [_]
   (Math/sqrt (mm/madd x x y y z z)))
  (mag-squared
   [_] (mm/madd x x y y z z))
#+END_SRC
*** PNormalize
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PNormalize
  (normalize
   [_]
   (let [l (Math/sqrt (mm/madd x x y y z z))]
     (if (pos? l)
       (Vec3. (/ x l) (/ y l) (/ z l) -1 #+clj -1)
       _)))
  (normalize
   [_ len]
   (let [l (Math/sqrt (mm/madd x x y y z z))]
     (if (pos? l)
       (let [l (/ len l)]
         (Vec3. (* x l) (* y l) (* z l) -1 #+clj -1))
       _)))
  (normalized?
   [_] (m/delta= 1.0 (g/mag-squared _)))
#+END_SRC
*** PDistance
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PDistance
  (dist
   [_ a] (Math/sqrt (g/dist-squared _ a)))
  (dist-squared
   [_ a]
   (let [[dx dy dz] (if (instance? Vec3 a)
                      [(- x (.-x ^Vec3 a))
                       (- y (.-y ^Vec3 a))
                       (- z (.-z ^Vec3 a))]
                      [(- x (first a))
                       (- y (nth a 1))
                       (- z (nth a 2 0.0))])]
     (mm/madd dx dx dy dy dz dz)))
#+END_SRC
*** PReflect
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PReflect
  (reflect
   [_ [rx ry rz :as r]]
    (let [d (* (g/dot _ r) 2.0)]
      (Vec3. (mm/msub rx d x) (mm/msub ry d y) (mm/msub rz d z) -1 #+clj -1)))
#+END_SRC
*** PInvert
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PInvert
  (invert
   [_] (Vec3. (- x) (- y) (- z) -1 #+clj -1))
#+END_SRC
*** PInterpolate
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PInterpolate
  (mix
   [_ a]
   (Vec3.
    (mm/mix x (first a) 0.5)
    (mm/mix y (nth a 1) 0.5)
    (mm/mix z (nth a 2) 0.5)
    -1 #+clj -1))
  (mix
   [_ a t]
   (Vec3.
    (mm/mix x (first a) t)
    (mm/mix y (nth a 1) t)
    (mm/mix z (nth a 2) t)
    -1 #+clj -1))
  (mix
   [_ a b c u v]
   (Vec3.
    (mm/mix x (first a) (first b) (first c) u v)
    (mm/mix y (nth a 1) (nth b 1) (nth c 1) u v)
    (mm/mix z (nth a 2) (nth b 2) (nth c 2) u v)
    -1 #+clj -1))
#+END_SRC
*** PHeading
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PHeading
  (heading [_] (g/heading-xy _))
  (heading-xy
   [_]
   (let [t (Math/atan2 y x)]
     (if (neg? t) (+ t TWO_PI) t)))
  (heading-xz
   [_]
   (let [t (Math/atan2 z x)]
     (if (neg? t) (+ t TWO_PI) t)))
  (heading-yz
   [_]
   (let [t (Math/atan2 z y)]
     (if (neg? t) (+ t TWO_PI) t)))
  (angle-between
   [_ a] (Math/acos (g/dot _ a)))
  (slope-xy [_] (/ y x))
  (slope-xz [_] (/ x x))
  (slope-yz [_] (/ z y))
#+END_SRC
*** PPolar

- http://mathworld.wolfram.com/SphericalCoordinates.html
- http://rbrundritt.wordpress.com/2008/10/14/conversion-between-spherical-and-cartesian-coordinates-systems/

#+BEGIN_SRC clojure :noweb-ref vec3
  g/PPolar
  (as-polar
   [_]
    (let [r (g/mag _)
          theta (Math/asin (/ z r))
          phi (Math/atan2 y x)]
      (Vec3. r theta phi -1 #+clj -1)))
  (as-cartesian [_]
    (let [rcos (* x (Math/cos y))]
      (Vec3.
       (* rcos (Math/cos z))
       (* rcos (Math/sin z))
       (* x    (Math/sin y)) -1 #+clj -1)))
#+END_SRC
*** End of implementations
#+BEGIN_SRC clojure :noweb-ref vec3
    )
#+END_SRC
*** Override print methods
#+BEGIN_SRC clojure :noweb-ref vec3
  ,#+clj (defmethod clojure.pprint/simple-dispatch Vec3
          [^Vec3 o] ((get-method clojure.pprint/simple-dispatch clojure.lang.IPersistentVector) o))
  ,#+clj (defmethod print-method Vec3
          [^Vec3 o ^java.io.Writer w] (.write w (.toString o)))
#+END_SRC
** Vector operations
*** 2D
#+BEGIN_SRC clojure :noweb-ref vec-ops
  (defn vec2-op-seq
    [op ^Vec2 acc xs]
    (loop [ax (.-x acc), ay (.-y acc), xs xs]
      (if xs
        (let [v ^Vec2 (first xs)]
          (recur (double (op ax (.-x v))) (double (op ay (.-y v))) (next xs)))
        (Vec2. ax ay -1 #+clj -1))))

  (defn vec2-op-seq2
    [op op2 ^Vec2 acc as b]
    (loop [ax (.-x acc), ay (.-y acc), as as]
      (if as
        (let [v ^Vec2 (first as)]
          (recur (double (op ax (.-x v))) (double (op ay (.-y v))) (next as)))
        (let [[bx by] (if (number? b) [b b] b)]
          (Vec2. (op2 ax bx) (op2 ay by) -1 #+clj -1)))))

  (defn vec2-op-1
    [op ^Vec2 _ a d]
    (if (instance? Vec2 a)
      (Vec2.
       (op (.-x _) (.-x ^Vec2 a))
       (op (.-y _) (.-y ^Vec2 a)) -1 #+clj -1)
      (if (number? a)
        (Vec2. (op (.-x _) a) (op (.-y _) a) -1 #+clj -1)
        (if (instance? Vec2 (first a))
          (vec2-op-seq op _ a)
          (Vec2.
           (op (.-x _) (nth a 0 d))
           (op (.-y _) (nth a 1 d)) -1 #+clj -1)))))

  (defn vec2-op-2
    [op ^Vec2 _ a b d1 d2]
    (if (instance? Vec2 a)
      (if (instance? Vec2 b)
        (Vec2. ;; v v
         (op (op (.-x _) (.-x ^Vec2 a)) (.-x ^Vec2 b))
         (op (op (.-y _) (.-y ^Vec2 a)) (.-y ^Vec2 b)) -1 #+clj -1)
        (if (number? b)
          (Vec2. ;; v n
           (op (op (.-x _) (.-x ^Vec2 a)) b)
           (op (op (.-y _) (.-y ^Vec2 a)) b) -1 #+clj -1)
          (Vec2. ;; v ?
           (op (op (.-x _) (.-x ^Vec2 a)) (nth b 0 d2))
           (op (op (.-y _) (.-y ^Vec2 a)) (nth b 1 d2)) -1 #+clj -1)))
      (let [an? (number? a) bn? (number? b)]
        (if (and an? bn?)
          (Vec2. ;; n n
           (op (.-x _) a)
           (op (.-y _) b) -1 #+clj -1)
          (let [[ax ay] (if an? [a a] a)
                [bx by] (if bn? [b b] b)]
            (Vec2. ;; ? ?
             (op (op (.-x _) (or ax d1)) (or bx d2))
             (op (op (.-y _) (or ay d1)) (or by d2)) -1 #+clj -1))))))

  (defn vec2-op-2*
    "Similar to vec2-op-2 but takes 2 fn args and handles case with
    a & b being both numbers differently."
    [op op2 ^Vec2 _ a b d1 d2]
    (if (instance? Vec2 a)
      (if (instance? Vec2 b)
        (Vec2. ;; v v
         (op2 (op (.-x _) (.-x ^Vec2 a)) (.-x ^Vec2 b))
         (op2 (op (.-y _) (.-y ^Vec2 a)) (.-y ^Vec2 b)) -1 #+clj -1)
        (if (number? b)
          (Vec2. ;; v n
           (op2 (op (.-x _) (.-x ^Vec2 a)) b)
           (op2 (op (.-y _) (.-y ^Vec2 a)) b) -1 #+clj -1)
          (Vec2. ;; v ?
           (op2 (op (.-x _) (.-x ^Vec2 a)) (nth b 0 d2))
           (op2 (op (.-y _) (.-y ^Vec2 a)) (nth b 1 d2)) -1 #+clj -1)))
      (if (and (sequential? a) (instance? Vec2 (first a)))
        (vec2-op-seq2 op op2 _ a b)
        (let [an? (number? a) bn? (number? b)]
          (if (and an? bn?)
            (Vec2.               ;; n n
             (op2 (op (.-x _) a) b) ;; difference to vec2-op-2
             (op2 (op (.-y _) a) b) -1 #+clj -1)
            (let [[ax ay] (if an? [a a] a)
                  [bx by] (if bn? [b b] b)]
              (Vec2. ;; ? ?
               (op2 (op (.-x _) (or ax d1)) (or bx d2))
               (op2 (op (.-y _) (or ay d1)) (or by d2)) -1 #+clj -1)))))))

  (defn vec2-op-3
    [op ^Vec2 _ a b c d]
    (if (instance? Vec2 a)
      (if (instance? Vec2 b)
        (if (instance? Vec2 c)
          (Vec2. ;; v v v
           (op (op (op (.-x _) (.-x ^Vec2 a)) (.-x ^Vec2 b)) (.-x ^Vec2 c))
           (op (op (op (.-y _) (.-y ^Vec2 a)) (.-y ^Vec2 b)) (.-y ^Vec2 c)) -1 #+clj -1)
          (if (number? c)
            (Vec2. ;; v v n
             (op (op (op (.-x _) (.-x ^Vec2 a)) (.-x ^Vec2 b)) c)
             (op (op (op (.-y _) (.-y ^Vec2 a)) (.-y ^Vec2 b)) c) -1 #+clj -1)
            (Vec2. ;; v v ?
             (op (op (op (.-x _) (.-x ^Vec2 a)) (.-x ^Vec2 b)) (nth c 0 d))
             (op (op (op (.-y _) (.-y ^Vec2 a)) (.-y ^Vec2 b)) (nth c 1 d)) -1 #+clj -1)))
        (let [[bx by] (if (number? b) [b b] b)
              [cx cy] (if (number? c) [c c] c)]
          (Vec2. ;; v ? ?
           (op (op (op (.-x _) (.-x ^Vec2 a)) (or bx d)) (or cx d))
           (op (op (op (.-y _) (.-y ^Vec2 a)) (or by d)) (or cy d)) -1 #+clj -1)))
      (let [[ax ay] (if (number? a) [a a] a)
            [bx by] (if (number? b) [b b] b)
            [cx cy] (if (number? c) [c c] c)]
        (Vec2. ;; ? ? ?
         (op (op (op (.-x _) (or ax d)) (or bx d)) (or cx d))
         (op (op (op (.-y _) (or ay d)) (or by d)) (or cy d)) -1 #+clj -1))))
#+END_SRC
*** 3D
#+BEGIN_SRC clojure :noweb-ref vec-ops
  (defn vec3-op-seq
    [op ^Vec3 acc xs]
    (loop [ax (.-x acc), ay (.-y acc), az (.-z acc), xs xs]
      (if xs
        (let [v ^Vec3 (first xs)]
          (recur (double (op ax (.-x v))) (double (op ay (.-y v))) (double (op az (.-z v))) (next xs)))
        (Vec3. ax ay az -1 #+clj -1))))

  (defn vec3-op-seq2
    [op op2 ^Vec3 acc as b]
    (loop [ax (.-x acc), ay (.-y acc), az (.-z acc), as as]
      (if as
        (let [v ^Vec3 (first as)]
          (recur (double (op ax (.-x v))) (double (op ay (.-y v))) (double (op az (.-z v))) (next as)))
        (let [[bx by bz] (if (number? b) [b b b] b)]
          (Vec3. (op2 ax bx) (op2 ay by) (op2 az bz) -1 #+clj -1)))))

  (defn vec3-op-1
    [op ^Vec3 _ a d]
    (if (instance? Vec3 a)
      (Vec3.
       (op (.-x _) (.-x ^Vec3 a))
       (op (.-y _) (.-y ^Vec3 a))
       (op (.-z _) (.-z ^Vec3 a)) -1 #+clj -1)
      (if (number? a)
        (Vec3. (op (.-x _) a) (op (.-y _) a) (op (.-z _) a) -1 #+clj -1)
        (if (instance? Vec3 (first a))
          (vec3-op-seq op _ a)
          (Vec3.
           (op (.-x _) (nth a 0 d))
           (op (.-y _) (nth a 1 d))
           (op (.-z _) (nth a 2 d)) -1 #+clj -1)))))

  (defn vec3-op-2
    [op op2 ^Vec3 _ a b d1 d2]
    (if (instance? Vec3 a)
      (if (instance? Vec3 b)
        (Vec3. ;; v v
         (op2 (op (.-x _) (.-x ^Vec3 a)) (.-x ^Vec3 b))
         (op2 (op (.-y _) (.-y ^Vec3 a)) (.-y ^Vec3 b))
         (op2 (op (.-z _) (.-z ^Vec3 a)) (.-z ^Vec3 b)) -1 #+clj -1)
        (if (number? b)
          (Vec3. ;; v n
           (op2 (op (.-x _) (.-x ^Vec3 a)) b)
           (op2 (op (.-y _) (.-y ^Vec3 a)) b)
           (op2 (op (.-z _) (.-z ^Vec3 a)) b) -1 #+clj -1)
          (Vec3. ;; v ?
           (op2 (op (.-x _) (.-x ^Vec3 a)) (nth b 0 d2))
           (op2 (op (.-y _) (.-y ^Vec3 a)) (nth b 1 d2))
           (op2 (op (.-z _) (.-z ^Vec3 a)) (nth b 2 d2)) -1 #+clj -1)))
      (if (and (sequential? a) (instance? Vec3 (first a)))
        (vec3-op-seq2 op op2 _ a b)
        (let [[ax ay az] (if (number? a) [a a a] a)
              [bx by bz] (if (number? b) [b b b] b)]
          (Vec3. ;; ? ? ?
           (op2 (op (.-x _) (or ax d1)) (or bx d2))
           (op2 (op (.-y _) (or ay d1)) (or by d2))
           (op2 (op (.-z _) (or az d1)) (or bz d2)) -1 #+clj -1)))))

  (defn vec3-op-3
    [op ^Vec3 _ a b c d]
    (if (instance? Vec3 a)
      (if (instance? Vec3 b)
        (if (instance? Vec3 c)
          (Vec3. ;; v v v
           (op (op (op (.-x _) (.-x ^Vec3 a)) (.-x ^Vec3 b)) (.-x ^Vec3 c))
           (op (op (op (.-y _) (.-y ^Vec3 a)) (.-y ^Vec3 b)) (.-y ^Vec3 c))
           (op (op (op (.-z _) (.-z ^Vec3 a)) (.-z ^Vec3 b)) (.-z ^Vec3 c)) -1 #+clj -1)
          (if (number? c)
            (Vec3. ;; v v n
             (op (op (op (.-x _) (.-x ^Vec3 a)) (.-x ^Vec3 b)) c)
             (op (op (op (.-y _) (.-y ^Vec3 a)) (.-y ^Vec3 b)) c)
             (op (op (op (.-z _) (.-z ^Vec3 a)) (.-z ^Vec3 b)) c) -1 #+clj -1)
            (Vec3. ;; v v ?
             (op (op (op (.-x _) (.-x ^Vec3 a)) (.-x ^Vec3 b)) (nth c 0 d))
             (op (op (op (.-y _) (.-y ^Vec3 a)) (.-y ^Vec3 b)) (nth c 1 d))
             (op (op (op (.-z _) (.-z ^Vec3 a)) (.-z ^Vec3 b)) (nth c 2 d)) -1 #+clj -1)))
        (let [[bx by bz] (if (number? b) [b b b] b)
              [cx cy cz] (if (number? c) [c c c] c)]
          (Vec3. ;; v ? ?
           (op (op (op (.-x _) (.-x ^Vec3 a)) (or bx d)) (or cx d))
           (op (op (op (.-y _) (.-y ^Vec3 a)) (or by d)) (or cy d))
           (op (op (op (.-z _) (.-z ^Vec3 a)) (or bz d)) (or cz d)) -1 #+clj -1)))
      (let [an? (number? a) bn? (number? b) cn? (number? c)]
        (if (and an? bn? cn?)
          (Vec3. ;; n n n
           (op (.-x _) a)
           (op (.-y _) b)
           (op (.-z _) c) -1 #+clj -1)
          (let [[ax ay az] (if (number? a) [a a a] a)
                [bx by bz] (if (number? b) [b b b] b)
                [cx cy cz] (if (number? c) [c c c] c)]
            (Vec3. ;; ? ? ?
             (op (op (op (.-x _) (or ax d)) (or bx d)) (or cx d))
             (op (op (op (.-y _) (or ay d)) (or by d)) (or cy d))
             (op (op (op (.-z _) (or az d)) (or bz d)) (or cz d)) -1 #+clj -1))))))
#+END_SRC
** Constants
#+BEGIN_SRC clojure :noweb-ref constants
  (def V2 (Vec2. 0.0 0.0 -1 #+clj -1))
  (def V3 (Vec3. 0.0 0.0 0.0 -1 #+clj -1))
  
  (def V2X (Vec2. 1.0 0.0 -1 #+clj -1))
  (def V2Y (Vec2. 0.0 1.0 -1 #+clj -1))
  
  (def V3X (Vec3. 1.0 0.0 0.0 -1 #+clj -1))
  (def V3Y (Vec3. 0.0 1.0 0.0 -1 #+clj -1))
  (def V3Z (Vec3. 0.0 0.0 1.0 -1 #+clj -1))
  
  (def V2INF- (Vec2. INF- INF- -1 #+clj -1))
  (def V2INF+ (Vec2. INF+ INF+ -1 #+clj -1))
  
  (def V3INF- (Vec3. INF- INF- INF- -1 #+clj -1))
  (def V3INF+ (Vec3. INF+ INF+ INF+ -1 #+clj -1))
#+END_SRC
** Constructors

To simplify vector type construction, factory functions
are provided which coerce arguments into vectors with these
rules:

| Input                 | Behavior                                           | Examples call        | Example result  |
|-----------------------+----------------------------------------------------+----------------------+-----------------|
| Clojure vector or seq | select first =n= elements or fill missing with 0.0 | =(vec2 [1 2 3 4])=   | =[1.0 2.0]=     |
|                       |                                                    | =(vec3 '(1 2)=       | =[1.0 2.0 0.0]= |
| Map                   | select values of =:x :y :z= or fill with 0.0       | =(vec2 {:x 1 :y 2})= | =[1.0 2.0]=     |
|                       |                                                    | =(vec3 {:x 1 :y 2})= | =[1.0 2.0 0.0]= |
| Single number         | set all vector components                          | =(vec3 1)=           | =[1.0 1.0 1.0]= |

#+BEGIN_SRC clojure :noweb-ref ctors
  (defn vec2
    ([] V2)
    ([x] (cond
          (instance? Vec2 x) x
          (sequential? x) (Vec2. (nth x 0 0.0) (nth x 1 0.0) -1 #+clj -1)
          (number? x) (Vec2. x x -1 #+clj -1)
          (map? x) (Vec2. (get x :x 0.0) (get x :y 0.0) -1 #+clj -1)
          :default (err/type-error! "Vec2" x)))
    ([x y] (Vec2. x y -1 #+clj -1)))
  
  (defn vec3
    ([] V3)
    ([x] (cond
          (instance? Vec3 x) x
          (sequential? x) (Vec3. (nth x 0 0.0) (nth x 1 0.0) (nth x 2 0.0) -1 #+clj -1)
          (number? x) (Vec3. x x x -1 #+clj -1)
          (map? x) (Vec3. (get x :x 0.0) (get x :y 0.0) (get x :z 0.0) -1 #+clj -1)
          :default (err/type-error! "Vec3" x)))
    ([x y] (Vec3. x y 0.0 -1 #+clj -1))
    ([x y z] (Vec3. x y z -1 #+clj -1)))
  
  (defn vec2? [x] (instance? Vec2 x))
  (defn vec3? [x] (instance? Vec3 x))
#+END_SRC

** Random vectors
#+BEGIN_SRC clojure :noweb-ref ctors
  (defn randvec2
    ([] (g/normalize (vec2 (m/randnorm) (m/randnorm))))
    ([n] (g/normalize (vec2 (m/randnorm) (m/randnorm)) n)))

  (defn randvec3
    ([] (g/normalize (vec3 (m/randnorm) (m/randnorm) (m/randnorm))))
    ([n] (g/normalize (vec3 (m/randnorm) (m/randnorm) (m/randnorm)) n)))
#+END_SRC

** Swizzling
#+BEGIN_SRC clojure :noweb-ref swizzle
  (defn lookup2
    [^Vec2 _ k nf]
    (case k
      \x (.-x _)
      \y (.-y _)
      (or nf (err/key-error! k))))

  (defn lookup3
    [^Vec3 _ k nf]
    (case k
      \x (.-x _)
      \y (.-y _)
      \z (.-z _)
      (or nf (err/key-error! k))))

  (defn swizzle-assoc*
    [_ ctor keymap k v]
    (let [n (name k)
          c (count n)]
      (if (and (<= c (count keymap)) (== c (count v) (count (into #{} n))))
        (loop [acc (vec _), i 0, n n]
          (if n
            (recur (assoc acc (keymap (first n)) (v i)) (inc i) (next n))
            (ctor acc)))
        (err/key-error! k))))

  (defn swizzle2
    [^Vec2 _ k default]
    (if (number? k)
      (case (int k)
        0 (.-x _)
        1 (.-y _)
        (or default (err/key-error! k)))
      (case k
        :x (.-x _)
        :y (.-y _)
        (let [n (name k) c (count n)]
          (case c
            2 (Vec2.
               (lookup2 _ (first n) default)
               (lookup2 _ (nth n 1) default) -1 #+clj -1)
            3 (Vec3.
               (lookup2 _ (first n) default)
               (lookup2 _ (nth n 1) default)
               (lookup2 _ (nth n 2) default) -1 #+clj -1)
            (or default (err/key-error! k)))))))

  (defn swizzle2-assoc
    [^Vec2 _ k v]
    (case k
      0 (Vec2. v (.-y _) -1 #+clj -1)
      1 (Vec2. (.-x _) v -1 #+clj -1)
      :x (Vec2. v (.-y _) -1 #+clj -1)
      :y (Vec2. (.-x _) v -1 #+clj -1)
      :xy (Vec2. (v 0) (v 1) -1 #+clj -1)
      :yx (Vec2. (v 1) (v 0) -1 #+clj -1)
      (err/key-error! k)))

  (defn swizzle3
    [^Vec3 _ k default]
    (if (number? k)
      (case (int k)
        0 (.-x _)
        1 (.-y _)
        2 (.-z _)
        (or default (err/key-error! k)))
      (case k
        :x (.-x _)
        :y (.-y _)
        :z (.-z _)
        (let [n (name k) c (count n)]
          (case c
            2 (Vec2.
               (lookup3 _ (first n) default)
               (lookup3 _ (nth n 1) default) -1 #+clj -1)
            3 (Vec3.
               (lookup3 _ (first n) default)
               (lookup3 _ (nth n 1) default)
               (lookup3 _ (nth n 2) default) -1 #+clj -1)
            (or default (err/key-error! k)))))))

  (defn swizzle3-assoc
    [^Vec3 _ k v]
    (case k
      :x (Vec3. v (.-y _) (.-z _) -1 #+clj -1)
      :y (Vec3. (.-x _) v (.-z _) -1 #+clj -1)
      :z (Vec3. (.-x _) (.-y _) v -1 #+clj -1)
      0 (Vec3. v (.-y _) (.-z _) -1 #+clj -1)
      1 (Vec3. (.-x _) v (.-z _) -1 #+clj -1)
      2 (Vec3. (.-x _) (.-y _) v -1 #+clj -1)
      (swizzle-assoc* _ vec3 {\x 0 \y 1 \z 2} k v)))
#+END_SRC

** Complete namespace definition                                   :noexport:
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/vector.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.core.vector
    ,#+cljs
    (:require-macros
     [thi.ng.macromath.core :as mm])
    (:require
     [thi.ng.geom.core :as g]
     [thi.ng.common.data.core :as d]
     [thi.ng.common.error :as err]
     [thi.ng.common.math.core :as m :refer [*eps* PI TWO_PI INF- INF+]]
     ,#+clj [thi.ng.geom.core.vectorseq]
     ,#+clj [thi.ng.macromath.core :as mm]
     ,#+clj [clojure.core.protocols :as cp]
     ,#+clj [clojure.pprint])
    ,#+clj
    (:import
     [thi.ng.geom.core.vectorseq VectorSeq]))

  (declare vec2 swizzle2 swizzle2-assoc)
  (declare vec3 swizzle3 swizzle3-assoc)
  (declare vec2-op-1 vec2-op-2 vec2-op-2* vec2-op-3)
  (declare vec3-op-1 vec3-op-2 vec3-op-3)

  <<helpers>>

  <<vec2>>

  <<vec3>>

  <<vec-ops>>

  <<constants>>

  <<ctors>>

  <<swizzle>>
#+END_SRC
