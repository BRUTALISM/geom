#+SETUPFILE: ../../src/setup.org

* Contents                                                         :toc_3_gh:
 - [[#thinggeomtvec][thi.ng.geom.tvec]]
     - [[#vec3][Vec3]]
         - [[#clojurescript-protocols][ClojureScript protocols]]
         - [[#pmathops][PMathOps]]
         - [[#pdotproduct][PDotProduct]]
         - [[#pclear][PClear]]
         - [[#pcrossproduct][PCrossProduct]]
         - [[#plimit][PLimit]]
         - [[#pminmax][PMinMax]]
         - [[#pdeltaequals][PDeltaEquals]]
         - [[#pmagnitude][PMagnitude]]
         - [[#pnormalize][PNormalize]]
         - [[#pdistance][PDistance]]
         - [[#preflect][PReflect]]
         - [[#pinvert][PInvert]]
         - [[#pinterpolate][PInterpolate]]
         - [[#pheading][PHeading]]
         - [[#ppolar][PPolar]]
         - [[#end-implementation][End implementation]]
     - [[#swizzling][Swizzling]]
     - [[#constructors][Constructors]]
     - [[#code-rewriting-macros][Code rewriting macros]]
     - [[#complete-namespace-definitions][Complete namespace definitions]]

* thi.ng.geom.tvec

** Vec3

#+BEGIN_SRC clojure :noweb-ref vec3
  ,#+cljs
  (deftype Vec3
      [buf ^:mutable _hash _meta]
#+END_SRC

*** ClojureScript protocols

#+BEGIN_SRC clojure :noweb-ref vec3
  IMeta
  (-meta [_] _meta)
  IWithMeta
  (-with-meta [_ m] (Vec3. (js/Float32Array. buf) _hash m))

  ICloneable
  (-clone
   [_] (Vec3. (js/Float32Array. buf) _hash _meta))

  ILookup
  (-lookup
   [_ k]
   (if (keyword? k)
     (if-let [f (swizzle3-fns k)]
       (f _)
       (err/key-error! k))
     (if (and (>= k 0) (<= k 2))
       (aget buf k)
       (err/key-error! k))))
  (-lookup
   [_ k nf]
   (if (keyword? k)
     (if-let [f (swizzle3-fns k)] (f _) nf)
     (if (and (>= k 0) (<= k 2)) (aget buf k) nf)))

  IFn
  (-invoke
   [_ k]
   (if (keyword? k)
     (if-let [f (swizzle3-fns k)]
       (f _)
       (err/key-error! k))
     (if (and (>= k 0) (<= k 2))
       (aget buf k)
       (err/key-error! k))))
  (-invoke
   [_ k nf]
   (if (keyword? k)
     (if-let [f (swizzle3-fns k)] (f _) nf)
     (if (and (>= k 0) (<= k 2)) (aget buf k) nf)))

  ICounted
  (-count
   [_] 3)

  IAssociative
  (-contains-key?
   [_ k]
   (if (number? k)
     (and (>= k 0) (<= k 2))
     (if (swizzle3-fns k) true false)))
  (-assoc
   [_ k v]
   (let [b (js/Float32Array. buf)] ;; FIXME allow keywords & swizzling assoc
     (aset b k v)
     (Vec3. b nil _meta)))

  IVector
  (-assoc-n
   [_ n v]
   (let [b (js/Float32Array. buf)]
     (aset b n v)
     (Vec3. b nil _meta)))

  ISequential
  ISeq
  (-first
   [_] (aget buf 0))
  (-rest
   [_] (cons (aget buf 1) (cons (aget buf 2) nil)))

  INext
  (-next
   [_] (cons (aget buf 1) (cons (aget buf 2) nil)))

  ISeqable
  (-seq
   [_] _)

  IReversible
  (-rseq
   [_]
   (let [b (js/Float32Array. 3)]
     (aset b 0 (aget buf 2))
     (aset b 1 (aget buf 1))
     (aset b 2 (aget buf 0))
     (Vec3. b nil _meta)))

  IIndexed
  (-nth
   [_ n] (aget buf n))
  (-nth
   [_ n nf] (if (and (>= n 0) (<= n 2)) (aget buf n) nf))

  ICollection
  (-conj
   [_ x] [(aget buf 0) (aget buf 1) (aget buf 2) x])

  IStack
  (-peek
   [_] (aget buf 2))
  (-pop
   [_] [(aget buf 0) (aget buf 1)]) ;; TODO Vec2

  IComparable
  (-compare
   [_ x]
   (if (instance? Vec3 x)
     (let [b' (.-buf ^Vec3 x)
           c (compare (aget buf 0) (aget b' 0))]
       (if (== 0 c)
         (let [c (compare (aget buf 1) (aget b' 1))]
           (if (== 0 c)
             (compare  (aget buf 2) (aget b' 2))
             c))
         c))
     (let [c (count x)]
       (if (== 3 c) (compare x _) (- 3 c)))))

  IHash
  (-hash
   [_]
   (or _hash
       (set! (.-__hash _)
             (mix-collection-hash
              (-> 31 (+ (hash (aget buf 0)))
                  (bit-or 0)
                  (imul 31) (+ (hash (aget buf 1)))
                  (bit-or 0)
                  (imul 31) (+ (hash (aget buf 2)))
                  (bit-or 0))
              3))))

  IEquiv
  (-equiv
   [_ o]
   (if (instance? Vec3 o)
     (let [b' (.-buf ^Vec3 o)]
       (and (== (aget buf 0) (aget b' 0)) (== (aget buf 1) (aget b' 1)) (== (aget buf 2) (aget b' 2))))
     (and (sequential? o) (== 3 (count o))
          (= (aget buf 0) (first o)) (= (aget buf 1) (nth o 1)) (= (aget buf 2) (nth o 2)))))

  IReduce
  (-reduce
   [coll f]
   (let [acc (f (aget buf 0) (aget buf 1))]
     (if (reduced? acc)
       @acc
       (let [acc (f acc (aget buf 2))]
         (if (reduced? acc)
           @acc
           acc)))))
  (-reduce
   [coll f start]
   (let [acc (f start (aget buf 0))]
     (if (reduced? acc)
       @acc
       (let [acc (f acc (aget buf 1))]
         (if (reduced? acc)
           @acc
           (let [acc (f acc (aget buf 2))]
             (if (reduced? acc)
               @acc
               acc)))))))

  Object
  (toString
   [_] (str "[" (aget buf 0) " " (aget buf 1) " " (aget buf 2) "]"))

  g/PBuffered
  (get-buffer [_] buf)
  (copy-to-buffer [_ dest idx] (.set dest buf idx) dest)
#+END_SRC

*** PMathOps

#+BEGIN_SRC clojure :noweb-ref vec3
  g/PMathOps
  (+ [_] _)
  (+ [_ v]       (vm/v3-op1 + buf v _meta))
  (+ [_ v1 v2]   (vm/v3-op2 + + buf v1 v2 0.0 0.0 _meta))
  (+ [_ x y z]   (vm/v3-op1-xyz + buf x y z _meta))
  (- [_]         (vm/v3-op0 - buf _meta))
  (- [_ v]       (vm/v3-op1 - buf v _meta))
  (- [_ v1 v2]   (vm/v3-op2 - - buf v1 v2 0.0 0.0 _meta))
  (- [_ x y z]   (vm/v3-op1-xyz - buf x y z _meta))
  (* [_] _)
  (* [_ v]       (vm/v3-op1 * buf v _meta))
  (* [_ v1 v2]   (vm/v3-op2 * * buf v1 v2 1.0 1.0 _meta))
  (* [_ x y z]   (vm/v3-op1-xyz * buf x y z _meta))
  (div [_]       (vm/v3-op0 / buf _meta))
  (div [_ v]     (vm/v3-op1 / buf v _meta))
  (div [_ v1 v2] (vm/v3-op2 / / buf v1 v2 0.0 0.0 _meta))
  (div [_ x y z] (vm/v3-op1-xyz / buf x y z _meta))
  (madd [_ a b]  (vm/v3-op2 * + buf a b 1.0 0.0 _meta))
  (addm [_ a b]  (vm/v3-op2 + * buf a b 0.0 1.0 _meta))
  (msub [_ a b]  (vm/v3-op2 * - buf a b 1.0 0.0 _meta))
  (subm [_ a b]  (vm/v3-op2 - * buf a b 0.0 1.0 _meta))
#+END_SRC

*** PDotProduct

#+BEGIN_SRC clojure :noweb-ref vec3
  g/PDotProduct
  (dot
   [_ v] (vm/rewrite-v3-v-no-let buf v 0.0 (+ (+ (* x vx) (* y vy)) (* z vz))))
#+END_SRC
*** PClear
#+BEGIN_SRC clojure :noweb-ref vec3'
  g/PClear
  (clear* [_] V3)
#+END_SRC
*** PCrossProduct
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PCrossProduct
  (cross
   [_ v]
   (let [b (js/Float32Array. 3)]
     (vm/rewrite-v3-v buf v 0.0
       (aset b 0 (mm/msub y vz vy z))
       (aset b 1 (mm/msub z vx vz x))
       (aset b 2 (mm/msub x vy vx y)))
     (Vec3. b nil _meta)))
#+END_SRC
*** PLimit
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PLimit
  (limit
   [_ len]
   (if (> (g/mag-squared _) (* len len))
     (g/normalize _ len)
     _))
#+END_SRC
*** PMinMax
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PMinMax
  (min
   [_ v] (vm/v3-op1 Math/min buf v _meta))
  (min
   [_ v v2] (vm/v3-op2 Math/min Math/min buf v v2 0.0 0.0 _meta))
  (max
   [_ v] (vm/v3-op1 Math/max buf v _meta))
  (max
   [_ v v2] (vm/v3-op2 Math/max Math/max buf v v2 0.0 0.0 _meta))
#+END_SRC
*** PDeltaEquals
#+BEGIN_SRC clojure :noweb-ref vec3
  m/PDeltaEquals
  (delta=
   [_ v] (m/delta= _ v *eps*))
  (delta=
   [_ v eps]
   (if (and (sequential? v) (== 3 (count v)))
     (vm/rewrite-v3-v-no-let
      buf v 0.0
      (if (m/delta= x vx eps)
        (if (m/delta= y vy eps)
          (m/delta= z vz eps))))))
#+END_SRC
*** PMagnitude
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PMagnitude
  (mag
   [_] (vm/rewrite-v3 buf (Math/sqrt (mm/madd x x y y z z))))
  (mag-squared
   [_] (vm/rewrite-v3 buf (mm/madd x x y y z z)))
#+END_SRC
*** PNormalize
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PNormalize
  (normalize
   [_]
   (vm/rewrite-v3
    buf
    (let [l (Math/sqrt (mm/madd x x y y z z))]
      (if (pos? l)
        (let [b (js/Float32Array. 3)]
          (aset b 0 (/ x l))
          (aset b 1 (/ y l))
          (aset b 2 (/ z l))
          (Vec3. b nil _meta))
        _))))
  (normalize
   [_ len]
   (vm/rewrite-v3
    buf
    (let [l (Math/sqrt (mm/madd x x y y z z))]
      (if (pos? l)
        (let [l (/ len l)
              b (js/Float32Array. 3)]
          (aset b 0 (* x l))
          (aset b 1 (* y l))
          (aset b 2 (* z l))
          (Vec3. b nil _meta))
        _))))
  (normalized?
   [_] (m/delta= 1.0 (g/mag-squared _)))
#+END_SRC
*** PDistance
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PDistance
  (dist
   [_ v] (Math/sqrt (g/dist-squared _ v)))
  (dist-squared
   [_ v]
   (vm/rewrite-v3-v buf v 0.0
     (let [dx (- x vx)
           dy (- y vy)
           dz (- z vz)]
       (mm/madd dx dx dy dy dz dz))))
#+END_SRC
*** PReflect
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PReflect
  (reflect
   [_ v]
   (let [b (js/Float32Array. 3)]
     (vm/rewrite-v3-v buf v 0.0
       (let [d (* (+ (+ (* x vx) (* y vy)) (* z vz)) 2.0)]
         (aset b 0 (mm/msub vx d x))
         (aset b 1 (mm/msub vy d y))
         (aset b 2 (mm/msub vz d z))
         (Vec3. b nil _meta)))))
#+END_SRC
*** PInvert
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PInvert
  (invert
   [_] (g/- _))
#+END_SRC
*** PInterpolate
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PInterpolate
  (mix
   [_ v]
   (let [b (js/Float32Array. 3)]
     (vm/rewrite-v3-nv-no-let
      buf v 0.0
      (aset b 0 (* (+ x vx) 0.5))
      (aset b 1 (* (+ y vy) 0.5))
      (aset b 2 (* (+ z vz) 0.5)))
     (Vec3. b nil _meta)))
  (mix
   [_ v v2]
   (let [b (js/Float32Array. 3)]
     (vm/rewrite-v3-nv-nv
      buf v v2 0.0 0.0
      (aset b 0 (+ (* (- bx x) cx) x))
      (aset b 1 (+ (* (- by y) cy) y))
      (aset b 2 (+ (* (- bz z) cz) z)))
     (Vec3. b nil _meta)))
  (mix
   [_ b c d u v]
   (let [b' (js/Float32Array. 3)
         dv? (instance? Vec3 d)
         dn? (number? d)
         d  (if dv? (.-buf d) d)
         dx (if dv? (aget d 0) (if dn? d (nth d 0 0.0)))
         dy (if dv? (aget d 1) (if dn? d (nth d 1 0.0)))
         dz (if dv? (aget d 2) (if dn? d (nth d 2 0.0)))]
     (vm/rewrite-v3-nv-nv
      buf b c 0.0 0.0
      (let [x1 (+ (* (- bx x) u) x)
            y1 (+ (* (- by y) u) y)
            z1 (+ (* (- bz z) u) z)]
        (aset b' 0 (+ (* (- (+ (* (- dx cx) u) cx) x1) v) x1))
        (aset b' 1 (+ (* (- (+ (* (- dy cy) u) cy) y1) v) y1))
        (aset b' 2 (+ (* (- (+ (* (- dz cz) u) cz) z1) v) z1))))
     (Vec3. b' nil _meta)))
#+END_SRC
*** PHeading
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PHeading
  (heading [_] (g/heading-xy _))
  (heading-xy
   [_]
   (let [t (Math/atan2 (aget buf 1) (aget buf 0))]
     (if (neg? t) (+ t TWO_PI) t)))
  (heading-xz
   [_]
   (let [t (Math/atan2 (aget buf 2) (aget buf 0))]
     (if (neg? t) (+ t TWO_PI) t)))
  (heading-yz
   [_]
   (let [t (Math/atan2 (aget buf 2) (aget buf 1))]
     (if (neg? t) (+ t TWO_PI) t)))
  (angle-between
   [_ a] (Math/acos (g/dot _ a)))
  (slope-xy [_] (/ (aget buf 1) (aget buf 0)))
  (slope-xz [_] (/ (aget buf 2) (aget buf 0)))
  (slope-yz [_] (/ (aget buf 2) (aget buf 1)))
#+END_SRC
*** PPolar

- http://mathworld.wolfram.com/SphericalCoordinates.html
- http://rbrundritt.wordpress.com/2008/10/14/conversion-between-spherical-and-cartesian-coordinates-systems/

#+BEGIN_SRC clojure :noweb-ref vec3
  g/PPolar
  (as-polar
   [_]
   (let [r (g/mag _)
         b (js/Float32Array. 3)]
     (aset b 0 r)
     (aset b 1 (Math/asin (/ (aget buf 2) r)))
     (aset b 2 (Math/atan2 (aget buf 1) (aget buf 0)))
     (Vec3. b nil _meta)))
  (as-cartesian
   [_]
   (let [b buf
         x (aget b 0)
         y (aget b 1)
         z (aget b 2)
         rcos (* x (Math/cos y))
         b' (js/Float32Array. 3)]
     (aset b' 0 (* rcos (Math/cos z)))
     (aset b' 1 (* rcos (Math/sin z)))
     (aset b' 2 (* x    (Math/sin y)))
     (Vec3. b' nil _meta)))
#+END_SRC

*** End implementation

#+BEGIN_SRC clojure :noweb-ref vec3
  )
#+END_SRC

** Swizzling

#+BEGIN_SRC clojure :noweb-ref swizzle-macros
  (def ^:private swizzle-keys
    {\x 0 \y 1 \z 2 \w 3})

  (def ^:private swizzle-perms
    (->> [(d/cartesian-product '#{x y z} '#{x y z} '#{x y z})
          (d/cartesian-product '#{x y} '#{x y})
          (d/cartesian-product '#{x z} '#{x z})
          (d/cartesian-product '#{y z} '#{y z})
          '((x) (y) (z))]
         (apply concat)
         (map #(symbol (apply str %)))))

  (defmacro float-array*
    [n]
    (let [name (symbol (str "float" n))]
      `(defn ~name [] (js/Float32Array. ~n))))

  (defmacro defswizzle
    [key]
    (let [id (str key)
          a (gensym)
          b (gensym)
          c (count id)
          type (if (== 3 c) 'Vec3 'Vec2)]
      (if (== 1 c)
        `(defn ~key
           [_#] (aget (.-buf _#) ~(swizzle-keys (first id))))
        `(defn ~key [_#]
           (let [~a (.-buf _#)
                 ~b (new js/Float32Array ~c)]
             ~@(map-indexed
                (fn [i ch]
                  (list 'aset b i (list 'aget a (swizzle-keys ch))))
                id)
             (new ~type ~b nil (.-_meta _#)))))))
#+END_SRC

** Constructors

#+BEGIN_SRC clojure :noweb-ref ctors
  ,#+cljs
  (defn vec3
    [x y z]
    (let [b (js/Float32Array. 3)]
      (aset b 0 x)
      (aset b 1 y)
      (aset b 2 z)
      (Vec3. b nil nil)))
#+END_SRC

** Code rewriting macros

#+BEGIN_SRC clojure :noweb-ref v3-macros
  (defmacro lookup3
    [src k nf]
    `(case ~k
       \x (aget ~src 0)
       \y (aget ~src 1)
       \z (aget ~src 2)
       (or ~nf (err/key-error! ~k))))

  (defmacro rewrite-v3
    [src & body]
    (let [[a x y z] (repeatedly 4 gensym)]
      `(let [~a ~src, ~x (aget ~a 0), ~y (aget ~a 1), ~z (aget ~a 2)]
         ~@(postwalk-replace {'x x 'y y 'z z} body))))

  (defmacro rewrite-v3-no-let
    [src & body]
    (let [a (gensym)]
      `(let [~a ~src]
         ~@(postwalk-replace
            {'x `(aget ~a 0) 'y `(aget ~a 1) 'z `(aget ~a 2)}
            body))))

  (defmacro rewrite-v3-v-no-let
    [src v default & body]
    (let [a (gensym)
          b (gensym)]
      `(let [~a ~src]
         (if (instance? ~'Vec3 ~v)
           (let [~b (.-buf ~v)]
             ~@(postwalk-replace
                {'x `(aget ~a 0) 'y `(aget ~a 1) 'z `(aget ~a 2)
                 'vx `(aget ~b 0) 'vy `(aget ~b 1) 'vz `(aget ~b 2)}
                body))
           (do ~@(postwalk-replace
                  {'x `(aget ~a 0) 'y `(aget ~a 1) 'z `(aget ~a 2)
                   'vx `(nth ~v 0 ~default) 'vy `(nth ~v 1 ~default) 'vz `(nth ~v 2 ~default)}
                  body))))))

  (defmacro rewrite-v3-v
    [src v default & body]
    (let [[a b x y z vx vy vz] (repeatedly 8 gensym)]
      `(let [~a ~src, ~x (aget ~a 0), ~y (aget ~a 1), ~z (aget ~a 2)]
         (if (instance? ~'Vec3 ~v)
           (let [~b (.-buf ~v), ~vx (aget ~b 0), ~vy (aget ~b 1), ~vz (aget ~b 2)]
             ~@(postwalk-replace {'x x 'y y 'z z 'vx vx 'vy vy 'vz vz} body))
           (let [~vx (nth ~v 0 ~default), ~vy (nth ~v 1 ~default), ~vz (nth ~v 2 ~default)]
             ~@(postwalk-replace {'x x 'y y 'z z 'vx vx 'vy vy 'vz vz} body))))))

  (defmacro rewrite-v3-nv
    [src v default & body]
    (let [[a v? nv vx vy vz] (repeatedly 6 gensym)]
      `(let [~a ~src
             ~v? (instance? ~'Vec3 ~v)
             ~nv (if ~v? (.-buf ~v) (number? ~v))
             ~vx (if ~v? (aget ~nv 0) (if ~nv ~v (nth ~v 0 ~default)))
             ~vy (if ~v? (aget ~nv 1) (if ~nv ~v (nth ~v 1 ~default)))
             ~vz (if ~v? (aget ~nv 2) (if ~nv ~v (nth ~v 2 ~default)))]
         ~@(postwalk-replace
            {'x `(aget ~a 0) 'y `(aget ~a 1) 'z `(aget ~a 2) 'vx vx 'vy vy 'vz vz}
            body))))

  (defmacro rewrite-v3-nv-no-let
    [src v default & body]
    (let [a (gensym), b (gensym)]
      `(let [~a ~src]
         (if (instance? ~'Vec3 ~v)
           (let [~b (.-buf ~v)]
             ~@(postwalk-replace
                {'x `(aget ~a 0) 'y `(aget ~a 1) 'z `(aget ~a 2)
                 'vx `(aget ~b 0) 'vy `(aget ~b 1) 'vz `(aget ~b 2)}
                body))
           (if (number? ~v)
             (do ~@(postwalk-replace
                    {'x `(aget ~a 0) 'y `(aget ~a 1) 'z `(aget ~a 2) 'vx v 'vy v 'vz v} body))
             (do ~@(postwalk-replace
                    {'x `(aget ~a 0) 'y `(aget ~a 1) 'z `(aget ~a 2)
                     'vx `(nth ~v 0 ~default) 'vy `(nth ~v 1 ~default) 'vz `(nth ~v 2 ~default)}
                    body)))))))

  (defmacro rewrite-v3-nv-nv
    [src v v2 d1 d2 & body]
    (let [[a b c x y z bx by bz cx cy cz v1? v2? n1? n2?] (repeatedly 16 gensym)]
      `(let [~v1? (instance? ~'Vec3 ~v)
             ~v2? (instance? ~'Vec3 ~v2)
             ~n1? (if-not ~v1? (number? ~v))
             ~n2? (if-not ~v2? (number? ~v2))
             ~a ~src, ~b (if ~v1? (.-buf ~v)), ~c (if ~v2? (.-buf ~v2))
             ~x (aget ~a 0), ~y (aget ~a 1), ~z (aget ~a 2)
             ~bx (if ~v1? (aget ~b 0) (if ~n1? ~v (nth ~v 0 ~d1)))
             ~by (if ~v1? (aget ~b 1) (if ~n1? ~v (nth ~v 1 ~d1)))
             ~bz (if ~v1? (aget ~b 2) (if ~n1? ~v (nth ~v 2 ~d1)))
             ~cx (if ~v2? (aget ~c 0) (if ~n2? ~v2 (nth ~v2 0 ~d2)))
             ~cy (if ~v2? (aget ~c 1) (if ~n2? ~v2 (nth ~v2 1 ~d2)))
             ~cz (if ~v2? (aget ~c 2) (if ~n2? ~v2 (nth ~v2 2 ~d2)))]
         ~@(postwalk-replace
            {'x x 'y y 'z z 'bx bx 'by by 'bz bz 'cx cx 'cy cy 'cz cz} body))))

  (defmacro rewrite-v3-nv-nv-no-let
    [src v v2 d1 d2 & body]
    (let [[a b c x y z bx by bz cx cy cz v1? v2? n1? n2?] (repeatedly 16 gensym)]
      `(let [~v1? (instance? ~'Vec3 ~v)
             ~v2? (instance? ~'Vec3 ~v2)
             ~n1? (if-not ~v1? (number? ~v))
             ~n2? (if-not ~v2? (number? ~v2))
             ~a ~src, ~b (if ~v1? (.-buf ~v)), ~c (if ~v2? (.-buf ~v2))]
         ~@(postwalk-replace
            {'x `(aget ~a 0) 'y `(aget ~a 1) 'z `(aget ~a 2)
             'bx `(if ~v1? (aget ~b 0) (if ~n1? ~v (nth ~v 0 ~d1)))
             'by `(if ~v1? (aget ~b 1) (if ~n1? ~v (nth ~v 1 ~d1)))
             'bz `(if ~v1? (aget ~b 2) (if ~n1? ~v (nth ~v 2 ~d1)))
             'cx `(if ~v2? (aget ~c 0) (if ~n2? ~v2 (nth ~v2 0 ~d2)))
             'cy `(if ~v2? (aget ~c 1) (if ~n2? ~v2 (nth ~v2 1 ~d2)))
             'cz `(if ~v2? (aget ~c 2) (if ~n2? ~v2 (nth ~v2 2 ~d2)))}
            body))))

  (defmacro v3-op0
    [op src meta]
    `(let [dest# (js/Float32Array. 3)]
       (rewrite-v3-no-let
        ~src
        (aset dest# 0 (~op ~'x))
        (aset dest# 1 (~op ~'y))
        (aset dest# 2 (~op ~'z)))
       (new ~'Vec3 dest# nil ~meta)))

  (defmacro v3-op1-xyz
    ([op src vs meta]
       `(v3-op1-xyz ~op ~src (nth ~vs 0 0.0) (nth ~vs 1 0.0) (nth ~vs 2 0.0) ~meta))
    ([op src x y z meta]
       `(let [src# ~src
              dest# (js/Float32Array. 3)]
          (v3-op1-xyz ~op dest# src# ~x ~y ~z ~meta)))
    ([op dest src x y z meta]
       `(do
          (aset ~dest 0 (~op (aget ~src 0) ~x))
          (aset ~dest 1 (~op (aget ~src 1) ~y))
          (aset ~dest 2 (~op (aget ~src 2) ~z))
          (new ~'Vec3 ~dest nil ~meta))))

  (defmacro v3-op1
    [op src v meta]
    `(let [dest# (js/Float32Array. 3)]
       (rewrite-v3-nv-no-let
        ~src ~v 0.0
        (aset dest# 0 (~op ~'x ~'vx))
        (aset dest# 1 (~op ~'y ~'vy))
        (aset dest# 2 (~op ~'z ~'vz)))
       (new ~'Vec3 dest# nil ~meta)))

  (defmacro v3-op2
    [op op2 src v v2 d1 d2 meta]
    `(let [dest# (js/Float32Array. 3)]
       (rewrite-v3-nv-nv
        ~src ~v ~v2 ~d1 ~d2
        (aset dest# 0 (~op2 (~op ~'x ~'bx) ~'cx))
        (aset dest# 1 (~op2 (~op ~'y ~'by) ~'cy))
        (aset dest# 2 (~op2 (~op ~'z ~'bz) ~'cz)))
       (new ~'Vec3 dest# nil ~meta)))

  (defmacro v3-op2-no-let
    [op op2 src v v2 d1 d2 meta]
    `(let [dest# (js/Float32Array. 3)]
       (rewrite-v3-nv-nv-no-let
        ~src ~v ~v2 ~d1 ~d2
        (aset dest# 0 (~op2 (~op ~'x ~'bx) ~'cx))
        (aset dest# 1 (~op2 (~op ~'y ~'by) ~'cy))
        (aset dest# 2 (~op2 (~op ~'z ~'bz) ~'cz)))
       (new ~'Vec3 dest# nil ~meta)))
#+END_SRC

** Complete namespace definitions

#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/tvec.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.core.tvec
    ,#+cljs
    (:require-macros
     [thi.ng.geom.core.vector.macros :as vm :refer [defswizzle]]
     [thi.ng.macromath.core :as mm])
    (:require
     [thi.ng.geom.core :as g]
     [thi.ng.geom.core.vector :as v]
     [thi.ng.common.math.core :as m :refer [TWO_PI *eps*]]
     [thi.ng.common.error :as err]))

  (declare swizzle-assoc swizzle2-fns swizzle3-fns)

  <<vec3>>

  ,#+cljs (defswizzle x)
  ,#+cljs (defswizzle xx)
  ,#+cljs (defswizzle xxx)
  ,#+cljs (defswizzle xxy)
  ,#+cljs (defswizzle xxz)
  ,#+cljs (defswizzle xy)
  ,#+cljs (defswizzle xyx)
  ,#+cljs (defswizzle xyy)
  ,#+cljs (defswizzle xyz)
  ,#+cljs (defswizzle xz)
  ,#+cljs (defswizzle xzx)
  ,#+cljs (defswizzle xzy)
  ,#+cljs (defswizzle xzz)
  ,#+cljs (defswizzle y)
  ,#+cljs (defswizzle yx)
  ,#+cljs (defswizzle yxx)
  ,#+cljs (defswizzle yxy)
  ,#+cljs (defswizzle yxz)
  ,#+cljs (defswizzle yy)
  ,#+cljs (defswizzle yyx)
  ,#+cljs (defswizzle yyy)
  ,#+cljs (defswizzle yyz)
  ,#+cljs (defswizzle yz)
  ,#+cljs (defswizzle yzx)
  ,#+cljs (defswizzle yzy)
  ,#+cljs (defswizzle yzz)
  ,#+cljs (defswizzle z)
  ,#+cljs (defswizzle zx)
  ,#+cljs (defswizzle zxx)
  ,#+cljs (defswizzle zxy)
  ,#+cljs (defswizzle zxz)
  ,#+cljs (defswizzle zy)
  ,#+cljs (defswizzle zyx)
  ,#+cljs (defswizzle zyy)
  ,#+cljs (defswizzle zyz)
  ,#+cljs (defswizzle zz)
  ,#+cljs (defswizzle zzx)
  ,#+cljs (defswizzle zzy)
  ,#+cljs (defswizzle zzz)

  ,#+cljs
  (def swizzle2-fns
    {:x x :xx xx :xy xy :y y :yx yx :yy yy})

  ,#+cljs
  (def swizzle3-fns
    {:x x, :xx xx, :xxx xxx, :xxy xxy, :xxz xxz, :xy xy, :xyx xyx,
     :xyy xyy, :xyz xyz, :xz xz, :xzx xzx, :xzy xzy, :xzz xzz,
     :y y, :yx yx, :yxx yxx, :yxy yxy, :yxz yxz, :yy yy, :yyx yyx,
     :yyy yyy, :yyz yyz, :yz yz, :yzx yzx, :yzy yzy, :yzz yzz,
     :z z, :zx zx, :zxx zxx, :zxy zxy, :zxz zxz, :zy zy, :zyx zyx,
     :zyy zyy, :zyz zyz, :zz zz, :zzx zzx, :zzy zzy, :zzz zzz})

  <<ctors>>
#+END_SRC

#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/vector/macros.clj :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.core.vector.macros
    (:require
     [clojure.walk :refer :all]
     [thi.ng.common.data.core :as d]
     [thi.ng.common.error :as err]))

  <<swizzle-macros>>

  <<v3-macros>>
#+END_SRC
