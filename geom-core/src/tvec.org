#+SETUPFILE: ../../src/setup.org

* Contents                                                         :toc_3_gh:
 - [[#thinggeomtvec][thi.ng.geom.tvec]]
     - [[#pmathops][PMathOps]]
     - [[#end-implementation][End implementation]]
     - [[#swizzling][Swizzling]]
     - [[#constructors][Constructors]]
     - [[#macros][Macros]]
     - [[#complete-namespace-definitions][Complete namespace definitions]]

* thi.ng.geom.tvec

#+BEGIN_SRC clojure :noweb-ref vec3
  (declare swizzle swizzle-assoc)

  (deftype Vec3
      [buf ^:mutable __hash __meta]

    IMeta
    (-meta [_] __meta)
    IWithMeta
    (-with-meta [_ m] (Vec3. (js/Float32Array. buf) __hash m))

    ICloneable
    (-clone
      [_] (Vec3. (js/Float32Array. buf) __hash __meta))

    ILookup
    (-lookup
      [_ k] (swizzle buf k nil))
    (-lookup
      [_ k nf] (swizzle buf k nf))

    IFn
    (-invoke
      [_ k] (swizzle buf k nil))
    (-invoke
      [_ k nf] (swizzle buf k nf))

    ICounted
    (-count
      [_] 3)

    IAssociative
    (-contains-key?
      [_ k] (or (and (number? k) (>= k 0) (<= k 2))
                (= :x k) (= :y k) (= :z k)))
    (-assoc
      [_ k v] (swizzle-assoc _ k v))

    IVector
    (-assoc-n
      [_ n v]
      (let [b (js/Float32Array. buf)]
        (aset b n v)
        (Vec3. b nil __meta)))

    ISequential
    ISeq
    (-first
      [_] (aget buf 0))
    (-rest
      [_] (cons (aget buf 1) (cons (aget buf 2) nil)))

    INext
    (-next
      [_] (cons (aget buf 1) (cons (aget buf 2) nil)))

    ISeqable
    (-seq
      [_] _)

    IReversible
    (-rseq
      [_]
      (let [b (js/Float32Array. 3)]
        (aset b 0 (aget buf 2))
        (aset b 1 (aget buf 1))
        (aset b 2 (aget buf 0))
        (Vec3. b nil __meta)))

    IIndexed
    (-nth
      [_ n] (aget buf n))
    (-nth
      [_ n nf] (if (and (>= n 0) (<= n 2)) (aget buf n) nf))

    ICollection
    (-conj
      [_ x] [(aget buf 0) (aget buf 1) (aget buf 2) x])

    IStack
    (-peek
      [_] (aget buf 2))
    (-pop
      [_] [(aget buf 0) (aget buf 1)]) ;; TODO Vec2

    IComparable
    (-compare
      [_ x]
      (if (instance? Vec3 x)
        (let [b' (.-buf ^Vec3 x)
              c (compare (aget buf 0) (aget b' 0))]
          (if (== 0 c)
            (let [c (compare (aget buf 1) (aget b' 1))]
              (if (== 0 c)
                (compare  (aget buf 2) (aget b' 2))
                c))
            c))
        (let [c (count x)]
          (if (== 3 c) (compare x _) (- 3 c)))))

    IHash
    (-hash
      [_]
      (or __hash
          (set! (.-__hash _)
                (mix-collection-hash
                 (-> 31 (+ (hash (aget buf 0)))
                     (bit-or 0)
                     (imul 31) (+ (hash (aget buf 1)))
                     (bit-or 0)
                     (imul 31) (+ (hash (aget buf 2)))
                     (bit-or 0))
                 3))))

    IEquiv
    (-equiv
      [_ o]
      (if (instance? Vec3 o)
        (let [b' (.-buf ^Vec3 o)]
          (and (== (aget buf 0) (aget b' 0)) (== (aget buf 1) (aget b' 1)) (== (aget buf 2) (aget b' 2))))
        (and (sequential? o) (== 3 (count o))
             (= (aget buf 0) (first o)) (= (aget buf 1) (nth o 1)) (= (aget buf 2) (nth o 2)))))

    IReduce
    (-reduce
      [coll f]
      (let [acc (f (aget buf 0) (aget buf 1))]
        (if (reduced? acc)
          @acc
          (let [acc (f acc (aget buf 2))]
            (if (reduced? acc)
              @acc
              acc)))))
    (-reduce
      [coll f start]
      (let [acc (f start (aget buf 0))]
        (if (reduced? acc)
          @acc
          (let [acc (f acc (aget buf 1))]
            (if (reduced? acc)
              @acc
              (let [acc (f acc (aget buf 2))]
                (if (reduced? acc)
                  @acc
                  acc)))))))

    Object
    (toString
      [_] (str "[" (aget buf 0) " " (aget buf 1) " " (aget buf 2) "]"))

    g/PBuffered
    (get-buffer [_] buf)
    (copy-to-buffer [_ dest idx] (.set dest buf idx))
#+END_SRC

** PMathOps
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PMathOps
  (+ [_] _)
  (+ [_ v]       (vm/v3-op1-dispatch + buf v __meta))
  (+ [_ v1 v2]   (vm/v3-op2-dispatch + + buf v1 v2 __meta))
  (+ [_ x y z]   (vm/v3-op1-xyz + buf x y z __meta))
  (- [_]         (vm/v3-op0 - buf __meta))
  (- [_ v]       (vm/v3-op1-dispatch - buf v __meta))
  (- [_ v1 v2]   (vm/v3-op2-dispatch - - buf v1 v2 __meta))
  (- [_ x y z]   (vm/v3-op1-xyz - buf x y z __meta))
  (* [_] _)
  (* [_ v]       (vm/v3-op1-dispatch * buf v __meta))
  (* [_ v1 v2]   (vm/v3-op2-dispatch * * buf v1 v2 __meta))
  (* [_ x y z]   (vm/v3-op1-xyz * buf x y z __meta))
  (div [_]       (vm/v3-op0 / buf __meta))
  (div [_ v]     (vm/v3-op1-dispatch / buf v __meta))
  (div [_ v1 v2] (vm/v3-op2-dispatch / / buf v1 v2 __meta))
  (div [_ x y z] (vm/v3-op1-xyz / buf x y z __meta))
#+END_SRC

** End implementation

#+BEGIN_SRC clojure :noweb-ref vec3
  )
#+END_SRC

** Swizzling

#+BEGIN_SRC clojure :noweb-ref vec3-swizzle
  (defn- swizzle
    [buf k default meta]
    (if (number? k)
      (case (int k)
        0 (aget buf 0)
        1 (aget buf 1)
        2 (aget buf 2)
        (or default (err/key-error! k)))
      (case k
        :x (aget buf 0)
        :y (aget buf 1)
        :z (aget buf 2)
        (let [n (name k) c (count n)]
          (case c
            2 (with-meta
                [(vm/lookup3 buf (first n) default)  ;; TODO vec2
                 (vm/lookup3 buf (nth n 1) default)]
                meta)
            3 (let [x (vm/lookup3 buf (first n) default)
                    y (vm/lookup3 buf (nth n 1) default)
                    z (vm/lookup3 buf (nth n 2) default)
                    b' (js/Float32Array. 3)]
                (aset b' 0 x)
                (aset b' 1 y)
                (aset b' 2 z)
                (Vec3. b' nil meta))
            (or default (err/key-error! k)))))))
#+END_SRC

** Constructors

#+BEGIN_SRC clojure :noweb-ref ctors
  (defn vec3
    [x y z]
    (let [b (js/Float32Array. 3)]
      (aset b 0 x)
      (aset b 1 y)
      (aset b 2 z)
      (Vec3. b nil nil)))
#+END_SRC

** Macros

#+BEGIN_SRC clojure :noweb-ref v3-macros
  (defmacro lookup3
    [src k nf]
    `(case ~k
       \x (aget ~src 0)
       \y (aget ~src 1)
       \z (aget ~src 2)
       (or ~nf (err/key-error! ~k))))

  (defmacro v3-op0
    [op src meta]
    `(let [src# ~src
           dest# (js/Float32Array. 3)]
       (aset dest# 0 (~op (aget src# 0)))
       (aset dest# 1 (~op (aget src# 1)))
       (aset dest# 2 (~op (aget src# 2)))
       (new ~'Vec3 dest# nil ~meta)))

  (defmacro v3-op1-xyz
    ([op src vs meta]
       `(v3-op1-xyz ~op ~src (nth ~vs 0 0.0) (nth ~vs 1 0.0) (nth ~vs 2 0.0) ~meta))
    ([op src x y z meta]
       `(let [src# ~src
              dest# (js/Float32Array. 3)]
          (aset dest# 0 (~op (aget src# 0) ~x))
          (aset dest# 1 (~op (aget src# 1) ~y))
          (aset dest# 2 (~op (aget src# 2) ~z))
          (new ~'Vec3 dest# nil ~meta))))

  (defmacro v3-op1-v
    [op a b meta]
    `(let [src-a# ~a
           src-b# ~b
           dest# (js/Float32Array. 3)]
       (aset dest# 0 (~op (aget src-a# 0) (aget src-b# 0)))
       (aset dest# 1 (~op (aget src-a# 1) (aget src-b# 1)))
       (aset dest# 2 (~op (aget src-a# 2) (aget src-b# 2)))
       (new ~'Vec3 dest# nil ~meta)))

  (defmacro v3-op2-xyz-v
    ([op op2 src-a vs src-c meta]
       `(v3-op2-xyz-v ~op ~op2 ~src-a (nth ~vs 0 0.0) (nth ~vs 1 0.0) (nth ~vs 2 0.0) ~src-c ~meta))
    ([op op2 src-a bx by bz src-c meta]
       `(let [src-a# ~src-a
              src-c# ~src-c
              dest# (js/Float32Array. 3)]
          (aset dest# 0 (~op2 (~op (aget src-a# 0) ~bx) (aget src-c# 0)))
          (aset dest# 1 (~op2 (~op (aget src-a# 1) ~by) (aget src-c# 1)))
          (aset dest# 2 (~op2 (~op (aget src-a# 2) ~bz) (aget src-c# 2)))
          (new ~'Vec3 dest# nil ~meta))))

  (defmacro v3-op2-v-xyz
    ([op op2 src-a src-b vs meta]
       `(v3-op2-v-xyz ~op ~op2 ~src-a ~src-b (nth ~vs 0 0.0) (nth ~vs 1 0.0) (nth ~vs 2 0.0) ~meta))
    ([op op2 src-a src-b cx cy cz meta]
       `(let [src-a# ~src-a
              src-b# ~src-b
              dest# (js/Float32Array. 3)]
          (aset dest# 0 (~op2 (~op (aget src-a# 0) (aget src-b# 0)) ~cx))
          (aset dest# 1 (~op2 (~op (aget src-a# 1) (aget src-b# 1)) ~cy))
          (aset dest# 2 (~op2 (~op (aget src-a# 2) (aget src-b# 2)) ~cz))
          (new ~'Vec3 dest# nil ~meta))))

  (defmacro v3-op2-xyz-xyz
    ([op op2 src-a vb vc meta]
       `(v3-op2-xyz-xyz
         ~op ~op2 ~src-a
         (nth ~vb 0 0.0) (nth ~vb 1 0.0) (nth ~vb 2 0.0)
         (nth ~vc 0 0.0) (nth ~vc 1 0.0) (nth ~vc 2 0.0) ~meta))
    ([op op2 src-a bx by bz cx cy cz meta]
       `(let [src-a# ~src-a
              dest# (js/Float32Array. 3)]
          (aset dest# 0 (~op2 (~op (aget src-a# 0) ~bx) ~cx))
          (aset dest# 1 (~op2 (~op (aget src-a# 1) ~by) ~cy))
          (aset dest# 2 (~op2 (~op (aget src-a# 2) ~bz) ~cz))
          (new ~'Vec3 dest# nil ~meta))))

  (defmacro v3-op2-vs-xyz
    [op op2 src-a vb cx cy cz meta]
    `(v3-op2-xyz-xyz
      ~op ~op2 ~src-a (nth ~vb 0 0.0) (nth ~vb 1 0.0) (nth ~vb 2 0.0) ~cx ~cy ~cz ~meta))

  (defmacro v3-op2-xyz-vs
    [op op2 src-a bx by bz vc meta]
    `(v3-op2-xyz-xyz
      ~op ~op2 ~src-a ~bx ~by ~bz (nth ~vc 0 0.0) (nth ~vc 1 0.0) (nth ~vc 2 0.0) ~meta))

  (defmacro v3-op2-v-v
    [op op2 src-a src-b src-c meta]
    `(let [src-a# ~src-a
           src-b# ~src-b
           src-c# ~src-c
           dest# (js/Float32Array. 3)]
       (aset dest# 0 (~op2 (~op (aget src-a# 0) (aget src-b# 0)) (aget src-c# 0)))
       (aset dest# 1 (~op2 (~op (aget src-a# 1) (aget src-b# 1)) (aget src-c# 1)))
       (aset dest# 2 (~op2 (~op (aget src-a# 2) (aget src-b# 2)) (aget src-c# 2)))
       (new ~'Vec3 dest# nil ~meta)))

  (defmacro v3-op1-dispatch
    [op src v meta]
    `(if (instance? ~'Vec3 ~v)
       (v3-op1-v ~op ~src (.-buf ~v) ~meta)
       (if (number? ~v)
         (v3-op1-xyz ~op ~src ~v ~v ~v ~meta)
         (v3-op1-xyz ~op ~src ~v ~meta))))

  (defmacro v3-op2-dispatch
    [op op2 src v1 v2 meta]
    `(if (instance? ~'Vec3 ~v1)
       (if (instance? ~'Vec3 ~v2)
         (v3-op2-v-v ~op ~op2 ~src (.-buf ~v1) (.-buf ~v2) meta)         ;; V V
         (if (number? ~v2)
           (v3-op2-v-xyz ~op ~op2 ~src (.-buf ~v1) ~v2 ~v2 ~v2 meta)     ;; V N
           (v3-op2-v-xyz ~op ~op2 ~src (.-buf ~v1) ~v2 meta)))           ;; V S
       (if (number? ~v1)
         (if (instance? ~'Vec3 ~v2)
           (v3-op2-xyz-v ~op ~op2 ~src ~v1 ~v1 ~v1 (.-buf ~v2) meta)     ;; N V
           (if (number? ~v2)
             (v3-op2-xyz-xyz ~op ~op2 ~src ~v1 ~v1 ~v1 ~v2 ~v2 ~v2 meta) ;; N N
             (v3-op2-xyz-vs ~op ~op2 ~src ~v1 ~v1 ~v1 ~v2 meta)))        ;; N S
         (if (instance? ~'Vec3 ~v2)
           (v3-op2-xyz-v ~op ~op2 ~src ~v1 (.-buf ~v2) meta)             ;; S V
           (if (number? ~v2)
             (v3-op2-vs-xyz ~op ~op2 ~src ~v1 ~v2 ~v2 ~v2 meta)          ;; S N
             (v3-op2-xyz-xyz ~op ~op2 ~src ~v1 ~v2 meta))))))            ;; S S
#+END_SRC

** Complete namespace definitions

#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/tvec.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.core.tvec
    ,#+cljs
    (:require-macros
     [thi.ng.geom.core.vector.macros :as vm])
    (:require
     [thi.ng.geom.core :as g]
     [thi.ng.common.math.core :as mm]
     [thi.ng.common.error :as err]))

  <<vec3>>

  <<vec3-swizzle>>

  <<ctors>>

  ,#+cljs
  (defn ^:export tvec-foo
    []
    (let [a (vec3 1 2 3)
          b (vec3 10 20 30)]
      (enable-console-print!)
      (prn :a a :b b)
      (prn "a+10" (g/+ a 10))
      (prn "a+b" (g/+ a b))
      (prn "a+b" (g/+ a [100 200 300]))
      (prn "apply a+b" (apply g/+ a b))
      (prn ":zxy a" (:zxy a))))
#+END_SRC

#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/vector/macros.clj :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.core.vector.macros
    (:require
     [thi.ng.common.error :as err]))

  <<v3-macros>>
#+END_SRC
