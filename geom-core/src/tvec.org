#+SETUPFILE: ../../src/setup.org

* Contents                                                         :toc_3_gh:
 - [[#thinggeomtvec][thi.ng.geom.tvec]]
     - [[#pmathops][PMathOps]]
         - [[#pdotproduct][PDotProduct]]
         - [[#pclear][PClear]]
         - [[#pcrossproduct][PCrossProduct]]
         - [[#plimit][PLimit]]
         - [[#pminmax][PMinMax]]
         - [[#pdeltaequals][PDeltaEquals]]
         - [[#pmagnitude][PMagnitude]]
         - [[#pnormalize][PNormalize]]
         - [[#pdistance][PDistance]]
         - [[#preflect][PReflect]]
         - [[#pinvert][PInvert]]
         - [[#pinterpolate][PInterpolate]]
         - [[#pheading][PHeading]]
         - [[#ppolar][PPolar]]
     - [[#end-implementation][End implementation]]
     - [[#swizzling][Swizzling]]
     - [[#constructors][Constructors]]
     - [[#macros][Macros]]
     - [[#complete-namespace-definitions][Complete namespace definitions]]
     - [[#js-bench][JS bench]]

* thi.ng.geom.tvec

#+BEGIN_SRC clojure :noweb-ref vec3
  ,#+cljs
  (declare swizzle swizzle-assoc)

  ,#+cljs
  (deftype Vec3
      [buf ^:mutable _hash _meta]

    IMeta
    (-meta [_] _meta)
    IWithMeta
    (-with-meta [_ m] (Vec3. (js/Float32Array. buf) _hash m))

    ICloneable
    (-clone
      [_] (Vec3. (js/Float32Array. buf) _hash _meta))

    ILookup
    (-lookup
      [_ k] (swizzle buf k nil))
    (-lookup
      [_ k nf] (swizzle buf k nf))

    IFn
    (-invoke
      [_ k] (swizzle buf k nil))
    (-invoke
      [_ k nf] (swizzle buf k nf))

    ICounted
    (-count
      [_] 3)

    IAssociative
    (-contains-key?
      [_ k] (or (and (number? k) (>= k 0) (<= k 2))
                (= :x k) (= :y k) (= :z k)))
    (-assoc
      [_ k v] (swizzle-assoc _ k v))

    IVector
    (-assoc-n
      [_ n v]
      (let [b (js/Float32Array. buf)]
        (aset b n v)
        (Vec3. b nil _meta)))

    ISequential
    ISeq
    (-first
      [_] (aget buf 0))
    (-rest
      [_] (cons (aget buf 1) (cons (aget buf 2) nil)))

    INext
    (-next
      [_] (cons (aget buf 1) (cons (aget buf 2) nil)))

    ISeqable
    (-seq
      [_] _)

    IReversible
    (-rseq
      [_]
      (let [b (js/Float32Array. 3)]
        (aset b 0 (aget buf 2))
        (aset b 1 (aget buf 1))
        (aset b 2 (aget buf 0))
        (Vec3. b nil _meta)))

    IIndexed
    (-nth
      [_ n] (aget buf n))
    (-nth
      [_ n nf] (if (and (>= n 0) (<= n 2)) (aget buf n) nf))

    ICollection
    (-conj
      [_ x] [(aget buf 0) (aget buf 1) (aget buf 2) x])

    IStack
    (-peek
      [_] (aget buf 2))
    (-pop
      [_] [(aget buf 0) (aget buf 1)]) ;; TODO Vec2

    IComparable
    (-compare
      [_ x]
      (if (instance? Vec3 x)
        (let [b' (.-buf ^Vec3 x)
              c (compare (aget buf 0) (aget b' 0))]
          (if (== 0 c)
            (let [c (compare (aget buf 1) (aget b' 1))]
              (if (== 0 c)
                (compare  (aget buf 2) (aget b' 2))
                c))
            c))
        (let [c (count x)]
          (if (== 3 c) (compare x _) (- 3 c)))))

    IHash
    (-hash
      [_]
      (or _hash
          (set! (.-__hash _)
                (mix-collection-hash
                 (-> 31 (+ (hash (aget buf 0)))
                     (bit-or 0)
                     (imul 31) (+ (hash (aget buf 1)))
                     (bit-or 0)
                     (imul 31) (+ (hash (aget buf 2)))
                     (bit-or 0))
                 3))))

    IEquiv
    (-equiv
      [_ o]
      (if (instance? Vec3 o)
        (let [b' (.-buf ^Vec3 o)]
          (and (== (aget buf 0) (aget b' 0)) (== (aget buf 1) (aget b' 1)) (== (aget buf 2) (aget b' 2))))
        (and (sequential? o) (== 3 (count o))
             (= (aget buf 0) (first o)) (= (aget buf 1) (nth o 1)) (= (aget buf 2) (nth o 2)))))

    IReduce
    (-reduce
      [coll f]
      (let [acc (f (aget buf 0) (aget buf 1))]
        (if (reduced? acc)
          @acc
          (let [acc (f acc (aget buf 2))]
            (if (reduced? acc)
              @acc
              acc)))))
    (-reduce
      [coll f start]
      (let [acc (f start (aget buf 0))]
        (if (reduced? acc)
          @acc
          (let [acc (f acc (aget buf 1))]
            (if (reduced? acc)
              @acc
              (let [acc (f acc (aget buf 2))]
                (if (reduced? acc)
                  @acc
                  acc)))))))

    Object
    (toString
      [_] (str "[" (aget buf 0) " " (aget buf 1) " " (aget buf 2) "]"))

    g/PBuffered
    (get-buffer [_] buf)
    (copy-to-buffer [_ dest idx] (.set dest buf idx))
#+END_SRC

** PMathOps
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PMathOps
  (+ [_] _)
  (+ [_ v]       (vm/v3-op1 + buf v _meta))
  (+ [_ v1 v2]   (vm/v3-op2-dispatch + + buf v1 v2 _meta))
  (+ [_ x y z]   (vm/v3-op1-xyz + buf x y z _meta))
  (- [_]         (vm/v3-op0 - buf _meta))
  (- [_ v]       (vm/v3-op1 - buf v _meta))
  (- [_ v1 v2]   (vm/v3-op2-dispatch - - buf v1 v2 _meta))
  (- [_ x y z]   (vm/v3-op1-xyz - buf x y z _meta))
  (* [_] _)
  (* [_ v]       (vm/v3-op1 * buf v _meta))
  (* [_ v1 v2]   (vm/v3-op2-dispatch * * buf v1 v2 _meta))
  (* [_ x y z]   (vm/v3-op1-xyz * buf x y z _meta))
  (div [_]       (vm/v3-op0 / buf _meta))
  (div [_ v]     (vm/v3-op1 / buf v _meta))
  (div [_ v1 v2] (vm/v3-op2-dispatch / / buf v1 v2 _meta))
  (div [_ x y z] (vm/v3-op1-xyz / buf x y z _meta))
  (madd [_ a b]  (vm/v3-op2-dispatch * + buf a b _meta))
  (addm [_ a b]  (vm/v3-op2-dispatch + * buf a b _meta))
  (msub [_ a b]  (vm/v3-op2-dispatch * - buf a b _meta))
  (subm [_ a b]  (vm/v3-op2-dispatch - * buf a b _meta))
#+END_SRC
*** PDotProduct
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PDotProduct
  (dot
   [_ v] (vm/rewrite-v3-v-no-let buf v 0.0 (+ (+ (* x vx) (* y vy)) (* z vz))))
#+END_SRC
*** PClear
#+BEGIN_SRC clojure :noweb-ref vec3'
  g/PClear
  (clear* [_] V3)
#+END_SRC
*** PCrossProduct
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PCrossProduct
  (cross
   [_ v]
   (let [b (js/Float32Array. 3)]
     (vm/rewrite-v3-v buf v 0.0
       (aset b 0 (mm/msub y vz vy z))
       (aset b 1 (mm/msub z vx vz x))
       (aset b 2 (mm/msub x vy vx y)))
     (Vec3. b nil _meta)))
#+END_SRC
*** PLimit
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PLimit
  (limit
   [_ len]
   (if (> (g/mag-squared _) (* len len))
     (g/normalize _ len)
     _))
#+END_SRC
*** PMinMax
#+BEGIN_SRC clojure :noweb-ref vec3'
  g/PMinMax
  (min
   [_ v]
   (let [b (js/Float32Array. 3)]
     (vm/rewrite-v3-nv-no-let buf v 0.0
       (aset b 0 (min x vx))
       (aset b 1 (min y vy))
       (aset b 2 (min z vz)))
     (Vec3. b nil _meta)))
  (min
   [_ v v2]
   (let [b (js/Float32Array. 3)]
     (vm/rewrite-v3-nv-no-let buf v 0.0
       (aset b 0 (min x vx))
       (aset b 1 (min y vy))
       (aset b 2 (min z vz)))
     (vm/rewrite-v3-nv-no-let b v2 0.0
       (aset b 0 (min x vx))
       (aset b 1 (min y vy))
       (aset b 2 (min z vz)))
     (Vec3. b nil _meta)))
  (max
   [_ v]
   (let [b (js/Float32Array. 3)]
     (vm/rewrite-v3-nv-no-let buf v 0.0
       (aset b 0 (max x vx))
       (aset b 1 (max y vy))
       (aset b 2 (max z vz)))
     (Vec3. b nil _meta)))
  (max
   [_ v v2]
   (let [b (js/Float32Array. 3)]
     (vm/rewrite-v3-nv-no-let buf v 0.0
       (aset b 0 (max x vx))
       (aset b 1 (max y vy))
       (aset b 2 (max z vz)))
     (vm/rewrite-v3-nv-no-let b v2 0.0
       (aset b 0 (max x vx))
       (aset b 1 (max y vy))
       (aset b 2 (max z vz)))
     (Vec3. b nil _meta)))
#+END_SRC
*** PDeltaEquals
#+BEGIN_SRC clojure :noweb-ref vec3
  m/PDeltaEquals
  (delta=
   [_ v] (m/delta= _ v *eps*))
  (delta=
   [_ v eps]
   (if (and (sequential? v) (== 3 (count v)))
     (vm/rewrite-v3-v-no-let buf v 0.0
       (and
        (m/delta= x vx eps)
        (m/delta= y vy eps)
        (m/delta= z vz eps)))))
#+END_SRC
*** PMagnitude
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PMagnitude
  (mag
   [_] (vm/rewrite-v3 buf (Math/sqrt (mm/madd x x y y z z))))
  (mag-squared
   [_] (vm/rewrite-v3 buf (mm/madd x x y y z z)))
#+END_SRC
*** PNormalize
#+BEGIN_SRC clojure :noweb-ref vec3'
  g/PNormalize
  (normalize
   [_]
   (let [l (Math/sqrt (mm/madd x x y y z z))]
     (if (pos? l)
       (Vec3. (/ x l) (/ y l) (/ z l) nil _meta)
       _)))
  (normalize
   [_ len]
   (let [l (Math/sqrt (mm/madd x x y y z z))]
     (if (pos? l)
       (let [l (/ len l)]
         (Vec3. (* x l) (* y l) (* z l) nil _meta))
       _)))
  (normalized?
   [_] (m/delta= 1.0 (g/mag-squared _)))
#+END_SRC
*** PDistance
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PDistance
  (dist
   [_ v] (Math/sqrt (g/dist-squared _ v)))
  (dist-squared
   [_ v]
   (vm/rewrite-v3-v buf v 0.0
     (let [dx (- x vx)
           dy (- y vy)
           dz (- z vz)]
       (mm/madd dx dx dy dy dz dz))))
#+END_SRC
*** PReflect
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PReflect
  (reflect
   [_ v]
   (let [b (js/Float32Array. 3)]
     (vm/rewrite-v3-v buf v 0.0
       (let [d (* (+ (+ (* x vx) (* y vy)) (* z vz)) 2.0)]
         (aset b 0 (mm/msub vx d x))
         (aset b 1 (mm/msub vy d y))
         (aset b 2 (mm/msub vz d z))
         (Vec3. b nil _meta)))))
#+END_SRC
*** PInvert
#+BEGIN_SRC clojure :noweb-ref vec3'
  g/PInvert
  (invert
   [_] (g/- _))
#+END_SRC
*** PInterpolate
#+BEGIN_SRC clojure :noweb-ref vec3'
  g/PInterpolate
  (mix
   [_ a]
   (Vec3.
    (mm/mix x (first a) 0.5)
    (mm/mix y (nth a 1 0.0) 0.5)
    (mm/mix z (nth a 2 0.0) 0.5)
    nil _meta))
  (mix
   [_ a t]
   (Vec3.
    (mm/mix x (first a) t)
    (mm/mix y (nth a 1 0.0) t)
    (mm/mix z (nth a 2 0.0) t)
    nil _meta))
  (mix
   [_ a b c u v]
   (Vec3.
    (mm/mix x (first a) (first b) (first c) u v)
    (mm/mix y (nth a 1 0.0) (nth b 1 0.0) (nth c 1 0.0) u v)
    (mm/mix z (nth a 2 0.0) (nth b 2 0.0) (nth c 2 0.0) u v)
    nil _meta))
#+END_SRC
*** PHeading
#+BEGIN_SRC clojure :noweb-ref vec3
  g/PHeading
  (heading [_] (g/heading-xy _))
  (heading-xy
   [_]
   (let [t (Math/atan2 (aget buf 1) (aget buf 0))]
     (if (neg? t) (+ t TWO_PI) t)))
  (heading-xz
   [_]
   (let [t (Math/atan2 (aget buf 2) (aget buf 0))]
     (if (neg? t) (+ t TWO_PI) t)))
  (heading-yz
   [_]
   (let [t (Math/atan2 (aget buf 2) (aget buf 1))]
     (if (neg? t) (+ t TWO_PI) t)))
  (angle-between
   [_ a] (Math/acos (g/dot _ a)))
  (slope-xy [_] (/ (aget buf 1) (aget buf 0)))
  (slope-xz [_] (/ (aget buf 2) (aget buf 0)))
  (slope-yz [_] (/ (aget buf 2) (aget buf 1)))
#+END_SRC
*** PPolar

- http://mathworld.wolfram.com/SphericalCoordinates.html
- http://rbrundritt.wordpress.com/2008/10/14/conversion-between-spherical-and-cartesian-coordinates-systems/

#+BEGIN_SRC clojure :noweb-ref vec3'
  g/PPolar
  (as-polar
   [_]
    (let [r (g/mag _)
          theta (Math/asin (/ z r))
          phi (Math/atan2 y x)]
      (Vec3. r theta phi nil _meta)))
  (as-cartesian [_]
    (let [rcos (* x (Math/cos y))]
      (Vec3.
       (* rcos (Math/cos z))
       (* rcos (Math/sin z))
       (* x    (Math/sin y)) nil _meta)))
#+END_SRC

** End implementation

#+BEGIN_SRC clojure :noweb-ref vec3
  )
#+END_SRC

** Swizzling

#+BEGIN_SRC clojure :noweb-ref vec3-swizzle
  ,#+cljs
  (defn- swizzle
    [buf k default meta]
    (if (number? k)
      (case (int k)
        0 (aget buf 0)
        1 (aget buf 1)
        2 (aget buf 2)
        (or default (err/key-error! k)))
      (case k
        :x (aget buf 0)
        :y (aget buf 1)
        :z (aget buf 2)
        (let [n (name k) c (count n)]
          (case c
            2 (with-meta
                [(vm/lookup3 buf (first n) default)  ;; TODO vec2
                 (vm/lookup3 buf (nth n 1) default)]
                meta)
            3 (let [x (vm/lookup3 buf (first n) default)
                    y (vm/lookup3 buf (nth n 1) default)
                    z (vm/lookup3 buf (nth n 2) default)
                    b' (js/Float32Array. 3)]
                (aset b' 0 x)
                (aset b' 1 y)
                (aset b' 2 z)
                (Vec3. b' nil meta))
            (or default (err/key-error! k)))))))
#+END_SRC

** Constructors

#+BEGIN_SRC clojure :noweb-ref ctors
  ,#+cljs
  (defn vec3
    [x y z]
    (let [b (js/Float32Array. 3)]
      (aset b 0 x)
      (aset b 1 y)
      (aset b 2 z)
      (Vec3. b nil nil)))
#+END_SRC

** Macros

#+BEGIN_SRC clojure :noweb-ref v3-macros
  (defmacro lookup3
    [src k nf]
    `(case ~k
       \x (aget ~src 0)
       \y (aget ~src 1)
       \z (aget ~src 2)
       (or ~nf (err/key-error! ~k))))

  (defmacro rewrite-v3
    [src & body]
    (let [[a x y z] (repeatedly 4 gensym)]
      `(let [~a ~src, ~x (aget ~a 0), ~y (aget ~a 1), ~z (aget ~a 2)]
         ~@(postwalk-replace {'x x 'y y 'z z} body))))

  (defmacro rewrite-v3-no-let
    [src & body]
    (let [a (gensym)]
      `(let [~a ~src]
         ~@(postwalk-replace
            {'x `(aget ~a 0) 'y `(aget ~a 1) 'z `(aget ~a 2)}
            body))))

  (defmacro rewrite-v3-v-no-let
    [src v default & body]
    (let [a (gensym)
          b (gensym)]
      `(let [~a ~src]
         (if (instance? ~'Vec3 ~v)
           (let [~b (.-buf ~v)]
             ~@(postwalk-replace
                {'x `(aget ~a 0) 'y `(aget ~a 1) 'z `(aget ~a 2)
                 'vx `(aget ~b 0) 'vy `(aget ~b 1) 'vz `(aget ~b 2)}
                body))
           (do ~@(postwalk-replace
                  {'x `(aget ~a 0) 'y `(aget ~a 1) 'z `(aget ~a 2)
                   'vx `(nth ~v 0 ~default) 'vy `(nth ~v 1 ~default) 'vz `(nth ~v 2 ~default)}
                  body))))))

  (defmacro rewrite-v3-v
    [src v default & body]
    (let [[a b x y z vx vy vz] (repeatedly 8 gensym)]
      `(let [~a ~src, ~x (aget ~a 0), ~y (aget ~a 1), ~z (aget ~a 2)]
         (if (instance? ~'Vec3 ~v)
           (let [~b (.-buf ~v), ~vx (aget ~b 0), ~vy (aget ~b 1), ~vz (aget ~b 2)]
             ~@(postwalk-replace {'x x 'y y 'z z 'vx vx 'vy vy 'vz vz} body))
           (let [~vx (nth ~v 0 ~default), ~vy (nth ~v 1 ~default), ~vz (nth ~v 2 ~default)]
             ~@(postwalk-replace {'x x 'y y 'z z 'vx vx 'vy vy 'vz vz} body))))))

  (defmacro rewrite-v3-nv
    [src v default & body]
    (let [[a b x y z vx vy vz] (repeatedly 8 gensym)]
      `(let [~a ~src, ~x (aget ~a 0), ~y (aget ~a 1), ~z (aget ~a 2)]
         (if (instance? ~'Vec3 ~v)
           (let [~b (.-buf ~v), ~vx (aget ~b 0), ~vy (aget ~b 1), ~vz (aget ~b 2)]
             ~@(postwalk-replace {'x x 'y y 'z z 'vx vx 'vy vy 'vz vz} body))
           (if (number? ~v)
             (do ~@(postwalk-replace {'x x 'y y 'z z 'vx v 'vy v 'vz v} body))
             (let [~vx (nth ~v 0 ~default), ~vy (nth ~v 1 ~default), ~vz (nth ~v 2 ~default)]
               ~@(postwalk-replace {'x x 'y y 'z z 'vx vx 'vy vy 'vz vz} body)))))))

  (defmacro rewrite-v3-nv-no-let
    [src v default & body]
    (let [a (gensym), b (gensym)]
      `(let [~a ~src]
         (if (instance? ~'Vec3 ~v)
           (let [~b (.-buf ~v)]
             ~@(postwalk-replace
                {'x `(aget ~a 0) 'y `(aget ~a 1) 'z `(aget ~a 2)
                 'vx `(aget ~b 0) 'vy `(aget ~b 1) 'vz `(aget ~b 2)}
                body))
           (if (number? ~v)
             (do ~@(postwalk-replace
                    {'x `(aget ~a 0) 'y `(aget ~a 1) 'z `(aget ~a 2) 'vx v 'vy v 'vz v} body))
             (do ~@(postwalk-replace
                  {'x `(aget ~a 0) 'y `(aget ~a 1) 'z `(aget ~a 2)
                   'vx `(nth ~v 0 ~default) 'vy `(nth ~v 1 ~default) 'vz `(nth ~v 2 ~default)}
                  body)))))))

  (defmacro rewrite-v3-nv-nv
    [src v v2 d1 d2 & body]
    (let [[a b c x y z bx by bz cx cy cz] (repeatedly 12 gensym)]
      `(let [~a ~src, ~x (aget ~a 0), ~y (aget ~a 1), ~z (aget ~a 2)]
         (if (instance? ~'Vec3 ~v)
           (let [~b (.-buf ~v) ~bx (aget ~b 0), ~by (aget ~b 1), ~bz (aget ~b 2)]
             (if (instance? ~'Vec3 ~v2)
               (let [~c (.-buf ~v2), ~cx (aget ~c 0), ~cy (aget ~c 1), ~cz (aget ~c 2)]
                 ~@(postwalk-replace
                    {'x x 'y y 'z z 'bx bx 'by by 'bz bz 'cx cx 'cy cy 'cz cz} body))
               (if (number? ~v2)
                 (do ~@(postwalk-replace
                        {'x x 'y y 'z z 'bx bx 'by by 'bz bz 'cx v2 'cy v2 'cz v2} body))
                 (let [~cx (nth ~v2 0 ~d2), ~cy (nth ~v2 1 ~d2), ~cz (nth ~v2 2 ~d2)]
                   ~@(postwalk-replace
                      {'x x 'y y 'z z 'bx bx 'by by 'bz bz 'cx cx 'cy cy 'cz cz} body)))))
           (if (number? ~v)
             (if (instance? ~'Vec3 ~v2)
               (let [~c (.-buf ~v2) ~cx (aget ~c 0), ~cy (aget ~c 1), ~cz (aget ~c 2)]
                 ~@(postwalk-replace
                    {'x x 'y y 'z z 'bx v 'by v 'bz v 'cx cx 'cy cy 'cz cz} body))
               (if (number? ~v2)
                 (do ~@(postwalk-replace
                        {'x x 'y y 'z z 'bx v 'by v 'bz v 'cx v2 'cy v2 'cz v2} body))
                 (let [~cx (nth ~v2 0 ~d2), ~cy (nth ~v2 1 ~d2), ~cz (nth ~v2 2 ~d2)]
                   ~@(postwalk-replace
                      {'x x 'y y 'z z 'bx v 'by v 'bz v 'cx cx 'cy cy 'cz cz} body))))
             (let [~bx (nth ~v 0 ~d1), ~by (nth ~v 1 ~d1), ~bz (nth ~v 2 ~d1)]
               (if (instance? ~'Vec3 ~v2)
                 (let [~c (.-buf ~v2), ~cx (aget ~c 0), ~cy (aget ~c 1), ~cz (aget ~c 2)]
                   ~@(postwalk-replace
                      {'x x 'y y 'z z 'bx bx 'by by 'bz bz 'cx cx 'cy cy 'cz cz} body))
                 (if (number? ~v2)
                   (do ~@(postwalk-replace
                          {'x x 'y y 'z z 'bx bx 'by by 'bz bz 'cx v2 'cy v2 'cz v2} body))
                   (let [~cx (nth ~v2 0 ~d2), ~cy (nth ~v2 1 ~d2), ~cz (nth ~v2 2 ~d2)]
                     ~@(postwalk-replace
                        {'x x 'y y 'z z 'bx bx 'by by 'bz bz 'cx cx 'cy cy 'cz cz} body))))))))))

  (defmacro rewrite-v3-nv-nv-alt
    [src v v2 d1 d2 & body]
    (let [[a b c x y z bx by bz cx cy cz] (repeatedly 12 gensym)]
      `(let [v1?# (instance? Vec3 v)
             v2?# (instance? Vec3 v2)
             n1?# (if-not v1? (number? v))
             n2?# (if-not v2? (number? v2))
             ~a ~src, ~b (if v1?# (.-buf ~v)), ~c (if v2?# (.-buf ~v2))
             ~x (aget ~a 0), ~y (aget ~a 1), ~z (aget ~a 2)
             ~bx (if v1?# (aget ~b 0) (if n1?# ~v (nth ~v 0 ~d1)))
             ~by (if v1?# (aget ~b 1) (if n1?# ~v (nth ~v 1 ~d1)))
             ~bz (if v1?# (aget ~b 2) (if n1?# ~v (nth ~v 2 ~d1)))
             ~cx (if v2?# (aget ~c 0) (if n2?# ~v2 (nth ~v2 0 ~d2)))
             ~cy (if v2?# (aget ~c 1) (if n2?# ~v2 (nth ~v2 1 ~d2)))
             ~cz (if v2?# (aget ~c 2) (if n2?# ~v2 (nth ~v2 2 ~d2)))]
         ~@(postwalk-replace
            {'x x 'y y 'z z 'bx bx 'by by 'bz bz 'cx cx 'cy cy 'cz cz} body))))

  (defmacro v3-op0
    [op src meta]
    `(let [dest# (js/Float32Array. 3)]
       (rewrite-v3-no-let
        ~src
        (aset dest# 0 (~op ~'x))
        (aset dest# 1 (~op ~'y))
        (aset dest# 2 (~op ~'z)))
       (new ~'Vec3 dest# nil ~meta)))

  (defmacro v3-op1-xyz
    ([op src vs meta]
       `(v3-op1-xyz ~op ~src (nth ~vs 0 0.0) (nth ~vs 1 0.0) (nth ~vs 2 0.0) ~meta))
    ([op src x y z meta]
       `(let [src# ~src
              dest# (js/Float32Array. 3)]
          (v3-op1-xyz ~op dest# src# ~x ~y ~z ~meta)))
    ([op dest src x y z meta]
       `(do
          (aset ~dest 0 (~op (aget ~src 0) ~x))
          (aset ~dest 1 (~op (aget ~src 1) ~y))
          (aset ~dest 2 (~op (aget ~src 2) ~z))
          (new ~'Vec3 ~dest nil ~meta))))

  (defmacro v3-op1
    [op src v meta]
    `(let [dest# (js/Float32Array. 3)]
       (rewrite-v3-nv-no-let
        ~src ~v 0.0
        (aset dest# 0 (~op ~'x ~'vx))
        (aset dest# 1 (~op ~'y ~'vy))
        (aset dest# 2 (~op ~'z ~'vz)))
       (new ~'Vec3 dest# nil ~meta)))


  (defmacro v3-op2-xyz-v
    ([op op2 dest src vs src-c meta]
       `(v3-op2-xyz-v ~op ~op2 ~dest ~src (nth ~vs 0 0.0) (nth ~vs 1 0.0) (nth ~vs 2 0.0) ~src-c ~meta))
    ([op op2 dest src bx by bz src-c meta]
       `(let [c# ~src-c]
          (aset ~dest 0 (~op2 (~op (aget ~src 0) ~bx) (aget c# 0)))
          (aset ~dest 1 (~op2 (~op (aget ~src 1) ~by) (aget c# 1)))
          (aset ~dest 2 (~op2 (~op (aget ~src 2) ~bz) (aget c# 2)))
          (new ~'Vec3 ~dest nil ~meta))))

  (defmacro v3-op2-v-xyz
    ([op op2 dest src src-b vs meta]
       `(v3-op2-v-xyz ~op ~op2 ~dest ~src ~src-b (nth ~vs 0 0.0) (nth ~vs 1 0.0) (nth ~vs 2 0.0) ~meta))
    ([op op2 dest src src-b cx cy cz meta]
       `(let [b# ~src-b]
          (aset ~dest 0 (~op2 (~op (aget ~src 0) (aget b# 0)) ~cx))
          (aset ~dest 1 (~op2 (~op (aget ~src 1) (aget b# 1)) ~cy))
          (aset ~dest 2 (~op2 (~op (aget ~src 2) (aget b# 2)) ~cz))
          (new ~'Vec3 ~dest nil ~meta))))

  (defmacro v3-op2-xyz-xyz
    ([op op2 dest src vb vc meta]
       `(v3-op2-xyz-xyz
         ~op ~op2 ~dest ~src
         (nth ~vb 0 0.0) (nth ~vb 1 0.0) (nth ~vb 2 0.0)
         (nth ~vc 0 0.0) (nth ~vc 1 0.0) (nth ~vc 2 0.0) ~meta))
    ([op op2 dest src bx by bz cx cy cz meta]
       `(do
          (aset ~dest 0 (~op2 (~op (aget ~src 0) ~bx) ~cx))
          (aset ~dest 1 (~op2 (~op (aget ~src 1) ~by) ~cy))
          (aset ~dest 2 (~op2 (~op (aget ~src 2) ~bz) ~cz))
          (new ~'Vec3 ~dest nil ~meta))))

  (defmacro v3-op2-vs-xyz
    [op op2 dest src vb cx cy cz meta]
    `(v3-op2-xyz-xyz
      ~op ~op2 ~dest ~src (nth ~vb 0 0.0) (nth ~vb 1 0.0) (nth ~vb 2 0.0) ~cx ~cy ~cz ~meta))

  (defmacro v3-op2-xyz-vs
    [op op2 dest src bx by bz vc meta]
    `(v3-op2-xyz-xyz
      ~op ~op2 ~dest ~src ~bx ~by ~bz (nth ~vc 0 0.0) (nth ~vc 1 0.0) (nth ~vc 2 0.0) ~meta))

  (defmacro v3-op2-v-v
    [op op2 dest src src-b src-c meta]
    `(let [b# ~src-b
           c# ~src-c]
       (aset ~dest 0 (~op2 (~op (aget ~src 0) (aget b# 0)) (aget c# 0)))
       (aset ~dest 1 (~op2 (~op (aget ~src 1) (aget b# 1)) (aget c# 1)))
       (aset ~dest 2 (~op2 (~op (aget ~src 2) (aget b# 2)) (aget c# 2)))
       (new ~'Vec3 ~dest nil ~meta)))

  (defmacro v3-op2-dispatch
    [op op2 src v1 v2 meta]
    `(let [src# ~src
           dest# (js/Float32Array. 3)]
       (if (instance? ~'Vec3 ~v1)
         (if (instance? ~'Vec3 ~v2)
           (v3-op2-v-v ~op ~op2 dest# src# (.-buf ~v1) (.-buf ~v2) ~meta) ;; V V
           (if (number? ~v2)
             (v3-op2-v-xyz ~op ~op2 dest# src# (.-buf ~v1) ~v2 ~v2 ~v2 ~meta) ;; V N
             (v3-op2-v-xyz ~op ~op2 dest# src# (.-buf ~v1) ~v2 ~meta))) ;; V S
         (if (number? ~v1)
           (if (instance? ~'Vec3 ~v2)
             (v3-op2-xyz-v ~op ~op2 dest# src# ~v1 ~v1 ~v1 (.-buf ~v2) ~meta) ;; N V
             (if (number? ~v2)
               (v3-op2-xyz-xyz ~op ~op2 dest# src# ~v1 ~v1 ~v1 ~v2 ~v2 ~v2 ~meta) ;; N N
               (v3-op2-xyz-vs ~op ~op2 dest# src# ~v1 ~v1 ~v1 ~v2 ~meta))) ;; N S
           (if (instance? ~'Vec3 ~v2)
             (v3-op2-xyz-v ~op ~op2 dest# src# ~v1 (.-buf ~v2) ~meta) ;; S V
             (if (number? ~v2)
               (v3-op2-vs-xyz ~op ~op2 dest# src# ~v1 ~v2 ~v2 ~v2 ~meta) ;; S N
               (v3-op2-xyz-xyz ~op ~op2 dest# src# ~v1 ~v2 ~meta))))))) ;; S S
#+END_SRC

** Complete namespace definitions

#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/tvec.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.core.tvec
    ,#+cljs
    (:require-macros
     [thi.ng.geom.core.vector.macros :as vm]
     [thi.ng.macromath.core :as mm])
    (:require
     [thi.ng.geom.core :as g]
     [thi.ng.common.math.core :as m :refer [TWO_PI *eps*]]
     [thi.ng.common.error :as err]))

  <<vec3>>

  <<vec3-swizzle>>

  <<ctors>>

  ,#+cljs
  (defn ^:export tvec-foo
    []
    (let [a (vec3 1 2 3)
          b (vec3 10 20 30)]
      (enable-console-print!)
      (prn :a a :b b)
      (prn "a+10" (g/+ a 10))
      (prn "a+b" (g/+ a b))
      (prn "a+b" (g/+ a [100 200 300]))
      (prn "apply a+b" (apply g/+ a b))
      (prn ":zxy a" (:zxy a))))
#+END_SRC

#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core/vector/macros.clj :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.core.vector.macros
    (:require
     [clojure.walk :refer :all]
     [thi.ng.common.error :as err]))

  <<v3-macros>>
#+END_SRC

** JS bench

#+BEGIN_SRC js
  var g = thi.ng.geom.core;
  var v = g.tvec;
  var a = v.vec3(1,2,3);
  var b = v.vec3(3,-2,1);
  var avg = 0;
  var n = 50;
  for(var j = 0; j < n; j++) {
    var t0=new Date().getTime(); for(var i=0; i<100000; i++) { g.cross(a,b); }
    vat t = new Date().getTime()-t0;
    avg += t;
    console.log(t);
  }
  avg /= n;
#+END_SRC
