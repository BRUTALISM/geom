#+SEQ_TODO:       TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:           Write(w) Update(u) Fix(f) Check(c) noexport(n)
#+EXPORT_EXCLUDE_TAGS: noexport

* thi.ng.geom.circle
** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx :mkdirp yes :padline no
  (ns thi.ng.geom.circle
    (:refer-clojure :exclude [+ - * min max])
    (:refer-clojure :rename {+ c+, - c-, * c*})
    (:require
     [thi.ng.common.data.core :as d]
     [thi.ng.common.math.core :as m :refer [PI TWO_PI *eps*]]
     [thi.ng.geom.core :as g :refer [+ - * vec2 vec3 *resolution*]]
     [thi.ng.geom.mesh :as mesh]
     [thi.ng.geom.types :as types])
    #+clj
    (:import
     [thi.ng.geom.types Circle Line2 Polygon Rect Triangle2]))
#+END_SRC
** Constructor
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  (defn circle
    ([] (thi.ng.geom.types.Circle. (vec2) 1.0))
    ([r] (thi.ng.geom.types.Circle. (vec2) r))
    ([p r] (thi.ng.geom.types.Circle. (vec2 p) r))
    ([x y r] (thi.ng.geom.types.Circle. (vec2 x y) r)))
#+END_SRC
** Type specific functions
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  (defn intersect-circle
    [{p :p r1 :r} {q :p r2 :r}]
    (let [delta (- q p)
          d (g/mag delta)]
      (when (and (<= d (c+ r1 r2)) (>= d (m/abs (c- r1 r2))))
        (let [a (/ (c+ (c- (c* r1 r1) (c* r2 r2)) (c* d d)) (c* 2.0 d))
              invd (/ 1.0 d)
              p (g/madd delta (c* a invd) p)
              h (Math/sqrt (c- (c* r1 r1) (c* a a)))
              perp (* (g/normal delta) (c* h invd))]
          [(+ p perp) (- p perp)]))))
  
  (defn tangent-points
    [{p :p :as c} q]
    (let [m (g/mix p q)]
      (intersect-circle c (circle m (g/dist m p)))))
#+END_SRC
** Protocol implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  (extend-type thi.ng.geom.types.Circle
#+END_SRC
*** PGraph
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PGraph
  (vertices
   ([_] (g/vertices _ *resolution*))
   ([_ res]
      (map #(g/point-at _ %) (butlast (m/norm-range res)))))
  (edges
   ([_] (g/edges _ *resolution*))
   ([_ res]
      (let [verts (g/vertices _ res)]
        (g/edges* #(thi.ng.geom.types.Line2. (% 0) (% 1))
                  (concat verts [(first verts)])))))
#+END_SRC
*** PArea
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PArea
  (area [{r :r}] (c* PI (c* r r)))
#+END_SRC
*** PBounds
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PBounds
  (bounds
   [{p :p r :r}]
   (let [d (c* 2 r)] (thi.ng.geom.types.Rect. (- p r) d d)))
  (width  [_] (c* 2.0 (:r _)))
  (height [_] (c* 2.0 (:r _)))
  (depth  [_] 0)
#+END_SRC
*** PCenter
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PCenter
  (center
   ([_] (thi.ng.geom.types.Circle. (vec2) (:r _)))
   ([_ p] (thi.ng.geom.types.Circle. (vec2 p) (:r _))))
  (centroid [_] (:p _))
#+END_SRC
*** PBoundingCircle
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PBoundingCircle
  (bounding-circle [_] _)
#+END_SRC
*** PCircumference
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PCircumference
  (circumference [_] (c* TWO_PI (:r _)))
#+END_SRC
*** PBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PClassify
  (classify-point
   [_ q]
   (m/signum (c- (:r _) (g/dist (:p _) q)) *eps*))
  g/PProximity
  (closest-point
   [{p :p r :r} q]
   (+ p (g/normalize (- q p) r)))
  g/PBoundary
  (contains-point?
   [{p :p r :r} q]
   (<= (g/mag-squared (- p q)) (c* r r)))
#+END_SRC
*** PSampleable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PSampleable
  (point-at
   [_ t]
   (+ (:p _) (g/as-cartesian (vec2 (:r _) (c* t TWO_PI)))))
  (random-point
   [_] (g/point-at _ (m/random)))
  (random-point-inside
   [_]
   (+ (:p _) (g/randvec2 (m/random (:r _)))))
  (sample-uniform
   [_ udist include-last?]
   (let [points (g/vertices _)]
     (g/sample-uniform* udist include-last? (conj (vec points) (first points)))))
#+END_SRC
*** PIntersectable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PIntersectable
  (intersect-shape
   [_ s]
   (cond
    (instance? thi.ng.geom.types.Circle s) (intersect-circle _ s)
    (instance? thi.ng.geom.types.Rect s) (g/intersect-shape s _)
    :default (g/type-error "Circle" s)))
#+END_SRC
*** PPolygonizable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PPolygonizable
  (as-polygon
   ([_] (g/as-polygon _ *resolution*))
   ([_ res] (thi.ng.geom.types.Polygon. (vec (g/vertices _ res)) [])))
#+END_SRC
*** PMeshable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PMeshable
  (as-mesh
   ([_] (g/as-mesh _ *resolution*))
   ([_ res] (mesh/into-mesh (mesh/mesh2) nil (g/tessellate* (:p _) (g/vertices _ res)))))
#+END_SRC
*** PTessellateable
     A circle can be tessellated into a list of uniform triangles,
     each sharing the circle's centroid. If called without 2nd
     argument the default circle =*resolution*= (a dynamic var defined
     in [[file:geom.org][thi.ng.geom.core]]) will be used.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PTessellateable
  (tessellate
   ([_] (g/tessellate _ *resolution*))
   ([{p :p :as _} res]
      (->> (g/vertices _ res)
          (g/tessellate* p)
          (map #(thi.ng.geom.types.Triangle2. (% 0) (% 1) (% 2))))))
#+END_SRC
*** PExtrudeable
**** TODO don't use polygon as intermediary to ensure better tessellation using centroid
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PExtrudeable
  (extrude
   [_
    {:keys [res depth offset scale top? bottom?]
     :or {res *resolution* depth 1.0 scale 1.0 top? true bottom? true}}]
   (let [points (g/vertices _ res)
         tpoints (if (= 1.0 scale) points (g/vertices (circle (:p _) (c* scale (:r _))) res))
         off (or offset (vec3 0 0 depth))
         points3 (mapv vec3 points)
         tpoints3 (mapv #(+ off %) tpoints)]
     (mesh/into-mesh
      (mesh/mesh3) nil
      (concat
       (when bottom?
         (->> points
              (g/tessellate* (:p _))
              (map (fn [[a b c]] [(vec3 a) (vec3 b) (vec3 c)]))))
       (mapcat (fn [[a1 b1] [a2 b2]] [[a1 b1 a2] [b1 b2 a2]])
               (d/successive-nth 2 (conj points3 (points3 0)))
               (d/successive-nth 2 (conj tpoints3 (tpoints3 0))))
       (when top?
         (->> tpoints
              (g/tessellate* (:p _))
              (map (fn [[a b c]] [(+ off b) (+ off a) (+ off c)]))))))))
#+END_SRC
*** End of implementations                                         :noexport:
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  )
#+END_SRC
