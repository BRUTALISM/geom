* thi.ng.geom.circle
** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  (ns thi.ng.geom.circle
    (:require
     [thi.ng.common.data.core :as d]
     [thi.ng.common.math.core :as m :refer [PI TWO_PI *eps*]]
     [thi.ng.geom.core :as g :refer [vec2 *resolution*]]
     [thi.ng.geom.types :as types])
    #+clj
    (:import
     [thi.ng.geom.types Circle Line2 Polygon Rect Triangle2]))
#+END_SRC
** Constructor
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
(defn circle
  ([] (thi.ng.geom.types.Circle. (vec2) 1.0))
  ([r] (thi.ng.geom.types.Circle. (vec2) r))
  ([p r] (thi.ng.geom.types.Circle. (vec2 p) r))
  ([x y r] (thi.ng.geom.types.Circle. (vec2 x y) r)))
#+END_SRC
** Type specific functions
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  (defn intersect-circle
    [{p :p r1 :r} {q :p r2 :r}]
    (let [delta (g/sub q p)
          d (g/mag delta)]
      (when (and (<= d (+ r1 r2)) (>= d (m/abs (- r1 r2))))
        (let [a (/ (+ (- (* r1 r1) (* r2 r2)) (* d d)) (* 2.0 d))
              invd (/ 1.0 d)
              p (g/madd delta (* a invd) p)
              h (Math/sqrt (- (* r1 r1) (* a a)))
              perp (g/scale (g/normal delta) (* h invd))]
          [(g/add p perp) (g/sub p perp)]))))

  (defn tangent-points
    [{p :p :as c} q]
    (let [m (g/mix p q)]
      (intersect-circle c (circle m (g/dist m p)))))
#+END_SRC
** Protocol implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  (extend-type thi.ng.geom.types.Circle
#+END_SRC
*** PGraph
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PGraph
  (vertices
   ([this] (g/vertices this *resolution*))
   ([this res]
      (map #(g/point-at this %) (m/norm-range res))))
  (edges
   ([this] (g/edges this *resolution*))
   ([this res]
      (let [verts (g/vertices this res)]
        (g/edges* #(thi.ng.geom.types.Line2. (% 0) (% 1))
                  (concat verts [(first verts)])))))
#+END_SRC
*** PShape
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PShape
  (area [{r :r}] (* PI (* r r)))
  (bounds
   [{p :p r :r}]
   (let [d (* 2 r)] (thi.ng.geom.types.Rect. (g/sub p r) d d)))
  (center
   ([this] (thi.ng.geom.types.Circle. (vec2) (:r this)))
   ([this p] (thi.ng.geom.types.Circle. (vec2 p) (:r this))))
  (centroid [this] (:p this))
  (width  [this] (* 2.0 (:r this)))
  (height [this] (* 2.0 (:r this)))
  (depth  [this] 0)
#+END_SRC
*** PShape2
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
    g/PShape2
    (bounding-circle [this] this)
    (circumference [this] (* TWO_PI (:r this)))
#+END_SRC
*** PBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PBoundary
  (classify-point
   [this q]
   (m/signum (- (:r this) (g/dist (:p this) q)) *eps*))
  (closest-point
   [{p :p r :r} q]
   (g/add p (g/normalize (g/sub q p) r)))
  (contains-point?
   [{p :p r :r} q]
   (<= (g/mag-squared (g/sub p q)) (* r r)))
#+END_SRC
*** PSampleable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PSampleable
  (point-at
   [this t]
   (g/add (:p this) (g/cartesian (vec2 (:r this) (* t TWO_PI)))))
  (random-point
   [this] (g/point-at this (m/random)))
  (random-point-inside
   [this]
   (g/add (:p this) (g/scale (g/randvec2) (m/random (:r this)))))
  (sample-uniform
   [this udist include-last?]
   (let [points (g/vertices this)]
     (g/sample-uniform* udist include-last? (conj (vec points) (first points)))))
#+END_SRC
*** PIntersectable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PIntersectable
  (intersect-shape
   [this s]
   (cond
    (instance? thi.ng.geom.types.Circle s) (intersect-circle this s)
    (instance? thi.ng.geom.types.Rect s) (g/intersect-shape s this)
    :default (g/type-error "Circle" s)))
#+END_SRC
*** PPolygonizable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PPolygonizable
  (as-polygon
   ([this] (g/as-polygon this *resolution*))
   ([this res] (thi.ng.geom.types.Polygon. (vec (g/vertices this res)) [])))
#+END_SRC
*** PMeshable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PMeshable
  (as-mesh
   ([this] (g/as-mesh this *resolution*))
   ([this res] (mesh/into-mesh (mesh/mesh2) nil (g/tessellate* (:p this) (g/vertices this res)))))
#+END_SRC
*** PTessellateable
     A circle can be tessellated into a list of uniform triangles,
     each sharing the circle's centroid. If called without 2nd
     argument the default circle =*resolution*= (a dynamic var defined
     in [[file:geom.org][thi.ng.geom.core]]) will be used.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PTessellateable
  (tessellate
   ([this] (g/tessellate this *resolution*))
   ([{p :p :as this} res]
      (->> (g/vertices this res)
          (g/tessellate* p)
          (map #(thi.ng.geom.types.Triangle2. (% 0) (% 1) (% 2))))))
#+END_SRC
*** PExtrudeable
**** TODO don't use polygon as intermediary to ensure better tessellation using centroid
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PExtrudeable
  (extrude
   [this
    {:keys [res depth offset scale top? bottom?] :or {res *resolution* depth 1.0 scale 1.0 top? true bottom? true}}]
   (let [points (g/vertices this res)
         tpoints (if (= 1.0 scale) points (g/vertices (circle (:p this) (* scale (:r this))) res))
         off (or offset (vec3 0 0 depth))
         points3 (mapv #(vec3 %) points)
         tpoints3 (mapv #(g/add off %) tpoints)]
     (mesh/into-mesh
      (mesh/mesh3) nil
      (concat
       (when bottom?
         (->> points
              (g/tessellate* (:p this))
              (map (fn [[a b c]] [(vec3 a) (vec3 b) (vec3 c)]))))
       (mapcat (fn [[a1 b1] [a2 b2]] [[a1 b1 a2] [b1 b2 a2]])
               (d/successive-nth 2 (conj points3 (points3 0)))
               (d/successive-nth 2 (conj tpoints3 (tpoints3 0))))
       (when top?
         (->> tpoints
              (g/tessellate* (:p this))
              (map (fn [[a b c]] [(g/add off b) (g/add off a) (g/add off c)]))))))))
#+END_SRC
*** End of implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  )
#+END_SRC
