#+SETUPFILE: ../../src/setup.org

* Namespace: thi.ng.geom.csg.core

** Helper functions
#+BEGIN_SRC clojure :noweb-ref helpers
  (defrecord CSGVertex [^thi.ng.geom.core.vector.Vec3 p ^thi.ng.geom.core.vector.Vec3 n]
    g/PInterpolate
    (mix [_ v t]
      (CSGVertex. (g/mix p (:p v) t) (g/mix n (:n v) t)))
    g/PFlip
    (flip [_]
      (CSGVertex. p (g/- n))))

  (defrecord CSGPolygon [plane vertices shared]
    g/PFlip
    (flip [_]
      (CSGPolygon. (g/flip plane) (mapv g/flip vertices) shared)))

  (defn compute-split-types
    [n w vertices]
    (let [ieps (- *eps*)]
      (loop [ptype 0, types [], vertices vertices]
        (if vertices
          (let [t (- (g/dot n (:p (first vertices))) w)
                pt (if (< t ieps) 2 (if (> t *eps*) 1 0))]
            (recur (bit-or ptype pt) (conj types pt) (next vertices)))
          [ptype types]))))

  (defn split-poly*
    [n w vertices types]
    (let [nv (count vertices)]
      (loop [f [], b [], i 0]
        (if (< i nv)
          (let [j (rem (inc i) nv)
                vi (nth vertices i)
                ti (types i)
                f (if (== ti 2) f (conj f vi))
                b (if (== ti 1) b (conj b vi))]
            (if (== 3 (bit-or ti (types j)))
              (let [vj (nth vertices j)
                    p (:p vi)
                    v (g/mix vi vj (/ (- w (g/dot n p)) (g/dot n (g/- (:p vj) p))))]
                (recur (conj f v) (conj b v) (inc i)))
              (recur f b (inc i))))
          [f b]))))

  (defn split-poly
    "Takes a plane and splits the given polygon with it. Returns a 4-element vector
    of classified sub-shapes: [coplanar-front coplanar-back front back]."
    [{:keys [n w]} {:keys [vertices plane] :as poly} [cp-front cp-back front back]]
    (let [[ptype types] (compute-split-types n w vertices)]
      (case ptype
        ;; co-planar
        0 (if (pos? (g/dot n (:n plane)))
            [(conj cp-front poly) cp-back front back]
            [cp-front (conj cp-back poly) front back])
        ;; front
        1 [cp-front cp-back (conj front poly) back]
        ;; back
        2 [cp-front cp-back front (conj back poly)]
        ;; both sides -> split
        3 (let [[f b] (split-poly* n w vertices types)]
            [cp-front cp-back
             (if (>= (count f) 3) (conj front (csg-polygon f (:shared poly))) f)
             (if (>= (count b) 3) (conj back (csg-polygon b (:shared poly))) b)]))))
#+END_SRC

** Public API
#+BEGIN_SRC clojure :noweb-ref api
  (defn clip-polygons
    "Uses a CSG node's plane to recursively clip the given seq of polygons.
    Returns a flat seq of polygons classified as in-front of the plane
    or the original seq if no clipping plane is available."
    [{:keys [plane front back] :as node} ps]
    (if (not plane)
      ps
      (let [[cp-front cp-back new-front new-back]
            (reduce
             (fn [state poly] (split-poly plane poly state))
             [[] [] [] []] ps)
            new-front (concat new-front cp-front)
            new-front (if front (clip-polygons front new-front) new-front)
            new-back (if back (clip-polygons back (concat new-back cp-back)) [])]
        (concat new-front new-back))))
  
  (defn all-polygons
    "Returns a lazy seq of all polygons of the given CSG node and its children."
    [{:keys [front back] :as node}]
    (concat
     (:polygons node)
     (if front (all-polygons front))
     (if back (all-polygons back))))
  
  (defn invert
    [{:keys [front back plane] :as node}]
    (assoc node
      :polygons (mapv g/flip (:polygons node))
      :plane (if plane (g/flip plane))
      :front (if back (invert back))
      :back (if front (invert front))))
  
  (defn clip
    "Clips the polygons of the first node with the ones from the second.
    Returns the updated node."
    [{:keys [front back] :as a} b]
    (assoc a
      :polygons (clip-polygons b (:polygons a))
      :front (if front (clip front b))
      :back (if back (clip back b))))
  
  (defn csg-plane
    "Creates a plane definition either from a seq of points or
    a normal vector & w-constant."
    [[a b c]]
    (p/plane-from-points
     (if (map? a) (:p a) a)
     (if (map? b) (:p b) b)
     (if (map? c) (:p c) c)))
  
  (defn csg-polygon
    "Creates a CSG polygon map from the given vertices and
    computes a plane definition using the first 3 vertices."
    ([vertices] (csg-polygon vertices nil))
    ([vertices shared]
       (CSGPolygon. (csg-plane vertices) (vec vertices) shared)))
  
  (defn csg-node
    "Creates a new or refines a CSG tree node and recursively
    adds the given polygons to it."
    ([polygons] (csg-node nil polygons))
    ([{:keys [polygons plane front back] :as node} ps]
       (if (seq ps)
         (let [plane (or plane (:plane (first ps)))
               [cp-front cp-back new-front new-back]
               (reduce
                (fn [state poly] (split-poly plane poly state))
                [[] [] [] []] ps)]
           (assoc node
             :plane plane
             :polygons (concat polygons cp-front cp-back)
             :front (if (seq new-front) (csg-node front new-front) front)
             :back (if (seq new-back) (csg-node back new-back) back)))
         node)))
  
  (defn union
    [a b]
    (let [a (csg-node a)
          b (csg-node b)
          a (clip a b)
          b (-> b (clip a) invert (clip a) invert)]
      (-> a (csg-node (all-polygons b)) all-polygons)))
  
  (defn subtract
    [a b]
    (let [b (csg-node b)
          a (-> a csg-node invert (clip b))
          b (-> b (clip a) invert (clip a) invert)]
      (-> a (csg-node (all-polygons b)) invert all-polygons)))
  
  (defn intersect
    [a b]
    (let [a (-> a csg-node invert)
          b (-> b csg-node (clip a) invert)
          a (clip a b)
          b (clip b a)]
      (-> a (csg-node (all-polygons b)) invert all-polygons)))
#+END_SRC
** Constructors
#+BEGIN_SRC clojure :noweb-ref ctors
  (defn mesh->csg
    "Converts a regular Mesh3 into a seq of CSG polygons.
    First calls `compute-face-normals` on mesh if not already present."
    [{:keys [faces fnormals] :as m}]
    (let [fnormals (if (seq fnormals)
                     fnormals
                     (:fnormals (g/compute-face-normals m)))]
      (map
       (fn [f]
         (let [n (fnormals f)]
           (csg-polygon (map #(CSGVertex. % n) f) nil)))
       faces)))
  
  (defn csg->mesh
    [polygons]
    (->> polygons
         (map #(map :p (:vertices %)))
         (gm/into-mesh (gm/gmesh))))
    
  (defn csg-cone
    ([s e radius res] (csg-cone s e radius radius res))
    ([s e r-south r-north res]
       (let [dir (g/- e s)
             az (g/normalize dir)
             ax (-> (if (> (m/abs (az 1)) 0.5)
                      (vec3 1 0 0)
                      (vec3 0 1 0))
                    (g/cross az)
                    (g/normalize))
             ay (-> ax (g/cross az) g/normalize)
             vs (CSGVertex. s (g/invert az))
             ve (CSGVertex. e az)
             f (fn [stack i blend r]
                 (let [theta (* m/TWO_PI i)
                       out   (g/madd ax (Math/cos theta) (g/* ay (Math/sin theta)))
                       norm  (g/madd out (- 1.0 (m/abs blend)) (g/* az blend))
                       pos   (g/+ s (g/* dir stack) (g/* out r))]
                   (CSGVertex. pos norm)))
             res (double res)]
         (mapcat
          (fn [i]
            (let [t0 (/ i res) t1 (/ (inc i) res)]
              [(csg-polygon [vs (f 0 t0 -1 r-south) (f 0 t1 -1 r-south)])
               (csg-polygon [(f 0 t1 0 r-south) (f 0 t0 0 r-south) (f 1 t0 0 r-north) (f 1 t1 0 r-north)])
               (csg-polygon [ve (f 1 t1 1 r-north) (f 1 t0 1 r-north)])]))
          (range res)))))
#+END_SRC

** Namespace declaration
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/csg/core.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.csg.core
    ,#+cljs
    (:require-macros
     [thi.ng.macromath.core :as mm])
    (:require
     [thi.ng.geom.core :as g]
     [thi.ng.geom.core.vector :as v :refer [vec3]]
     [thi.ng.geom.gmesh :as gm]
     [thi.ng.geom.plane :as p]
     [thi.ng.common.data.core :as d]
     [thi.ng.common.math.core :as m :refer [PI TWO_PI *eps*]]
     ,#+clj [thi.ng.macromath.core :as mm]))

  (declare csg-polygon)

  <<helpers>>

  <<api>>

  <<ctors>>
#+END_SRC
