#+SETUPFILE: ../../src/setup.org

* thi.ng.geom.mesh.slicing

** Slicing algorithm

#+BEGIN_SRC clojure :noweb-ref main
(def box
  (-> (r/rect 100)
      ;;(c/circle [50 50] 50)
      (g/as-polygon)
      (g/extrude-shell
       {:depth 100 :wall 25 :top? false :bottom? true :mesh (bm/basic-mesh)})
      (g/tessellate)))

(defn z-slice-tree
  [tree z eps]
  (let [plane (pl/plane-with-point (vec3 0 0 z) v/V3Z)
	tris (->> (it/query-interval tree [(- z eps) (+ z eps)] [])
	     (mapcat
	      (fn [t]
		(let [t' (get (t/slice-with* t plane) 1)
		      tf (filter #(m/delta= z (:z %)) t)]
		  ;;(prn t t' tf)
		  (or t' (if (> (count tf) 1) [t]))))))]
    (g/into (gm/gmesh) tris)))

(defn vertex-loop
  [m v z]
  (loop [path [v] neighbors (d/value-set :next (:vertices m) v)]
    (let [nf (filter #(m/delta= z (:z %)) neighbors)
	  nf2 (first (filter #(< (.indexOf path %) 1) nf))]
      (prn (peek path) :-> nf2)
      (if (and nf2 (not (m/delta= v nf2)))
	(recur (conj path nf2) (d/value-set :next (:vertices m) nf2))
	path))))

(defn find-loops2
  [m z]
  (loop [paths [] vertices (set (filter #(m/delta= z (:z %)) (g/vertices m)))]
    (if (seq vertices)
      (let [v (first vertices)
	    p (vertex-loop m v z)]
	(prn (map :xy p))
	(recur (conj paths p) (reduce disj vertices p)))
      paths)))

(defn find-edge-loop
  [edges]
  (loop [acc [(ffirst edges)], p (peek (first edges)), edges (set (rest edges))]
    (if (seq edges)
      (let [e (some #(if (= p (first %)) %) edges)]
	(if e
	  (recur (conj acc (first e)) (second e) (disj edges e))
	  [acc edges]))
      [acc])))

(defn edge-loops
  ([edges] (edge-loops [] edges))
  ([acc edges]
     (let [[loop edges] (find-edge-loop edges)]
       (if edges
	 (recur (conj acc loop) edges)
	 (conj acc loop)))))

(defn mesh->intervaltree
  [slice-dir mesh]
  (let [axis ({:x 0 :y 1 :z 2} slice-dir)
	faces (map #(vector (gu/axis-bounds axis %) %) (g/faces mesh))
	median (/ (reduce (fn [acc [b]] (+ acc (mm/addm (b 0) (b 1) 0.5))) 0 faces)
		  (count faces))]
    (it/interval-tree median faces)))

(defn find-loops
  [edges]
  (loop [acc [] edges edges]
    (if edges
      (let [[l m] (find-edge-loop edges)]
	(if (seq l)
	  (recur (if (> (count l) 1) (conj acc l) acc) m)))
      acc)))

(defn save-mesh
  [m] (with-open [o (io/output-stream "p.ply")] (mio/write-ply o m)))
#+END_SRC

** Java 2D graphics helpers

#+BEGIN_SRC clojure :noweb-ref g2d
(defn new-image
  "Creates a new transparent BufferedImage and Graphics2D instance.
  Graphics are configured for anti-aliasing."
  [w h]
  (let[img (BufferedImage. w h BufferedImage/TYPE_INT_ARGB)
       g2d (.createGraphics img)]
    (doto g2d
      (.setRenderingHint RenderingHints/KEY_ANTIALIASING RenderingHints/VALUE_ANTIALIAS_ON)
      (.setRenderingHint RenderingHints/KEY_INTERPOLATION RenderingHints/VALUE_INTERPOLATION_BICUBIC)
      (.setRenderingHint RenderingHints/KEY_RENDERING RenderingHints/VALUE_RENDER_QUALITY))
    {:img img :g2d g2d}))

(defn clear-image
  "Takes an image spec returned by new-image and fills the image with transparent white."
  [{:keys[img g2d]}]
  (doto g2d
    (.setPaint Color/RED)
    (.fillRect 0 0 (.getWidth img) (.getHeight img))))

(defn save-image
  "Takes an image spec and saves it as PNG to the given path."
  [imgspec path]
  (ImageIO/write (:img imgspec) "PNG" (io/file path)))

(defn draw-poly
  [img points]
  (let [ccw? (neg? (g/area (p/polygon2 points)))
	[p & more :as points] (if ccw? (reverse points) points)
	path (Path2D$Double.)]
    (prn :np (count points))
    (.moveTo path (:x p) (:y p))
    (doseq [p more]
      (.lineTo path (:x p) (:y p)))
    (.closePath path)
    (doto (:g2d img)
      (.setPaint (if ccw? Color/BLACK Color/WHITE))
      (.fill path)
      (.setPaint Color/GREEN))
    (doseq [p points]
      (.draw (:g2d img) (Rectangle2D$Double. (dec (:x p)) (dec (:y p)) 3.0 3.0)))))

(defn draw-slice-paths
  [paths z]
  (let [img (new-image 500 500)]
    (clear-image img)
    (doseq [p paths]
      (prn p)
      (draw-poly img (map #(g/* (:xy %) 4) p)))
    (save-image img (format "z-%3.3f.png" (double z)))))
#+END_SRC

** Complete namespace

#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/mesh/slicing.cljx :noweb yes :mkdirp yes :padline no
(ns thi.ng.geom.mesh.slicing
  (:require
   [thi.ng.geom.core :as g]
   [thi.ng.geom.core.utils :as gu]
   [thi.ng.geom.core.vector :as v :refer [vec3]]
   [thi.ng.geom.gmesh :as gm]
   [thi.ng.geom.basicmesh :as bm]
   [thi.ng.geom.circle :as c]
   [thi.ng.geom.rect :as r]
   [thi.ng.geom.polygon :as p]
   [thi.ng.geom.plane :as pl]
   [thi.ng.geom.triangle :as t]
   [thi.ng.geom.mesh.io :as mio]
   [clojure.java.io :as io]
   [thi.ng.common.math.core :as m]
   [thi.ng.common.data.core :as d]
   [thi.ng.common.data.intervaltree :as it]
   [thi.ng.macromath.core :as mm])
  (:import
   (java.awt.image BufferedImage)
   (java.awt Graphics2D RenderingHints Color Font GradientPaint)
   (java.awt.geom Path2D$Double Rectangle2D$Double)
   (javax.imageio ImageIO)))

  <<main>>

  <<g2d>>
#+END_SRC
