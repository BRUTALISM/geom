#+SETUPFILE: ../../src/setup.org

* Contents                                                         :toc_4_gh:
 - [[#namespace-thinggeomvizcore][Namespace: thi.ng.geom.viz.core]]
     - [[#example-usage][Example usage]]
         - [[#running-all-examples-from-repl][Running all examples from REPL]]
         - [[#scatter-plot][Scatter plot]]
         - [[#line-plot][Line plot]]
         - [[#polar-line-plot][Polar line plot]]
         - [[#stacked-intervals][Stacked intervals]]
             - [[#plain-intervals][Plain intervals]]
             - [[#categorized-timeline][Categorized timeline]]
         - [[#contour-plot][Contour plot]]
     - [[#visualization-spec-format][Visualization spec format]]
         - [[#axis-definitions-x-axis--y-axis][Axis definitions (:x-axis / :y-axis)]]
             - [[#notes-for-polar-projection][Notes for polar projection]]
             - [[#default-axis-label-styling][Default axis label styling]]
         - [[#axis-grid-definition-grid][Axis grid definition (:grid)]]
         - [[#dataset-specs-data][Dataset specs (:data)]]
     - [[#scales][Scales]]
         - [[#linear-scale][Linear scale]]
         - [[#logarithmic-scale][Logarithmic scale]]
         - [[#lens-scale-dilating--bundling][Lens scale (dilating / bundling)]]
     - [[#axis--tick-generators][Axis & tick generators]]
         - [[#common-axis-factory][Common axis factory]]
         - [[#linear][Linear]]
         - [[#logarithmic][Logarithmic]]
         - [[#lens-axis][Lens axis]]
     - [[#visualization-methods][Visualization methods]]
         - [[#line-plot][Line plot]]
         - [[#area-graph][Area graph]]
         - [[#scatter-plot][Scatter plot]]
         - [[#contour-lines][Contour lines]]
         - [[#stacked-intervals][Stacked intervals]]
     - [[#2d-cartesian-plotting-svg][2D Cartesian Plotting (SVG)]]
         - [[#svg-axis-generators][SVG axis generators]]
         - [[#generic-plotting-helpers][Generic plotting helpers]]
     - [[#2d-polar-plotting-svg][2D Polar Plotting (SVG)]]
         - [[#svg-axis-generators][SVG axis generators]]
     - [[#projections][Projections]]
     - [[#value-transformations][Value transformations]]
     - [[#value-formatting][Value formatting]]
     - [[#custom-shapes][Custom shapes]]
     - [[#todo-3d-plotting][TODO 3D Plotting]]
     - [[#complete-namespace-definitions][Complete namespace definitions]]

* Namespace: thi.ng.geom.viz.core

** Example usage

This section shows some basic example outputs and general usage
patterns. See spec description in next section for further
information.

*** Running all examples from REPL

#+BEGIN_SRC clojure
  (->> ["scatter" "lineplot" "lineplot-polar" "intervals" "timeline" "contours"]
       (map #(load-file (str "examples/" % ".clj")))
       dorun)
#+END_SRC

*** Scatter plot

| [[http://media.thi.ng/geom/viz/scatter-linear-3.svg]] | [[http://media.thi.ng/geom/viz/scatter-log-3.svg]] |

#+BEGIN_SRC clojure :tangle ../babel/examples/scatter.clj :mkdirp yes :padline no
  (require '[thi.ng.geom.viz.core :as viz] :reload)
  (require '[thi.ng.geom.svg.core :as svg])
  (require '[thi.ng.math.core :as m])

  (->> {:x-axis (viz/log-axis {:domain [1 201] :range [50 590] :pos 550})
        :y-axis (viz/linear-axis
                 {:domain [0.1 101] :range [550 20] :major 10 :minor 5 :pos 50
                  :label-dist 15 :label {:text-anchor "end"}})
        ;;:y-axis (viz/log-axis {:domain [0.1 101] :range [550 20] :pos 50}) ;; Y log axis
        :grid   {:attribs {:stroke "#caa"}
                 :minor-x true
                 :minor-y true}
        :data   [{:values  (map (juxt identity #(Math/sqrt %)) (range 0 200 2))
                  :attribs {:fill "#0af" :stroke "none"}
                  :layout  viz/svg-scatter-plot}
                 {:values  (map (juxt identity #(m/random %)) (range 0 200 2))
                  :attribs {:fill "none" :stroke "#f60"}
                  :shape   (viz/svg-triangle-down 6)
                  :layout  viz/svg-scatter-plot}]}
       (viz/svg-plot2d-cartesian)
       (svg/svg {:width 600 :height 600})
       (svg/serialize)
       (spit "scatter.svg"))
#+END_SRC

*** Line plot

[[http://media.thi.ng/geom/viz/lineplot-3.svg]]

#+BEGIN_SRC clojure :tangle ../babel/examples/lineplot.clj :mkdirp yes :padline no
  (require '[thi.ng.geom.viz.core :as viz] :reload)
  (require '[thi.ng.geom.svg.core :as svg])
  (require '[thi.ng.math.core :as m :refer [PI]])

  (defn test-equation
    [t] (let [x (m/mix (- PI) PI t)] [x (* (Math/cos (* 0.5 x)) (Math/sin (* x x x)))]))

  (->> {:x-axis (viz/linear-axis
                 {:domain [(- PI) PI] :range [50 580] :major (/ PI 2) :minor (/ PI 4) :pos 250})
        :y-axis (viz/linear-axis
                 {:domain [-1 1] :range [250 20] :major 0.2 :minor 0.1 :pos 50
                  :label-dist 15 :label {:text-anchor "end"}})
        :grid   {:attribs {:stroke "#caa"}
                 :minor-y true}
        :data   [{:values  (map test-equation (m/norm-range 200))
                  :attribs {:fill "none" :stroke "#0af"}
                  :layout  viz/svg-line-plot}]}
       (viz/svg-plot2d-cartesian)
       (svg/svg {:width 600 :height 300})
       (svg/serialize)
       (spit "lineplot.svg"))
#+END_SRC

*** Polar line plot

Same overall visualization setup, only using polar coordinate transform...

[[http://media.thi.ng/geom/viz/lineplot-polar-3.svg]]

#+BEGIN_SRC clojure :tangle ../babel/examples/lineplot-polar.clj :mkdirp yes :padline no
  (require '[thi.ng.geom.viz.core :as viz] :reload)
  (require '[thi.ng.geom.svg.core :as svg])
  (require '[thi.ng.geom.core.vector :as v])
  (require '[thi.ng.math.core :as m :refer [PI]])

  (defn test-equation
    [t] (let [x (m/mix (- PI) PI t)] [x (* (Math/cos (* 0.5 x)) (Math/sin (* x x x)))]))

  (->> {:x-axis (viz/linear-axis
                 {:domain [(- PI) PI] :range [(* 1.1 PI) (* 1.9 PI)]
                  :major (/ PI 2) :minor (/ PI 16)
                  :major-size -10 :minor-size -5 :label-dist -15
                  :pos 280})
        :y-axis (viz/linear-axis
                 {:domain [-1 1] :range [60 280]
                  :major 0.5 :minor 0.25
                  :major-size 0.05 :minor-size 0.025 :label-dist 0.1
                  :pos (* 1.1 PI)})
        :origin (v/vec2 300 310)
        :grid   {:attribs {:stroke "#caa" :fill "none"}
                 :minor-x true
                 :minor-y true}
        :data   [{:values  (map test-equation (m/norm-range 200))
                  :attribs {:fill "none" :stroke "#0af"}
                  :layout  viz/svg-line-plot}]}
       (viz/svg-plot2d-polar)
       (svg/svg {:width 600 :height 320})
       (svg/serialize)
       (spit "lineplot-polar.svg"))
#+END_SRC

*** Stacked intervals
**** Plain intervals

[[http://media.thi.ng/geom/viz/intervals-3.svg]]

#+BEGIN_SRC clojure :tangle ../babel/examples/intervals.clj :mkdirp yes :padline no
  (require '[thi.ng.geom.viz.core :as viz] :reload)
  (require '[thi.ng.geom.svg.core :as svg])
  (require '[thi.ng.math.core :as m])

  (->> {:x-axis (viz/linear-axis {:domain [-10 310] :range [50 550] :major 100 :minor 50 :pos 150})
        :y-axis (viz/linear-axis {:domain [0 4] :range [50 150] :visible false})
        :data   [{:values  [[0 100] [10 90] [80 200] [250 300] [150 170] [110 120]
                            [210 280] [180 280] [160 240] [160 170]]
                  :attribs {:stroke-width "10px" :stroke-linecap "round" :stroke "#0af"}
                  :layout  viz/svg-stacked-interval-plot}]}
       (viz/svg-plot2d-cartesian)
       (svg/svg {:width 600 :height 200})
       (svg/serialize)
       (spit "intervals.svg"))
#+END_SRC

**** Categorized timeline

This more complex example shows how to use structured data (here
project descriptions) to create a timeline and visualize each item
using a custom shape function w/ linear gradients (based on item type).

[[http://media.thi.ng/geom/viz/timeline-3.svg]]

#+BEGIN_SRC clojure :tangle ../babel/examples/timeline.clj :mkdirp yes :padline no
  (require '[thi.ng.geom.viz.core :as viz] :reload)
  (require '[thi.ng.geom.svg.core :as svg])
  (require '[thi.ng.math.core :as m])
  (require '[thi.ng.color.core :as col])
  (import '[java.util Calendar GregorianCalendar])

  (def items
    [{:title "toxiclibs"          :from #inst "2006-03" :to #inst "2013-06" :type :oss}
     {:title "thi.ng/geom"        :from #inst "2011-08" :to #inst "2015-06" :type :oss}
     {:title "thi.ng/trio"        :from #inst "2012-12" :to #inst "2015-06" :type :oss}
     {:title "thi.ng/simplecl"    :from #inst "2012-10" :to #inst "2013-06" :type :oss}
     {:title "thi.ng/raymarchcl"  :from #inst "2013-02" :to #inst "2013-05" :type :oss}
     {:title "thi.ng/structgen"   :from #inst "2012-10" :to #inst "2013-02" :type :oss}
     {:title "thi.ng/luxor"       :from #inst "2013-10" :to #inst "2015-06" :type :oss}
     {:title "thi.ng/morphogen"   :from #inst "2014-03" :to #inst "2015-06" :type :oss}
     {:title "thi.ng/color"       :from #inst "2014-09" :to #inst "2015-06" :type :oss}
     {:title "thi.ng/validate"    :from #inst "2014-05" :to #inst "2015-06" :type :oss}
     {:title "thi.ng/ndarray"     :from #inst "2015-05" :to #inst "2015-06" :type :oss}
     {:title "thi.ng/tweeny"      :from #inst "2013-10" :to #inst "2015-01" :type :oss}
     {:title "Co(De)Factory"      :from #inst "2013-12" :to #inst "2014-08" :type :project}
     {:title "Chrome WebLab"      :from #inst "2011-05" :to #inst "2012-11" :type :project}
     {:title "ODI"                :from #inst "2013-07" :to #inst "2013-10" :type :project}
     {:title "LCOM"               :from #inst "2012-06" :to #inst "2013-05" :type :project}
     {:title "V&amp;A Ornamental" :from #inst "2010-12" :to #inst "2011-05" :type :project}
     {:title "Engine26"           :from #inst "2010-08" :to #inst "2010-12" :type :project}
     {:title "Resonate"           :from #inst "2012-04" :to #inst "2012-04" :type :workshop}
     {:title "Resonate"           :from #inst "2013-03" :to #inst "2013-03" :type :workshop}
     {:title "Resonate"           :from #inst "2014-04" :to #inst "2014-04" :type :workshop}
     {:title "Resonate"           :from #inst "2015-04" :to #inst "2015-04" :type :workshop}
     {:title "Resonate"           :from #inst "2012-04" :to #inst "2012-04" :type :talk}
     {:title "Resonate"           :from #inst "2013-03" :to #inst "2013-03" :type :talk}
     {:title "Resonate"           :from #inst "2014-04" :to #inst "2014-04" :type :talk}
     {:title "Resonate"           :from #inst "2015-04" :to #inst "2015-04" :type :talk}
     {:title "Retune"             :from #inst "2014-09" :to #inst "2014-09" :type :talk}
     {:title "Bezalel"            :from #inst "2011-04" :to #inst "2011-04" :type :workshop}
     {:title "V&amp;A"            :from #inst "2011-01" :to #inst "2011-03" :type :workshop}
     {:title "HEAD"               :from #inst "2010-10" :to #inst "2010-10" :type :workshop}
     {:title "ETH"                :from #inst "2010-11" :to #inst "2010-11" :type :workshop}
     {:title "SAC"                :from #inst "2012-11" :to #inst "2012-11" :type :workshop}
     {:title "SAC"                :from #inst "2014-12" :to #inst "2014-12" :type :workshop}
     {:title "MSA"                :from #inst "2013-04" :to #inst "2013-04" :type :workshop}
     {:title "Young Creators"     :from #inst "2014-06" :to #inst "2014-06" :type :workshop}
     {:title "EYEO"               :from #inst "2013-06" :to #inst "2013-06" :type :talk}
     {:title "Reasons"            :from #inst "2014-02" :to #inst "2014-02" :type :talk}
     {:title "Reasons"            :from #inst "2014-09" :to #inst "2014-09" :type :talk}])

  (def item-type-colors {:project "#0af" :oss "#63f" :workshop "#9f0" :talk "#f9f"})

  (def month (* (/ (+ (* 3 365) 366) 4.0 12.0) 24 60 60 1000))
  (def year  (* month 12))

  (defn ->epoch [^java.util.Date d] (.getTime d))

  ;; http://stackoverflow.com/questions/9001384/java-date-rounding
  (defn round-to-year
    [epoch]
    (let [cal (GregorianCalendar.)]
      (doto cal
        (.setTimeInMillis (long epoch))
        (.add Calendar/MONTH 6)
        (.set Calendar/MONTH 0)
        (.set Calendar/DAY_OF_MONTH 1)
        (.set Calendar/HOUR 0)
        (.set Calendar/MINUTE 0)
        (.set Calendar/SECOND 0)
        (.set Calendar/MILLISECOND 0))
      (.get cal Calendar/YEAR)))

  (defn make-gradient
    [[id base]]
    (let [base (col/hex->rgba base)]
      (svg/linear-gradient-rgb
       id {} [0 base] [1 (col/adjust-saturation-rgb base -0.66)])))

  (defn item-range [i] [(->epoch (:from i)) (->epoch (:to i))])

  (defn timeline-spec
    [type offset]
    {:values     (if type (filter #(= type (:type %)) items) items)
     :offset     offset
     :item-range item-range
     :attribs    {:fill "white" :stroke "none"
                  :font-family "Arial" :font-size 10}
     :shape      (viz/labeled-rect-horizontal
                  {:h 14 :r 7 :min-width 30 :base-line 3 :label :title
                   :fill #(str "url(#" (name (:type %)) ")")})
     :layout     viz/svg-stacked-interval-plot})

  ;; Create stacked timeline with *all* items
  (->> {:x-axis (viz/linear-axis
                 {:domain [(->epoch #inst "2010-09") (->epoch #inst "2015-06")]
                  :range [10 950] :pos 160 :major year :minor month :format round-to-year})
        :y-axis (viz/linear-axis {:domain [0 9] :range [10 160] :visible false})
        :grid   {:minor-x true}
        :data   [(timeline-spec nil 0)]}
       (viz/svg-plot2d-cartesian)
       (svg/svg
        {:width 960 :height 200}
        (apply svg/defs (map make-gradient item-type-colors)))
       (svg/serialize)
       (spit "timeline.svg"))
#+END_SRC

We can also group items by their =:type= property and arrange them
separately along the Y-axis. This creates a less compact result, but
better legibility. The example also shows how to re-use visualization
spec fragments (via the use of our =timeline-spec= fn).

[[http://media.thi.ng/geom/viz/timeline-separate-3.svg]]

#+BEGIN_SRC clojure :tangle ../babel/examples/timeline.clj :mkdirp yes
  ;; Create stacked timeline vertically grouped by item type
  (->> {:x-axis (viz/linear-axis
                 {:domain [(->epoch #inst "2010-09") (->epoch #inst "2015-06")]
                  :range [10 950] :pos 205 :major year :minor month :format round-to-year})
        :y-axis (viz/linear-axis {:domain [0 12] :range [10 205] :visible false})
        :grid   {:minor-x true}
        :data   [(timeline-spec :project 0)
                 (timeline-spec :oss 2)
                 (timeline-spec :workshop 9)
                 (timeline-spec :talk 10)]}
       (viz/svg-plot2d-cartesian)
       (svg/svg
        {:width 960 :height 230}
        (apply svg/defs (map make-gradient item-type-colors)))
       (svg/serialize)
       (spit "timeline-separate.svg"))
#+END_SRC

*** Contour plot

| [[http://media.thi.ng/geom/viz/contours-3.svg]]     | [[http://media.thi.ng/geom/viz/contours-outline-3.svg]]     |
| linear X/Y filled                               | linear X/Y outline                                      |
| [[http://media.thi.ng/geom/viz/contours-log-3.svg]] | [[http://media.thi.ng/geom/viz/contours-log-outline-3.svg]] |
| log X/Y filled                                  | log X/Y outline                                         |

#+BEGIN_SRC clojure :tangle ../babel/examples/contours.clj :mkdirp yes :padline no
  (require '[thi.ng.geom.viz.core :as viz])
  (require '[thi.ng.geom.svg.core :as svg])
  (require '[thi.ng.math.core :as m])
  (require '[thi.ng.math.simplexnoise :as n])

  (->> {:x-axis (viz/linear-axis
                 {:domain [0 63] :range [50 550] :major 8 :minor 2 :pos 550})
        :y-axis (viz/linear-axis
                 {:domain [0 63] :range [550 50] :major 8 :minor 2 :pos 50
                  :label-dist 15 :label {:text-anchor "end"}})
        ;; :x-axis (viz/log-axis {:domain [0 64] :range [50 550] :base 2 :pos 555})
        ;; :y-axis (viz/log-axis {:domain [0 64] :range [550 50] :base 2 :pos 45})
        :data   [{:matrix  (->> (for [y (range 64) x (range 64)]
                                  (+ 0.5 (* 0.5 (n/noise2 (* x 0.06) (* y 0.06)))))
                                (viz/contour-matrix 64 64))
                  :matrix-scale [10 10]
                  :levels  (range 0.05 1 0.05)
                  :attribs {:fill "none" :stroke "#0af"}
                  ;; :attribs {:fill "rgba(0,160,255,0.05)" :stroke "#0af"} ;; filled version
                  :layout  viz/svg-contour-plot}]}
       (viz/svg-plot2d-cartesian)
       (svg/svg {:width 600 :height 600})
       (svg/serialize)
       (spit "contours-outline.svg"))
#+END_SRC

Another variation of the above with polar coordinates:

[[http://media.thi.ng/geom/viz/contours-polar.gif]]

** Visualization spec format

| *Key*     | *Value*                  | *Required* | *Description*                             |
|-----------+--------------------------+------------+-------------------------------------------|
| =:x-axis= | horizontal axis spec map | Y          | X-axis behavior & representation details  |
| =:y-axis= | vertical axis spec map   | Y          | Y-axis behavior & representation details  |
| =:grid=   | grid spec map            | N          | Optional background axis grid             |
| =:data=   | vector of dataset specs  | Y          | Allows multiple datasets in visualization |

*** Axis definitions (:x-axis / :y-axis)

Axis specs are usually created via one of the available axis generator
functions (=linear-axis= & =log-axis=). These functions too take a map
of the same keys, but =linear-axis= interpretes the =:major= and
=:minor= values differently: In this context these values are the
intended precision and ticks will be created at multiples of the given
value. The =log-axis= generator auto-creates ticks based on the
=:base= of the logarithm.

| *Key*         | *Value*              | *Required* | *Default*           | *Description*                                                            |
|---------------+----------------------+------------+---------------------+--------------------------------------------------------------------------|
| =:scale=      | scale function       | Y          | nil                 | Scale function to translate domain values into visualization coordinates |
| =:domain=     | vec of domain bounds | Y          | nil                 | Lower & upper bound of data source interval                              |
| =:range=      | vec of range bounds  | Y          | nil                 | Lower & upper bound of projected coordinates                             |
| =:major=      | seq of domain values | N          | nil                 | Seq of domain positions at which to draw labeled tick marks              |
| =:minor=      | seq of domain values | N          | nil                 | Seq of domain positions at which                                         |
| =:major-size= | number               | N          | 10                  | Length of major tick marks                                               |
| =:minor-size= | number               | N          | 5                   | Length of minor tick marks                                               |
| =:label-dist= | number               | N          | 10 + major-size     | Distance of value labels from axis                                       |
| =:pos=        | number               | Y          | nil                 | Draw position of the axis (ypos for X-axis, xpos for Y-axis)             |
| =:format=     | function             | N          | =(value-format 2)=  | Function to format tick labels                                           |
| =:label=      | map                  | N          | see next section    | Style attribute map for value labels                                     |
| =:attribs=    | map                  | N          | ={:stroke "black"}= | Axis line attribs attributes                                             |
| =:visible=    | boolean              | N          | true                | Flag if axis will be visible in visualization                            |
| =:origin=     | 2d point             | Y/N        | [0 0]               | Only needed for polar projections, center of visualization               |

**** Notes for polar projection

- the =:range= interval of the x-axis must be an angle interval in radians (see above example)
- the =:range= interval of the y-axis must be a radius interval

Same goes for =:pos= values: The =:pos= for x-axis is a radius, the =:pos= for y-axis is an angle in radians

**** Default axis label styling

#+BEGIN_SRC clojure :noweb-ref default-label-style
  {:fill "black"
   :stroke "none"
   :font-family "Arial"
   :font-size 10
   :text-anchor "middle"}
#+END_SRC

*** Axis grid definition (:grid)

*Note:* If no =:grid= spec is given in the main spec, no background grid will be displayed...

| *Key*      | *Value* | *Required* | *Default*       | *Description*                                            |
|------------+---------+------------+-----------------+----------------------------------------------------------|
| =:attribs= | hashmap | N          | default attribs | allows extra attributes to be injected (e.g. for SVG)    |
| =:minor-x= | boolean | N          | false           | if =false= only uses major tick mark positions on X axis |
| =:minor-y= | boolean | N          | false           | if =false= only uses major tick mark positions on Y axis |

*** Dataset specs (:data)

The format of these maps is largely dependent on the concrete
visualization methods used, but must state the following keys:

| *Key*     | *Value*         | *Required* | *Default* | *Description*               |
|-----------+-----------------+------------+-----------+-----------------------------|
| =:layout= | layout function | Y          | none      | function to map data points |

** Scales

Scaling functions merely provide a means to map values from a source
interval (domain) to a target interval (range). The latter usually
represents values in the visualization space (e.g. partial screen
coordinates).

The functions below can be useful also outside a visualization
context, but here are used in conjunction with their related axis
definition functions described below. When creating visualizations,
we would not usually use these scaling functions directly, but use
them implicitly via our defined axis specs.

*** Linear scale

#+BEGIN_SRC clojure :noweb-ref scale
  (defn linear-scale
    [domain range]
    (fn [x] (m/map-interval x domain range)))
#+END_SRC

*** Logarithmic scale

#+BEGIN_SRC clojure :noweb-ref scale
  (defn log
    [base]
    (let [lb (Math/log base)]
      #(/ (cond
            (pos? %) (Math/log %)
            (neg? %) (- (Math/log (- %)))
            :else 0)
          lb)))

  (defn log-scale
    [base [d1 d2 :as domain] [r1 r2 :as range]]
    (let [log* (log base)
          d1l  (log* d1)
          dr   (- (log* d2) d1l)]
      (fn [x] (m/mix r1 r2 (/ (- (log* x) d1l) dr)))))
#+END_SRC

*** Lens scale (dilating / bundling)

The =lens-scale= defines a non-linear mapping by specifying a focal
position in the domain interval, as well as a lens strength which
controls the compression or expansion of the domain space around this
focal point. If strength is positive, the lens is dilating. If
negative, it is bundling (compressing). A strength of zero causes a
normal/linear scaling behavior.

The two animations below show the effect of individually adjusting the focus and lens strength:

| [[http://media.thi.ng/geom/viz/lens-focus-2.gif]] | [[http://media.thi.ng/geom/viz/lens-strength-4.gif]] |
| Focus shift, constant strength = 0.5          | Lens strength adjustment, constant focus = 0.0   |

#+BEGIN_SRC clojure :noweb-ref scale
  (defn lens-scale
    [[d1 d2] [r1 r2] focus strength]
    (let [dr (- d2 d1)
          f  (/ (- focus d1) dr)]
      (fn [x] (m/mix-lens r1 r2 (/ (- x d1) dr) f strength))))
#+END_SRC

** Axis & tick generators

*** Common axis factory

#+BEGIN_SRC clojure :noweb-ref axis
  (defn axis-common*
    [{:keys [visible major-size minor-size format attribs label label-dist]
      :or {format (value-formatter 2), visible true
           major-size 10, minor-size 5}
      :as spec}]
    (assoc spec
           :visible    visible
           :major-size major-size
           :minor-size minor-size
           :format     format
           :attribs      (merge
                        {:stroke "black"}
                        attribs)
           :label      (merge
                        <<default-label-style>>
                        label)
           :label-dist (or label-dist (+ 10 major-size))))
#+END_SRC

*** Linear

#+BEGIN_SRC clojure :noweb-ref axis
  (defn lin-tick-marks
    [[d1 d2] delta]
    (let [dr (- d2 d1)
          d1' (m/roundto d1 delta)]
      (filter #(m/in-range? d1 d2 %) (range d1' (+ d2 delta) delta))))

  (defn linear-axis
    [{:keys [domain range major minor] :as spec}]
    (let [major' (if major (lin-tick-marks domain major))
          minor' (if minor (lin-tick-marks domain minor))
          minor' (if (and major' minor')
                   (filter (complement (set major')) minor')
                   minor')]
      (-> spec
          (assoc
           :scale (linear-scale domain range)
           :major major'
           :minor minor')
          (axis-common*))))
#+END_SRC

*** Logarithmic

#+BEGIN_SRC clojure :noweb-ref axis
  (defn log-ticks-domain
    [base d1 d2]
    (let [log* (log base)] [(m/floor (log* d1)) (m/ceil (log* d2))]))

  (defn log-tick-marks-major
    [base [d1 d2]]
    (let [[d1l d2l] (log-ticks-domain base d1 d2)]
      (->> (for [i (range d1l (inc d2l))]
             (if (>= i 0)
               (* (/ 1 base) (Math/pow base i))
               (* (/ 1 base) (- (Math/pow base (- i))))))
           (filter #(m/in-range? d1 d2 %)))))

  (defn log-tick-marks-minor
    [base [d1 d2]]
    (let [[d1l d2l] (log-ticks-domain base d1 d2)
          ticks (if (== 2 base) [0.75] (range 2 base))]
      (->> (for [i (range d1l (inc d2l)) j ticks]
             (if (>= i 0)
               (* (/ j base) (Math/pow base i))
               (* (/ j base) (- (Math/pow base (- i))))))
           (filter #(m/in-range? d1 d2 %)))))

  (defn log-axis
    [{:keys [base domain range] :or {base 10} :as spec}]
    (-> spec
        (assoc
         :scale (log-scale base domain range)
         :major (log-tick-marks-major base domain)
         :minor (log-tick-marks-minor base domain))
        (axis-common*)))
#+END_SRC

*** Lens axis

The lens axis is a modified =linear-axis= with two additional required
attributes to control the domain space deformation in order to
compress or expand the space around a given focal point and therefore
introduce a non-linear arrangement. See =lens-scale= above for further
details.

- =:focus= - the domain value acting as lens focus (by default the center of the domain is used)
- =:strength= - the lens strength & direction (normalized values -1.0 ... + 1.0, default = 0.5)

#+BEGIN_SRC clojure :noweb-ref axis
  (defn lens-axis
    [{:keys [domain range focus strength major minor]
      :or {strength 0.5} :as spec}]
    (let [major' (if major (lin-tick-marks domain major))
          minor' (if minor (lin-tick-marks domain minor))
          minor' (if (and major' minor')
                   (filter (complement (set major')) minor')
                   minor')
          focus  (or focus (/ (apply + domain) 2.0))]
      (-> spec
          (assoc
           :scale    (lens-scale domain range focus strength)
           :major    major'
           :minor    minor'
           :focus    focus
           :strength strength)
          (axis-common*))))
#+END_SRC

** Visualization methods
*** Line plot

#+BEGIN_SRC clojure :noweb-ref plot-2d
  (defn line-plot-points
    [{:keys [x-axis y-axis project]} {:keys [values attribs]}]
    (let [[ry1 ry2] (:range y-axis)]
      (->> values
           (sequence
            (value-transducer
             {:cull-domain (:domain x-axis)
              :cull-range  (if (< ry1 ry2) [ry1 ry2] [ry2 ry1])
              :scale-x     (:scale x-axis)
              :scale-y     (:scale y-axis)
              :project     project})))))

  (defn svg-line-plot
    [v-spec d-spec]
    (svg/line-strip (line-plot-points v-spec d-spec) (:attribs d-spec)))
#+END_SRC

*** Area graph

#+BEGIN_SRC clojure :noweb-ref plot-2d
  (defn svg-area-plot
    [v-spec d-spec]
    (let [project (:project v-spec)
          ry1     (first (:range (:y-axis v-spec)))
          points  (line-plot-points (assoc v-spec :project identity) d-spec)
          p       (v/vec2 (first (last points)) ry1)
          q       (v/vec2 (ffirst points) ry1)
          points  (concat points (map (partial g/mix p q) (m/norm-range 20)))]
      (svg/polygon (map project points) (:attribs d-spec))))
#+END_SRC

*** Scatter plot

#+BEGIN_SRC clojure :noweb-ref plot-2d
  (defn svg-scatter-plot
    [{:keys [x-axis y-axis project]}
     {:keys [values attribs shape]
      :or   {shape #(svg/circle % 3)}}]
    (let [[r1 r2] (:range y-axis)]
      (->> values
           (sequence
            (value-transducer
             {:cull-domain (:domain x-axis)
              :cull-range  (if (< r1 r2) [r1 r2] [r2 r1])
              :scale-x     (:scale x-axis)
              :scale-y     (:scale y-axis)
              :project     project
              :shape       shape}))
           (svg/group attribs))))
#+END_SRC

*** Contour lines

#+BEGIN_SRC clojure :noweb-ref plot-2d
  (defn contour-matrix
    [w h values]
    (let [mat (nd/ndarray :float32 values [h w])]
      (contours/set-border2d mat 1e9)))

  (defn contour->svg
    [scale-x scale-y project]
    (fn [contour]
      (let [contour (map (fn [[y x]] [(scale-x x) (scale-y y)]) contour)]
        (svg/polygon (map project contour)))))

  (defn svg-contour-plot
    [{:keys [x-axis y-axis project]}
     {:keys [matrix attribs levels]}]
    (let [contour-fn (contour->svg (:scale x-axis) (:scale y-axis) project)]
      (svg/group
       attribs
       (map
        #(svg/group {} (map contour-fn (contours/find-contours2d matrix %)))
        (sort levels)))))
#+END_SRC

*** Stacked intervals

#+BEGIN_SRC clojure :noweb-ref plot-2d
  (defn overlap? [[a b] [c d]] (and (<= a d) (>= b c)))

  (defn compute-row-stacking
    [item-range coll]
    (reduce
     (fn [grid x]
       (let [r (item-range x)]
         (loop [[row & more] grid idx 0]
           (if (or (nil? row) (not (some #(overlap? r (item-range %)) row)))
             (update-in grid [idx] #(conj (or % []) x))
             (recur more (inc idx))))))
     [] coll))

  (defn svg-stacked-interval-plot
    [{:keys [x-axis y-axis]}
     {:keys [values attribs shape item-range offset]
      :or   {shape (fn [[a b]] (svg/line a b))
             item-range identity
             offset 0}}]
    (let [scale-x (:scale x-axis)
          scale-y (:scale y-axis)
          [d1 d2] (:domain x-axis)
          map-val (value-mapper scale-x scale-y)]
      (->> values
           (filter #(overlap? (:domain x-axis) (item-range %)))
           (sort-by (comp first item-range))
           (compute-row-stacking item-range)
           (mapcat
            (fn [i row]
              (let [i (+ i offset)]
                (map
                 (fn [item]
                   (let [[a b] (item-range item)
                         a (max d1 a)
                         b (min d2 b)]
                     [(map-val [a i]) (map-val [b i]) item]))
                 row)))
            (range))
           (map shape)
           (svg/group attribs))))
#+END_SRC

** 2D Cartesian Plotting (SVG)

*** SVG axis generators

#+BEGIN_SRC clojure :noweb-ref plot-2d
  (defn svg-axis*
    [{:keys [major minor attribs label]} axis tick1-fn tick2-fn label-fn]
    (svg/group
     attribs
     (map tick1-fn major)
     (map tick2-fn minor)
     (svg/group label (map label-fn major))
     axis))

  (defn svg-x-axis-cartesian
    [{:keys [scale major-size minor-size label-dist pos format] [r1 r2] :range
      :as spec}]
    (svg-axis*
     spec (svg/line [r1 pos] [r2 pos])
     #(let [x (scale %)] (svg/line [x pos] [x (+ pos major-size)]))
     #(let [x (scale %)] (svg/line [x pos] [x (+ pos minor-size)]))
     #(let [x (scale %)] (svg/text [x (+ pos label-dist)] (format %)))))

  (defn svg-y-axis-cartesian
    [{:keys [scale major-size minor-size label-dist pos format] [r1 r2] :range
      :as spec}]
    (svg-axis*
     spec (svg/line [pos r1] [pos r2])
     #(let [y (scale %)] (svg/line [pos y] [(- pos major-size) y]))
     #(let [y (scale %)] (svg/line [pos y] [(- pos minor-size) y]))
     #(let [y (scale %)] (svg/text [(- pos label-dist) y] (format %)))))
#+END_SRC

*** Generic plotting helpers

#+BEGIN_SRC clojure :noweb-ref plot-2d
  (defn svg-axis-grid2d-cartesian
    [x-axis y-axis {:keys [attribs minor-x minor-y]}]
    (let [[x1 x2] (:range x-axis)
          [y1 y2] (:range y-axis)
          scale-x (:scale x-axis)
          scale-y (:scale y-axis)]
      (svg/group
       (merge {:stroke "#ccc" :stroke-dasharray "1 1"} attribs)
       (if (:visible x-axis)
         (map #(let [x (scale-x %)] (svg/line [x y1] [x y2]))
              (if minor-x (concat (:minor x-axis) (:major x-axis)) (:major x-axis))))
       (if (:visible y-axis)
         (map #(let [y (scale-y %)] (svg/line [x1 y] [x2 y]))
              (if minor-y (concat (:minor y-axis) (:major y-axis)) (:major y-axis)))))))

  (defn svg-plot2d-cartesian
    [{:keys [x-axis y-axis grid data] :as opts}]
    (let [opts (assoc opts :project identity)]
      (svg/group
       {}
       (if grid (svg-axis-grid2d-cartesian x-axis y-axis grid))
       (map (fn [spec] ((:layout spec) opts spec)) data)
       (if (:visible x-axis) (svg-x-axis-cartesian x-axis))
       (if (:visible y-axis) (svg-y-axis-cartesian y-axis)))))
#+END_SRC

** 2D Polar Plotting (SVG)

*** SVG axis generators

#+BEGIN_SRC clojure :noweb-ref plot-2d
  (defn svg-x-axis-polar
    [{{:keys [scale major-size minor-size label-dist pos format]
       [r1 r2] :range :or {format (value-formatter 2)}} :x-axis
       project :project o :origin :as spec}]
    (svg-axis*
     (:x-axis spec) (svg/arc o pos r1 r2 true {:fill "none"})
     #(let [x (scale %)]
        (svg/line (project [x pos]) (project [x (- pos major-size)])))
     #(let [x (scale %)]
        (svg/line (project [x pos]) (project [x (- pos minor-size)])))
     #(let [x (scale %)]
        (svg/text (project [x (- pos label-dist)]) (format %) {:stroke "none"}))))

  (defn svg-y-axis-polar
    [{{:keys [scale major-size minor-size label-dist pos format]
       [r1 r2] :range :or {format (value-formatter 2)}} :y-axis
       project :project :as spec}]
    (svg-axis*
     (:y-axis spec) (svg/line (project [pos r1]) (project [pos r2]))
     #(let [y (scale %)]
        (svg/line (project [pos y]) (project [(- pos major-size) y])))
     #(let [y (scale %)]
        (svg/line (project [pos y]) (project [(- pos minor-size) y])))
     #(let [y (scale %)]
        (svg/text (project [(- pos label-dist) y]) (format %) {:stroke "none"}))))
#+END_SRC

#+BEGIN_SRC clojure :noweb-ref plot-2d
  (defn svg-axis-grid2d-polar
    [{:keys [x-axis y-axis origin project] {:keys [attribs minor-x minor-y]} :grid}]
    (let [[x1 x2] (:range x-axis)
          [y1 y2] (:range y-axis)
          scale-x (:scale x-axis)
          scale-y (:scale y-axis)]
      (svg/group
       (merge {:stroke "#ccc" :stroke-dasharray "1 1"} attribs)
       (if (:visible x-axis)
         (map
          #(let [x (scale-x %)]
             (svg/line (project [x y1]) (project [x y2])))
          (if minor-x (concat (:minor x-axis) (:major x-axis)) (:major x-axis))))
       (if (:visible y-axis)
         (map
          #(let [y (scale-y %)]
             (svg/arc origin y x1 x2 true))
          (if minor-y (concat (:minor y-axis) (:major y-axis)) (:major y-axis)))))))

  (defn svg-plot2d-polar
    [{:keys [x-axis y-axis grid data origin] :as opts}]
    (let [opts (assoc opts :project (polar-projection origin))]
      (svg/group
       {}
       (if grid (svg-axis-grid2d-polar opts))
       (map (fn [spec] ((:layout spec) opts spec)) data)
       (if (:visible x-axis) (svg-x-axis-polar opts))
       (if (:visible y-axis) (svg-y-axis-polar opts)))))
#+END_SRC

** Projections

#+BEGIN_SRC clojure :noweb-ref projections
  (defn polar-projection
    [origin]
    (let [o (v/vec2 origin)]
      (fn [[x y]] (g/+ o (g/as-cartesian (v/vec2 y x))))))
#+END_SRC

** Value transformations

#+BEGIN_SRC clojure :noweb-ref transformers
  (defn value-mapper
    [scale-x scale-y] (fn [[x y]] [(scale-x x) (scale-y y)]))

  (defn value-transducer
    [{:keys [cull-domain cull-range scale-x scale-y project shape]}]
    (cond->      (comp
                  (filter #(m/in-range? cull-domain (first %)))
                  (map (value-mapper scale-x scale-y)))
      cull-range (comp (filter #(m/in-range? cull-range (second %))))
      project    (comp (map project))
      shape      (comp (map shape))))
#+END_SRC

** Value formatting

#+BEGIN_SRC clojure :noweb-ref formatters
  (defn value-formatter
    [prec]
    (let [fmt [(f/float prec)]]
      (fn [x] (f/format fmt x))))
#+END_SRC

** Custom shapes

This section provides some preset shape functions for use with scatter
plots or stacked interval plots (see examples at beginning of this
file).

#+BEGIN_SRC clojure :noweb-ref shapes
  (defn svg-triangle-up
    [w]
    (let [h (* w (Math/sin m/THIRD_PI))
          w (* 0.5 w)]
      (fn [[x y]] (svg/polygon [[(- x w) (+ y h)] [(+ x w) (+ y h)] [x y]]))))

  (defn svg-triangle-down
    [w]
    (let [h (* w (Math/sin m/THIRD_PI))
          w (* 0.5 w)]
      (fn [[x y]] (svg/polygon [[(- x w) (- y h)] [(+ x w) (- y h)] [x y]]))))

  (defn svg-square
    [r] (let [d (* r 2.0)] (fn [[x y]] (svg/rect [(- x r) (- y r)] d d))))

  (defn labeled-rect-horizontal
    [{:keys [h r label fill min-width base-line]}]
    (let [r2 (* -2 r)
          h2 (* 0.5 h)]
      (fn [[[ax ay :as a] [bx :as b] item]]
        (svg/group
         {}
         (svg/rect
          [(- ax r) (- ay h2)] (- bx ax r2) h
          {:fill (fill item) :rx r :ry r})
         (if (< min-width (- bx ax))
           (svg/text [ax (+ base-line ay)] (label item)))))))
#+END_SRC

** TODO 3D Plotting

TBD

** Complete namespace definitions

#+BEGIN_SRC clojure :tangle ../babel/src/thi/ng/geom/viz/core.cljc :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.viz.core
    (:require
     [thi.ng.geom.core :as g]
     [thi.ng.geom.core.vector :as v]
     [thi.ng.geom.svg.core :as svg]
     [thi.ng.ndarray.core :as nd]
     [thi.ng.ndarray.contours :as contours]
     [thi.ng.math.core :as m]
     [thi.ng.strf.core :as f]))

  <<transformers>>

  <<projections>>

  <<formatters>>

  <<scale>>

  <<axis>>

  <<shapes>>

  <<plot-2d>>
#+END_SRC

