#+SETUPFILE: ../../src/setup.org

* Contents                                                         :toc_4_gh:
 - [[#namespace-thinggeomvizcore][Namespace: thi.ng.geom.viz.core]]
     - [[#example-usage][Example usage]]
         - [[#scatter-plot][Scatter plot]]
         - [[#line-plot][Line plot]]
         - [[#stacked-intervals][Stacked intervals]]
             - [[#plain-intervals][Plain intervals]]
             - [[#categorized-timeline][Categorized timeline]]
         - [[#contour-plot][Contour plot]]
     - [[#visualization-spec-format][Visualization spec format]]
         - [[#axis-definitions-x-axis--y-axis][Axis definitions (:x-axis / :y-axis)]]
         - [[#axis-grid-definition-grid][Axis grid definition (:grid)]]
         - [[#dataset-specs-data][Dataset specs (:data)]]
     - [[#scales][Scales]]
         - [[#linear-scale][Linear scale]]
         - [[#logarithmic-scale][Logarithmic scale]]
     - [[#axis--tick-generators][Axis & tick generators]]
         - [[#svg-axis-generators][SVG axis generators]]
         - [[#linear][Linear]]
         - [[#logarithmic][Logarithmic]]
     - [[#2d-cartesian-plotting-svg][2D Cartesian Plotting (SVG)]]
         - [[#generic-plotting-helpers][Generic plotting helpers]]
         - [[#line-plot][Line plot]]
         - [[#scatter-plot][Scatter plot]]
         - [[#contour-lines][Contour lines]]
         - [[#stacked-intervals][Stacked intervals]]
     - [[#helper-functions][Helper functions]]
     - [[#custom-shape-drawing][Custom shape drawing]]
     - [[#todo-3d-plotting][TODO 3D Plotting]]
     - [[#complete-namespace-definitions][Complete namespace definitions]]

* Namespace: thi.ng.geom.viz.core

** Example usage

This section shows some basic example outputs and general usage
patterns. See spec description in next section for further
information.

*** Scatter plot

| [[http://media.thi.ng/geom/viz/scatter-linear-2.svg]] | [[http://media.thi.ng/geom/viz/scatter-log-2.svg]] |

#+BEGIN_SRC clojure :tangle ../babel/examples/scatter.clj :mkdirp yes :padline no
  (require '[thi.ng.geom.viz.core :as viz])
  (require '[thi.ng.geom.svg.core :as svg])
  (require '[thi.ng.math.core :as m])

  (->> {:x-axis (viz/log-axis {:domain [1 201] :range [50 590] :base 10 :pos 550})
        :y-axis (viz/linear-axis {:domain [0 100] :range [550 20] :major 10 :minor 5 :pos 50})
        ;;:y-axis (viz/log-axis {:domain [0.1 101] :range [550 20] :base 10 :pos 50}) ;; Y log axis
        :grid   {:attribs {:stroke "#caa"}
                 :minor-x true
                 :minor-y true}
        :data   [{:values  (map (juxt identity #(Math/sqrt %)) (range 0 200 2))
                  :attribs {:fill "#0af" :stroke "none"}
                  :layout  viz/svg-scatter-plot}
                 {:values  (map (juxt identity #(m/random %)) (range 0 200 2))
                  :attribs {:fill "none" :stroke "#f60"}
                  :shape   (viz/svg-triangle-down 3)
                  :layout  viz/svg-scatter-plot}]}
       (viz/svg-plot2d-cartesian)
       (svg/svg {:width 600 :height 600})
       (svg/serialize)
       (spit "scatter.svg"))
#+END_SRC

*** Line plot

[[http://media.thi.ng/geom/viz/lineplot-2.svg]]

#+BEGIN_SRC clojure :tangle ../babel/examples/lineplot.clj :mkdirp yes :padline no
  (require '[thi.ng.geom.viz.core :as viz])
  (require '[thi.ng.geom.svg.core :as svg])
  (require '[thi.ng.math.core :as m :refer [PI HALF_PI QUARTER_PI]])

  (defn test-equation
    [t] (let [x (m/mix (- PI) PI t)] [x (* (Math/cos (* 0.5 x)) (Math/sin (* x x x)))]))

  (->> {:x-axis (viz/linear-axis
                 {:domain [(- PI) PI]
                  :range  [50 580]
                  :major  HALF_PI
                  :minor  QUARTER_PI
                  :pos    250})
        :y-axis (viz/linear-axis
                 {:domain [-1 1]
                  :range  [250 20]
                  :major  0.2
                  :minor  0.1
                  :pos    50})
        :grid   {:attribs {:stroke "#caa"}
                 :minor-y true}
        :data   [{:values  (map test-equation (m/norm-range 200))
                  :attribs {:fill "none" :stroke "#0af"}
                  :layout  viz/svg-line-plot}]}
       (viz/svg-plot2d-cartesian)
       (svg/svg {:width 600 :height 300})
       (svg/serialize)
       (spit "lineplot.svg"))
#+END_SRC

*** Stacked intervals
**** Plain intervals

[[http://media.thi.ng/geom/viz/intervals-2.svg]]

#+BEGIN_SRC clojure :tangle ../babel/examples/intervals.clj :mkdirp yes :padline no
  (require '[thi.ng.geom.viz.core :as viz])
  (require '[thi.ng.geom.svg.core :as svg])
  (require '[thi.ng.math.core :as m])

  (->> {:x-axis (viz/linear-axis {:domain [-10 310] :range [50 550] :major 100 :minor 50 :pos 150})
        :y-axis (viz/linear-axis {:domain [0 4] :range [50 150] :visible false})
        :data   [{:values  [[0 100] [10 90] [80 200] [250 300] [150 170] [110 120]
                            [210 280] [180 280] [160 240] [160 170]]
                  :attribs {:stroke-width "10px" :stroke-linecap "round" :stroke "#0af"}
                  :layout  viz/svg-stacked-interval-plot}]}
       (viz/svg-plot2d-cartesian)
       (svg/svg {:width 600 :height 200})
       (svg/serialize)
       (spit "intervals.svg"))
#+END_SRC

**** Categorized timeline

This more complex example shows how to use structured data (here
project descriptions) to create a timeline and visualize each item
using a custom shape function w/ linear gradients (based on item type).

[[http://media.thi.ng/geom/viz/timeline-2.svg]]

#+BEGIN_SRC clojure :tangle ../babel/examples/timeline.clj :mkdirp yes :padline no
  (require '[thi.ng.geom.viz.core :as viz])
  (require '[thi.ng.geom.svg.core :as svg])
  (require '[thi.ng.math.core :as m])
  (require '[thi.ng.color.core :as col])
  (import '[java.util Calendar GregorianCalendar])

  (def items
    [{:title "toxiclibs" :from #inst "2006-03" :to #inst "2013-06" :type :oss}
     {:title "thi.ng/geom" :from #inst "2011-08" :to #inst "2015-06" :type :oss}
     {:title "thi.ng/trio" :from #inst "2012-12" :to #inst "2015-06" :type :oss}
     {:title "thi.ng/simplecl" :from #inst "2012-10" :to #inst "2013-06" :type :oss}
     {:title "thi.ng/raymarchcl" :from #inst "2013-02" :to #inst "2013-05" :type :oss}
     {:title "thi.ng/structgen" :from #inst "2012-10" :to #inst "2013-02" :type :oss}
     {:title "thi.ng/luxor" :from #inst "2013-10" :to #inst "2015-06" :type :oss}
     {:title "thi.ng/morphogen" :from #inst "2014-03" :to #inst "2015-06" :type :oss}
     {:title "thi.ng/color" :from #inst "2014-09" :to #inst "2015-06" :type :oss}
     {:title "thi.ng/validate" :from #inst "2014-05" :to #inst "2015-06" :type :oss}
     {:title "thi.ng/ndarray" :from #inst "2015-05" :to #inst "2015-06" :type :oss}
     {:title "thi.ng/tweeny" :from #inst "2013-10" :to #inst "2015-01" :type :oss}
     {:title "Co(De)Factory" :from #inst "2013-12" :to #inst "2014-08" :type :project}
     {:title "Chrome WebLab" :from #inst "2011-05" :to #inst "2012-11" :type :project}
     {:title "ODI" :from #inst "2013-07" :to #inst "2013-10" :type :project}
     {:title "LCOM" :from #inst "2012-06" :to #inst "2013-05" :type :project}
     {:title "V&amp;A Ornamental" :from #inst "2010-12" :to #inst "2011-05" :type :project}
     {:title "Engine26" :from #inst "2010-08" :to #inst "2010-12" :type :project}
     {:title "Resonate" :from #inst "2012-04" :to #inst "2012-04" :type :workshop}
     {:title "Resonate" :from #inst "2013-03" :to #inst "2013-03" :type :workshop}
     {:title "Resonate" :from #inst "2014-04" :to #inst "2014-04" :type :workshop}
     {:title "Resonate" :from #inst "2015-04" :to #inst "2015-04" :type :workshop}
     {:title "Resonate" :from #inst "2012-04" :to #inst "2012-04" :type :talk}
     {:title "Resonate" :from #inst "2013-03" :to #inst "2013-03" :type :talk}
     {:title "Resonate" :from #inst "2014-04" :to #inst "2014-04" :type :talk}
     {:title "Resonate" :from #inst "2015-04" :to #inst "2015-04" :type :talk}
     {:title "Retune" :from #inst "2014-09" :to #inst "2014-09" :type :talk}
     {:title "Bezalel" :from #inst "2011-04" :to #inst "2011-04" :type :workshop}
     {:title "V&amp;A" :from #inst "2011-01" :to #inst "2011-03" :type :workshop}
     {:title "HEAD" :from #inst "2010-10" :to #inst "2010-10" :type :workshop}
     {:title "ETH" :from #inst "2010-11" :to #inst "2010-11" :type :workshop}
     {:title "SAC" :from #inst "2012-11" :to #inst "2012-11" :type :workshop}
     {:title "SAC" :from #inst "2014-12-02" :to #inst "2014-12-06" :type :workshop}
     {:title "MSA" :from #inst "2013-04" :to #inst "2013-04" :type :workshop}
     {:title "Young Creators" :from #inst "2014-06" :to #inst "2014-06" :type :workshop}
     {:title "EYEO" :from #inst "2013-06" :to #inst "2013-06" :type :talk}
     {:title "Reasons" :from #inst "2014-02" :to #inst "2014-02" :type :talk}
     {:title "Reasons" :from #inst "2014-09" :to #inst "2014-09" :type :talk}])

  (def month (* (/ (+ (* 3 365) 366) 4.0 12.0) 24 60 60 1000))
  (def year (* month 12))

  (defn ->epoch
    [^java.util.Date d] (.getTime d))

  ;; http://stackoverflow.com/questions/9001384/java-date-rounding
  (defn round-to-year
    [epoch]
    (let [cal (GregorianCalendar.)]
      (doto cal
        (.setTimeInMillis (long epoch))
        (.add Calendar/MONTH 6)
        (.set Calendar/MONTH 0)
        (.set Calendar/DAY_OF_MONTH 1)
        (.set Calendar/HOUR 0)
        (.set Calendar/MINUTE 0)
        (.set Calendar/SECOND 0)
        (.set Calendar/MILLISECOND 0))
      (.get cal Calendar/YEAR)))

  (defn make-gradient
    [id base]
    (let [base (col/hex->rgba base)]
      (svg/linear-gradient-rgb
       id {} [0 base] [1 (col/adjust-saturation-rgb base -0.66)])))

  (defn timeline-item
    [[[ax ay :as a] [bx :as b] item]]
    (svg/group
     {}
     (svg/rect
      [(- ax 7) (- ay 7)] (- bx ax -14) 14
      {:fill (str "url(#" (name (:type item)) ")") :rx 7 :ry 7})
     (if (< 30 (- bx ax))
       (svg/text [ax (+ 3 ay)] (:title item) {:stroke "none"}))))

  (->> {:x-axis (viz/linear-axis
                 {:domain [(->epoch #inst "2010-09") (->epoch #inst "2015-06")]
                  :range  [50 950]
                  :pos    200
                  :major  year
                  :minor  month
                  :format round-to-year})
        :y-axis (viz/linear-axis
                 {:domain  [0 9]
                  :range   [50 200]
                  :pos     50
                  :visible false})
        :grid   {:minor-x true
                 :minor-y false}
        :data   [{:values     items
                  :item-range (fn [x] [(->epoch (:from x)) (->epoch (:to x))])
                  :attribs    {:fill "white" :stroke "none" ;;:stroke-width "14px" :stroke-linecap "round"
                               :font-family "Arial" :font-size 10}
                  :shape      timeline-item
                  :layout  viz/svg-stacked-interval-plot}]}
       (viz/svg-plot2d-cartesian)
       (svg/svg
        {:width 960 :height 250}
        (svg/defs
          (make-gradient "project" "#0af")
          (make-gradient "oss" "#63f")
          (make-gradient "workshop" "#9f0")
          (make-gradient "talk" "#f9f")))
       (svg/serialize)
       (spit "timeline.svg"))
#+END_SRC

*** Contour plot

| [[http://media.thi.ng/geom/viz/contours-2.svg]]     | [[http://media.thi.ng/geom/viz/contours-outline-2.svg]]     |
| linear X/Y filled                               | linear X/Y outline                                      |
| [[http://media.thi.ng/geom/viz/contours-log-2.svg]] | [[http://media.thi.ng/geom/viz/contours-log-outline-2.svg]] |
| log X/Y filled                                  | log X/Y outline                                         |

#+BEGIN_SRC clojure :tangle ../babel/examples/contours.clj :mkdirp yes :padline no
  (require '[thi.ng.geom.viz.core :as viz])
  (require '[thi.ng.geom.svg.core :as svg])
  (require '[thi.ng.math.core :as m])
  (require '[thi.ng.math.simplexnoise :as n])

  (->> {:x-axis (viz/linear-axis {:domain [0 63] :range [50 550] :major 8 :minor 2 :pos 550})
        :y-axis (viz/linear-axis {:domain [0 63] :range [550 50] :major 8 :minor 2 :pos 50})
        ;; :x-axis (viz/log-axis {:domain [0 64] :range [50 550] :base 2 :pos 555})
        ;; :y-axis (viz/log-axis {:domain [0 64] :range [550 50] :base 2 :pos 45})
        :data   [{:matrix  (->> (for [y (range 64) x (range 64)]
                                  (+ 0.5 (* 0.5 (n/noise2 (* x 0.06) (* y 0.06)))))
                                (viz/contour-matrix 64 64))
                  :matrix-scale [10 10]
                  :levels  (range 0.05 1 0.05)
                  :attribs {:fill "none" :stroke "#0af"}
                  ;; :attribs {:fill "rgba(0,160,255,0.05)" :stroke "#0af"} ;; filled version
                  :layout  viz/svg-contour-plot}]}
       (viz/svg-plot2d-cartesian)
       (svg/svg {:width 600 :height 600})
       (svg/serialize)
       (spit "contours-outline.svg"))
#+END_SRC

** Visualization spec format

| *Key*     | *Value*                  | *Required* | *Description*                             |
|-----------+--------------------------+------------+-------------------------------------------|
| =:x-axis= | horizontal axis spec map | Y          | X-axis behavior & representation details  |
| =:y-axis= | vertical axis spec map   | Y          | Y-axis behavior & representation details  |
| =:grid=   | grid spec map            | N          | Optional background axis grid             |
| =:data=   | vector of dataset specs  | Y          | Allows multiple datasets in visualization |

*** Axis definitions (:x-axis / :y-axis)

Axis specs are usually created via one of the available axis generator
functions (=linear-axis= & =log-axis=). These functions too take a map
of the same keys, but =linear-axis= interpretes the =:major= and
=:minor= values differently: In this context these values are the
intended precision and ticks will be created at multiples of the given
value. The =log-axis= generator auto-creates ticks based on the
=:base= of the logarithm.

| *Key*      | *Value*              | *Required* | *Default*          | *Description*                                                            |
|------------+----------------------+------------+--------------------+--------------------------------------------------------------------------|
| =:scale=   | scale function       | Y          | nil                | Scale function to translate domain values into visualization coordinates |
| =:domain=  | vec of domain bounds | Y          | nil                | Lower & upper bound of data source interval                              |
| =:range=   | vec of range bounds  | Y          | nil                | Lower & upper bound of projected coordinates                             |
| =:major=   | seq of domain values | N          | nil                | Seq of domain positions at which to draw labeled tick marks              |
| =:minor=   | seq of domain values | N          | nil                | Seq of domain positions at which                                         |
| =:pos=     | number               | Y          | nil                | Draw position of the axis (ypos for X-axis, xpos for Y-axis)             |
| =:format=  | function             | N          | =(value-format 2)= | Function to format tick labels                                           |
| =:visible= | boolean              | N          | Y                  | Flag if axis will be visible in visualization                            |

*** Axis grid definition (:grid)

*Note:* If no =:grid= spec is given in the main spec, no background grid will be displayed...

| *Key*      | *Value* | *Required* | *Default*     | *Description*                                            |
|------------+---------+------------+---------------+----------------------------------------------------------|
| =:attribs= | hashmap | N          | default style | allows extra attributes to be injected (e.g. for SVG)    |
| =:minor-x= | boolean | N          | false         | if =false= only uses major tick mark positions on X axis |
| =:minor-y= | boolean | N          | false         | if =false= only uses major tick mark positions on Y axis |

*** Dataset specs (:data)

The format of these maps is largely dependent on the concrete
visualization methods used, but must state the following keys:

| *Key*     | *Value*         | *Required* | *Default* | *Description*               |
|-----------+-----------------+------------+-----------+-----------------------------|
| =:layout= | layout function | Y          | none      | function to map data points |

** Scales

*** Linear scale

#+BEGIN_SRC clojure :noweb-ref scale
  (defn linear-scale
    [domain range]
    (fn [x] (m/map-interval x domain range)))
#+END_SRC

*** Logarithmic scale

#+BEGIN_SRC clojure :noweb-ref scale
  (defn log
    [base]
    (let [lb (Math/log base)]
      #(/ (cond
            (pos? %) (Math/log %)
            (neg? %) (- (Math/log (- %)))
            :else 0)
          lb)))

  (defn log-scale
    [base [d1 d2 :as domain] [r1 r2 :as range]]
    (let [log* (log base)
          d1l  (log* d1)
          dr   (- (log* d2) d1l)]
      (fn [x] (m/mix r1 r2 (/ (- (log* x) d1l) dr)))))
#+END_SRC

** Axis & tick generators

*** SVG axis generators

#+BEGIN_SRC clojure :noweb-ref axis
  (defn format-value
    [prec]
    (let [fmt [(f/float prec)]]
      (fn [x] (f/format fmt x))))

  (defn svg-axis*
    [{:keys [major minor]} a b align tick1-fn tick2-fn]
    (svg/group
     {:stroke "black"}
     (svg/group
      {:fill "black"
       :font-family "Arial"
       :font-size 10
       :text-anchor align}
      (mapcat tick1-fn major))
     (svg/group
      {:stroke "#333"}
      (map tick2-fn minor))
     (svg/line a b)))

  (defn svg-x-axis
    [{:keys [scale major minor pos format] [r1 r2] :range
      :or {format (format-value 2)} :as spec}]
    (svg-axis*
     spec [r1 pos] [r2 pos] "start"
     #(let [x (scale %)]
        [(svg/line [x pos] [x (+ pos 10)]) (svg/text [x (+ pos 20)] (format %) {:stroke "none"})])
     #(let [x (scale %)]
        (svg/line [x pos] [x (+ pos 5)]))))

  (defn svg-y-axis
    [{:keys [scale major minor pos format] [r1 r2] :range
      :or {format (format-value 2)} :as spec}]
    (svg-axis*
     spec [pos r1] [pos r2] "end"
     #(let [y (scale %)]
        [(svg/line [pos y] [(- pos 10) y]) (svg/text [(- pos 15) y] (format %) {:stroke "none"})])
     #(let [y (scale %)]
        (svg/line [pos y] [(- pos 5) y]))))
#+END_SRC

*** Linear

#+BEGIN_SRC clojure :noweb-ref axis
  (defn lin-tick-marks
    [[d1 d2] delta]
    (let [dr (- d2 d1)
          d1' (m/roundto d1 delta)]
      (filter #(m/in-range? d1 d2 %) (range d1' (+ d2 delta) delta))))

  (defn linear-axis
    [{:keys [domain range major minor visible] :or {visible true} :as spec}]
    (let [major' (if major (lin-tick-marks domain major))
          minor' (if minor (lin-tick-marks domain minor))
          minor' (if (and major' minor')
                   (filter (complement (set major')) minor')
                   minor')]
      (assoc spec
             :scale   (linear-scale domain range)
             :major   major'
             :minor   minor'
             :visible visible)))
#+END_SRC

*** Logarithmic

#+BEGIN_SRC clojure :noweb-ref axis
  (defn log-ticks-domain
    [base d1 d2]
    (let [log* (log base)] [(m/floor (log* d1)) (m/ceil (log* d2))]))

  (defn log-tick-marks-major
    [base [d1 d2]]
    (let [[d1l d2l] (log-ticks-domain base d1 d2)]
      (->> (for [i (range d1l (inc d2l))]
             (if (>= i 0)
               (* (/ 1 base) (Math/pow base i))
               (* (/ 1 base) (- (Math/pow base (- i))))))
           (filter #(m/in-range? d1 d2 %)))))

  (defn log-tick-marks-minor
    [base [d1 d2]]
    (let [[d1l d2l] (log-ticks-domain base d1 d2)
          ticks (if (== 2 base) [0.75] (range 2 base))]
      (->> (for [i (range d1l (inc d2l)) j ticks]
             (if (>= i 0)
               (* (/ j base) (Math/pow base i))
               (* (/ j base) (- (Math/pow base (- i))))))
           (filter #(m/in-range? d1 d2 %)))))

  (defn log-axis
    [{:keys [base domain range visible] :or {visible true} :as spec}]
    (assoc spec
           :scale   (log-scale base domain range)
           :major   (log-tick-marks-major base domain)
           :minor   (log-tick-marks-minor base domain)
           :visible visible))
#+END_SRC

** 2D Cartesian Plotting (SVG)

*** Generic plotting helpers

#+BEGIN_SRC clojure :noweb-ref plot-2d
  (defn svg-axis-grid2d-cartesian
    [x-axis y-axis {:keys [attribs minor-x minor-y]}]
    (let [[x1 x2] (:range x-axis)
          [y1 y2] (:range y-axis)
          scale-x (:scale x-axis)
          scale-y (:scale y-axis)]
      (svg/group
       (merge {:stroke "#ccc" :stroke-dasharray "1 1"} attribs)
       (if (:visible x-axis)
         (map #(let [x (scale-x %)] (svg/line [x y1] [x y2]))
              (if minor-x (concat (:minor x-axis) (:major x-axis)) (:major x-axis))))
       (if (:visible y-axis)
         (map #(let [y (scale-y %)] (svg/line [x1 y] [x2 y]))
              (if minor-y (concat (:minor y-axis) (:major y-axis)) (:major y-axis)))))))

  (defn- value-projector
    [scale-x scale-y] (fn [[x y]] [(scale-x x) (scale-y y)]))

  (defn svg-plot2d-cartesian
    [{:keys [x-axis y-axis grid data] :as opts}]
    (svg/group
     {}
     (if grid   (svg-axis-grid2d-cartesian x-axis y-axis grid))
     (map (fn [spec] ((:layout spec) opts spec)) data)
     (if (:visible x-axis) (svg-x-axis x-axis))
     (if (:visible y-axis) (svg-y-axis y-axis))))
#+END_SRC

*** Line plot

#+BEGIN_SRC clojure :noweb-ref plot-2d
  (defn svg-line-plot
    [{:keys [x-axis y-axis]} {:keys [values attribs]}]
    (let [scale-x (:scale x-axis)
          scale-y (:scale y-axis)
          [r1 r2] (:range y-axis)
          range'  (if (< r1 r2) [r1 r2] [r2 r1])]
      (svg/line-strip
       (sequence
        (comp
         (filter #(m/in-range? (:domain x-axis) (first %)))
         (map (value-projector scale-x scale-y))
         (filter #(m/in-range? range' (second %))))
        values)
       attribs)))
#+END_SRC

*** Scatter plot

#+BEGIN_SRC clojure :noweb-ref plot-2d
  (defn svg-scatter-plot
    [{:keys [x-axis y-axis]}
     {:keys [values attribs shape]
      :or   {shape #(svg/circle % 3)}}]
    (let [scale-x (:scale x-axis)
          scale-y (:scale y-axis)
          [r1 r2] (:range y-axis)
          range'  (if (< r1 r2) [r1 r2] [r2 r1])]
      (svg/group
       attribs
       (sequence
        (comp
         (filter #(m/in-range? (:domain x-axis) (first %)))
         (map (value-projector scale-x scale-y))
         (filter #(m/in-range? range' (second %)))
         (map shape))
        values))))
#+END_SRC

*** Contour lines

#+BEGIN_SRC clojure :noweb-ref plot-2d
  (defn contour-matrix
    [w h values]
    (let [mat (nd/ndarray :float32 values [h w])]
      (contours/set-border2d mat 1e9)))

  (defn contour->svg
    [scale-x scale-y]
    (fn [contour]
      (-> (map (fn [[y x]] [(scale-x x) (scale-y y)]) contour)
          (svg/polygon))))

  (defn svg-contour-plot
    [{:keys [x-axis y-axis]}
     {:keys [matrix attribs levels]}]
    (let [contour-fn (contour->svg (:scale x-axis) (:scale y-axis))]
      (svg/group
       attribs
       (map
        #(svg/group {} (map contour-fn (contours/find-contours2d matrix %)))
        (sort levels)))))
#+END_SRC

*** Stacked intervals

#+BEGIN_SRC clojure :noweb-ref plot-2d
  (defn overlap? [[a b] [c d]] (and (<= a d) (>= b c)))

  (defn compute-row-stacking
    [item-range coll]
    (reduce
     (fn [grid x]
       (let [r (item-range x)]
         (loop [[row & more] grid idx 0]
           (if (or (nil? row) (not (some #(overlap? r (item-range %)) row)))
             (update-in grid [idx] #(conj (or % []) x))
             (recur more (inc idx))))))
     [] coll))

  (defn svg-stacked-interval-plot
    [{:keys [x-axis y-axis]}
     {:keys [values attribs shape item-range]
      :or   {shape (fn [[a b]] (svg/line a b)) item-range identity}}]
    (let [scale-x (:scale x-axis)
          scale-y (:scale y-axis)
          [d1 d2] (:domain x-axis)
          project (value-projector scale-x scale-y)]
      (->> values
           (filter #(overlap? (:domain x-axis) (item-range %)))
           (sort-by (comp first item-range))
           (compute-row-stacking item-range)
           (mapcat
            (fn [i row]
              (map
               (fn [item]
                 (let [[a b] (item-range item)
                       a (max d1 a)
                       b (min d2 b)]
                   [(project [a i]) (project [b i]) item]))
               row))
            (range))
           (map shape)
           (svg/group attribs))))
#+END_SRC

** Helper functions

#+BEGIN_SRC clojure :noweb-ref helpers

#+END_SRC

** Custom shape drawing

#+BEGIN_SRC clojure :noweb-ref shapes
  (defn svg-triangle-up
    [r] (fn [[x y]] (svg/polygon [[(- x r) (+ y r)] [(+ x r) (+ y r)] [x (- y r)]])))

  (defn svg-triangle-down
    [r] (fn [[x y]] (svg/polygon [[(- x r) (- y r)] [(+ x r) (- y r)] [x (+ y r)]])))

  (defn svg-square
    [r] (let [d (* r 2.0)] (fn [[x y]] (svg/rect [(- x r) (- y r)] d d))))
#+END_SRC

** TODO 3D Plotting

TBD

** Complete namespace definitions

#+BEGIN_SRC clojure :tangle ../babel/src/thi/ng/geom/viz/core.cljc :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.viz.core
    (:require
     [thi.ng.geom.core :as g]
     [thi.ng.geom.svg.core :as svg]
     [thi.ng.ndarray.core :as nd]
     [thi.ng.ndarray.contours :as contours]
     [thi.ng.math.core :as m]
     [thi.ng.strf.core :as f]))

  <<scale>>

  <<axis>>

  <<shapes>>

  <<plot-2d>>
#+END_SRC

