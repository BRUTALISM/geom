#+SETUPFILE: ../../src/setup.org

* Contents                                                         :toc_4_gh:
 - [[#namespace-thinggeomvizcore][Namespace: thi.ng.geom.viz.core]]
     - [[#example-usage][Example usage]]
         - [[#scatter-plot][Scatter plot]]
         - [[#line-plot][Line plot]]
         - [[#stacked-intervals][Stacked intervals]]
         - [[#contour-plot][Contour plot]]
     - [[#visualization-spec-format][Visualization spec format]]
         - [[#axis-definitions-x-axis--y-axis][Axis definitions (:x-axis / :y-axis)]]
         - [[#axis-grid-definition-grid][Axis grid definition (:grid)]]
         - [[#dataset-specs-data][Dataset specs (:data)]]
     - [[#scales][Scales]]
         - [[#linear-scale][Linear scale]]
         - [[#logarithmic-scale][Logarithmic scale]]
     - [[#axis--tick-generators][Axis & tick generators]]
         - [[#svg-axis-generators][SVG axis generators]]
         - [[#linear][Linear]]
         - [[#logarithmic][Logarithmic]]
     - [[#2d-cartesian-plotting-svg][2D Cartesian Plotting (SVG)]]
         - [[#generic-plotting-helpers][Generic plotting helpers]]
         - [[#line-plot][Line plot]]
         - [[#scatter-plot][Scatter plot]]
         - [[#contour-lines][Contour lines]]
         - [[#stacked-intervals][Stacked intervals]]
     - [[#custom-shape-drawing][Custom shape drawing]]
     - [[#todo-3d-plotting][TODO 3D Plotting]]
     - [[#complete-namespace-definition][Complete namespace definition]]

* Namespace: thi.ng.geom.viz.core

** Example usage

This section shows some basic example outputs and general usage
patterns. See spec description in next section for further
information.

*** Scatter plot

| [[http://media.thi.ng/geom/viz/scatter-linear.svg]] | [[http://media.thi.ng/geom/viz/scatter-log.svg]] |

#+BEGIN_SRC clojure :noweb-ref example1
  (require '[thi.ng.geom.viz.core :as viz] :reload)
  (require '[thi.ng.geom.svg.core :as svg])
  (require '[thi.ng.math.core :as m])

  (->> {:x-axis   (viz/log-axis 10 [0.1 201] [50 590] 550)
        :y-axis   (viz/linear-axis [0 100] [550 20] 50 10 1)
        ;;:y-axis   (viz/log-axis 10 [0.1 101] [550 20] 50) ;; Y log axis
        :grid     {:attribs {:stroke "#caa"}
                   :minor-x true
                   :minor-y true}
        :data     [{:values   (map (juxt identity #(Math/sqrt %)) (range 0 200 2))
                    :attribs  {:fill "#0af" :stroke "none"}
                    :layout   viz/svg-scatter-plot}
                   {:values   (map (juxt identity #(m/random %)) (range 0 200 2))
                    :attribs  {:fill "none" :stroke "#f60"}
                    :shape    (viz/svg-triangle-down 3)
                    :layout   viz/svg-scatter-plot}]}
       (viz/svg-plot2d-cartesian)
       (svg/svg {:width 600 :height 600})
       (svg/serialize)
       (spit "scatter.svg"))
#+END_SRC

*** Line plot

[[http://media.thi.ng/geom/viz/lineplot.svg]]

#+BEGIN_SRC clojure :noweb-ref example2
  (require '[thi.ng.geom.viz.core :as viz] :reload)
  (require '[thi.ng.geom.svg.core :as svg])
  (require '[thi.ng.math.core :as m])

  (->> {:x-axis   (viz/linear-axis [(- m/PI) m/PI] [50 590] 250 10 0)
        :y-axis   (viz/linear-axis [-1.1 1.1] [250 20] 50 5 1)
        :grid     {:attribs {:stroke "#caa"}
                   :minor-y true}
        :data     [{:values  (map
                              (fn [t]
                                (let [x (m/mix (- m/PI) m/PI t)
                                      y (* (Math/cos (* 0.5 x)) (Math/sin (* x x x)))]
                                  [x y]))
                              (m/norm-range 200))
                    :attribs {:fill "none" :stroke "#0af"}
                    :layout  viz/svg-line-plot}]}
       (viz/svg-plot2d-cartesian)
       (svg/svg {:width 600 :height 300})
       (svg/serialize)
       (spit "lineplot.svg"))
#+END_SRC

*** Stacked intervals

[[http://media.thi.ng/geom/viz/stacked-intervals.svg]]

#+BEGIN_SRC clojure :noweb-ref example4
  (require '[thi.ng.geom.viz.core :as viz] :reload)
  (require '[thi.ng.geom.svg.core :as svg])
  (require '[thi.ng.math.core :as m])

  (->> {:x-axis   (viz/linear-axis [-10 310] [50 550] 150 10 4)
        :y-axis   (viz/linear-axis [0 4] [50 150] 50 1 0)
        :data     [{:values  [[0 100] [10 90] [80 200] [250 300] [150 170] [110 120]
                              [210 280] [180 280] [160 240] [160 170]]
                    :attribs {:stroke-width "14px" :stroke-linecap "round" :stroke "#0af"}
                    ;; :attribs {:fill "rgba(0,160,255,0.1)" :stroke "#0af"} ;; filled version
                    :layout  viz/svg-stacked-interval-plot}]}
       (viz/svg-plot2d-cartesian)
       (svg/svg
        {:width 600 :height 200}
        (svg/defs
          (svg/linear-gradient-rgb "grad" [0 [0 2/3 1]] [1 [0.75 0.9 1]])))
       (svg/serialize)
       (spit "timeline.svg"))
#+END_SRC

[[http://media.thi.ng/geom/viz/timeline.svg]]

#+BEGIN_SRC clojure :noweb-ref example41
  (require '[thi.ng.geom.viz.core :as viz] :reload)
  (require '[thi.ng.geom.svg.core :as svg])
  (require '[thi.ng.math.core :as m])

  (def ->epoch #(.getTime ^java.util.Date %))

  (def item-cols
    {:project  "#0af"
     :oss      "#63f"
     :workshop "#9f0"
     :talk     "#f9f"})

  (def items
    [{:title "toxiclibs" :from #inst "2006-03" :to #inst "2013-06" :type :oss}
     {:title "thi.ng/geom" :from #inst "2011-08" :to #inst "2015-06" :type :oss}
     {:title "thi.ng/trio" :from #inst "2012-12" :to #inst "2015-06" :type :oss}
     {:title "thi.ng/simplecl" :from #inst "2012-10" :to #inst "2013-05" :type :oss}
     {:title "thi.ng/simplecl" :from #inst "2015-05" :to #inst "2015-06" :type :oss}
     {:title "thi.ng/raymarchcl" :from #inst "2013-02" :to #inst "2013-05" :type :oss}
     {:title "thi.ng/structgen" :from #inst "2012-10" :to #inst "2013-02" :type :oss}
     {:title "thi.ng/luxor" :from #inst "2013-10" :to #inst "2015-06" :type :oss}
     {:title "thi.ng/morphogen" :from #inst "2014-03" :to #inst "2015-06" :type :oss}
     {:title "thi.ng/color" :from #inst "2014-09" :to #inst "2015-06" :type :oss}
     {:title "thi.ng/validate" :from #inst "2014-05" :to #inst "2015-06" :type :oss}
     {:title "thi.ng/ndarray" :from #inst "2015-05" :to #inst "2015-06" :type :oss}
     {:title "thi.ng/tweeny" :from #inst "2013-10" :to #inst "2015-01" :type :oss}
     {:title "Co(De)Factory" :from #inst "2013-12" :to #inst "2014-08" :type :project}
     {:title "Chrome WebLab" :from #inst "2011-05" :to #inst "2012-11" :type :project}
     {:title "ODI" :from #inst "2013-07" :to #inst "2013-10" :type :project}
     {:title "LCOM" :from #inst "2012-06" :to #inst "2013-05" :type :project}
     {:title "V&amp;A Ornamental" :from #inst "2010-12" :to #inst "2011-05" :type :project}
     {:title "Engine26" :from #inst "2010-08" :to #inst "2010-12" :type :project}
     {:title "Resonate" :from #inst "2012-04" :to #inst "2012-04" :type :workshop}
     {:title "Resonate" :from #inst "2013-03" :to #inst "2013-03" :type :workshop}
     {:title "Resonate" :from #inst "2014-04" :to #inst "2014-04" :type :workshop}
     {:title "Resonate" :from #inst "2015-04" :to #inst "2015-04" :type :workshop}
     {:title "Resonate" :from #inst "2012-04" :to #inst "2012-04" :type :talk}
     {:title "Resonate" :from #inst "2013-03" :to #inst "2013-03" :type :talk}
     {:title "Resonate" :from #inst "2014-04" :to #inst "2014-04" :type :talk}
     {:title "Resonate" :from #inst "2015-04" :to #inst "2015-04" :type :talk}
     {:title "Retune" :from #inst "2014-09" :to #inst "2014-09" :type :talk}
     {:title "Bezalel" :from #inst "2011-04" :to #inst "2011-04" :type :workshop}
     {:title "V&amp;A" :from #inst "2011-01" :to #inst "2011-03" :type :workshop}
     {:title "HEAD" :from #inst "2010-10" :to #inst "2010-10" :type :workshop}
     {:title "ETH" :from #inst "2010-11" :to #inst "2010-11" :type :workshop}
     {:title "SAC" :from #inst "2012-11" :to #inst "2012-11" :type :workshop}
     {:title "SAC" :from #inst "2014-12-02" :to #inst "2014-12-06" :type :workshop}
     {:title "MSA" :from #inst "2013-04" :to #inst "2013-04" :type :workshop}
     {:title "Young Creators" :from #inst "2014-06" :to #inst "2014-06" :type :workshop}
     {:title "EYEO" :from #inst "2013-06" :to #inst "2013-06" :type :talk}
     {:title "Reasons" :from #inst "2014-02" :to #inst "2014-02" :type :talk}
     {:title "Reasons" :from #inst "2014-09" :to #inst "2014-09" :type :talk}])

  (->> {:x-axis   (viz/linear-axis [(->epoch #inst "2010-09") (->epoch #inst "2015-06")] [50 950] 200 1 11)
        :y-axis   (viz/linear-axis [0 9] [50 200] 50 1 0)
        :grid     {:minor-x true}
        :data     [{:values     items
                    :item-range (fn [x] [(->epoch (:from x)) (->epoch (:to x))])
                    :attribs    {:fill "white" :stroke-width "14px" :stroke-linecap "round"
                                 :font-family "Arial" :font-size 10}
                    :shape      (fn [[[ax ay :as a] [bx :as b] item]]
                                  (svg/group
                                   {}
                                   (svg/line a b {:stroke (item-cols (:type item))})
                                   (if (< 30 (- bx ax))
                                     (svg/text [ax (+ 3 ay)] (:title item) {:stroke "none"}))))
                    :layout  viz/svg-stacked-interval-plot}]}
       (viz/svg-plot2d-cartesian)
       (svg/svg
        {:width 960 :height 250}
        (svg/defs
          (svg/linear-gradient-rgb "grad" [0 [0 2/3 1]] [1 [0.75 0.9 1]])))
       (svg/serialize)
       (spit "timeline.svg"))
#+END_SRC

*** Contour plot

| [[http://media.thi.ng/geom/viz/contours.svg]] | [[http://media.thi.ng/geom/viz/contours-outline.svg]] |

#+BEGIN_SRC clojure :noweb-ref example3
  (require '[thi.ng.geom.viz.core :as viz] :reload)
  (require '[thi.ng.geom.svg.core :as svg])
  (require '[thi.ng.math.core :as m])
  (require '[thi.ng.math.simplexnoise :as n])

  (->> {:x-axis   (viz/linear-axis [0 64] [50 550] 550 5 3)
        :y-axis   (viz/linear-axis [0 64] [550 50] 50 5 3)
        ;; :x-axis   (viz/log-axis 2 [0 64] [50 550] 555)
        ;; :y-axis   (viz/log-axis 2 [0 64] [550 50] 45)
        :data     [{:matrix  (->> (for [y (range 64) x (range 64)]
                                    (+ 0.5 (* 0.5 (n/noise2 (* x 0.06) (* y 0.06)))))
                                  (viz/contour-matrix 64 64))
                    :levels  (range 0.05 1 0.05)
                    :attribs {:fill "none" :stroke "#0af"}
                    ;; :attribs {:fill "rgba(0,160,255,0.05)" :stroke "#0af"} ;; filled version
                    :layout  viz/svg-contour-plot}]}
       (viz/svg-plot2d-cartesian)
       (svg/svg {:width 600 :height 600})
       (svg/serialize)
       (spit "contours.svg"))
#+END_SRC

** Visualization spec format

| *Key*     | *Value*                  | *Required* | *Description*                             |
|-----------+--------------------------+------------+-------------------------------------------|
| =:x-axis= | horizontal axis spec map | Y          | X-axis behavior & representation details  |
| =:y-axis= | vertical axis spec map   | Y          | Y-axis behavior & representation details  |
| =:grid=   | grid spec map            | N          | Optional background axis grid             |
| =:data=   | vector of dataset specs  | Y          | Allows multiple datasets in visualization |

*** Axis definitions (:x-axis / :y-axis)

| *Key*     | *Value*              | *Required* | *Default* | *Description*                                                            |
|-----------+----------------------+------------+-----------+--------------------------------------------------------------------------|
| =:scale=  | scale function       | Y          | nil       | Scale function to translate domain values into visualization coordinates |
| =:domain= | vec of domain bounds | Y          | nil       | Lower & upper bound of data source interval                              |
| =:range=  | vec of range bounds  | Y          | nil       | Lower & upper bound of projected coordinates                             |
| =:major=  | seq of domain values | N          | nil       | Seq of domain positions at which to draw labeled tick marks              |
| =:minor=  | seq of domain values | N          | nil       | Seq of domain positions at which                                         |

*** Axis grid definition (:grid)

| *Key*      | *Value* | *Required* | *Default*     | *Description*                                            |
|------------+---------+------------+---------------+----------------------------------------------------------|
| =:attribs= | hashmap | N          | default style | allows extra attributes to be injected (e.g. for SVG)    |
| =:minor-x= | boolean | N          | false         | if =false= only uses major tick mark positions on X axis |
| =:minor-y= | boolean | N          | false         | if =false= only uses major tick mark positions on Y axis |

*** Dataset specs (:data)

The format of these maps is largely dependent on the concrete
visualization methods used, but must state the following keys:

| *Key*     | *Value*         | *Required* | *Default* | *Description*               |
|-----------+-----------------+------------+-----------+-----------------------------|
| =:layout= | layout function | Y          | none      | function to map data points |

** Scales

*** Linear scale

#+BEGIN_SRC clojure :noweb-ref scale
  (defn linear-scale
    [domain range]
    (fn [x] (m/map-interval x domain range)))
#+END_SRC

*** Logarithmic scale

#+BEGIN_SRC clojure :noweb-ref scale
  (defn log
    [base]
    (let [lb (Math/log base)]
      #(/ (cond
            (pos? %) (Math/log %)
            (neg? %) (- (Math/log (- %)))
            :else 0)
          lb)))

  (defn log-scale
    [base [d1 d2 :as domain] [r1 r2 :as range]]
    (let [log* (log base)
          d1l  (log* d1)
          dr   (- (log* d2) d1l)]
      (fn [x] (m/mix r1 r2 (/ (- (log* x) d1l) dr)))))
#+END_SRC

** Axis & tick generators

*** SVG axis generators

#+BEGIN_SRC clojure :noweb-ref axis
  (defn tick-value
    [x] (m/roundto x (if (< (m/abs x) 1) 0.01 1)))

  (defn svg-axis*
    [{:keys [major minor]} a b align tick1-fn tick2-fn]
    (svg/group
     {:stroke "black"}
     (svg/group
      {:fill "black"
       :font-family "Arial"
       :font-size 10
       :text-anchor align}
      (mapcat tick1-fn major))
     (svg/group
      {:stroke "#333"}
      (map tick2-fn minor))
     (svg/line a b)))

  (defn svg-x-axis
    [{:keys [scale major minor pos] [r1 r2] :range :as spec}]
    (svg-axis*
     spec [r1 pos] [r2 pos] "start"
     #(let [x (scale %)]
        [(svg/line [x pos] [x (+ pos 10)]) (svg/text [x (+ pos 20)] (tick-value %) {:stroke "none"})])
     #(let [x (scale %)]
        (svg/line [x pos] [x (+ pos 5)]))))

  (defn svg-y-axis
    [{:keys [scale major minor pos] [r1 r2] :range :as spec}]
    (svg-axis*
     spec [pos r1] [pos r2] "end"
     #(let [y (scale %)]
        [(svg/line [pos y] [(- pos 10) y]) (svg/text [(- pos 15) y] (tick-value %) {:stroke "none"})])
     #(let [y (scale %)]
        (svg/line [pos y] [(- pos 5) y]))))
#+END_SRC

*** Linear

#+BEGIN_SRC clojure :noweb-ref axis
  (defn lin-tick-marks
    [[d1 d2] n]
    (let [dr (- d2 d1)
          lr (Math/pow 10 (m/roundto (/ (Math/log dr) (Math/log 10)) 1))
          delta (/ lr n)
          d1' (m/roundto d1 delta)]
      (filter #(m/in-range? d1 d2 %) (range d1' (+ d2 delta) delta))))

  (defn linear-axis
    [domain range pos major minor]
    (let [major' (lin-tick-marks domain major)
          minor' (lin-tick-marks domain (* major (inc minor)))
          minor' (filter (complement (set major')) minor')]
      {:scale  (linear-scale domain range)
       :major  major'
       :minor  minor'
       :domain domain
       :range  range
       :pos    pos}))
#+END_SRC

*** Logarithmic

#+BEGIN_SRC clojure :noweb-ref axis
  (defn log-ticks-domain
    [base d1 d2]
    (let [log* (log base)] [(m/floor (log* d1)) (m/ceil (log* d2))]))

  (defn log-tick-marks-major
    [base [d1 d2]]
    (let [[d1l d2l] (log-ticks-domain base d1 d2)]
      (->> (for [i (range d1l (inc d2l))]
             (if (>= i 0)
               (* (/ 1 base) (Math/pow base i))
               (* (/ 1 base) (- (Math/pow base (- i))))))
           (filter #(m/in-range? d1 d2 %)))))

  (defn log-tick-marks-minor
    [base [d1 d2]]
    (let [[d1l d2l] (log-ticks-domain base d1 d2)
          ticks (if (== 2 base) [0.75] (range 2 base))]
      (->> (for [i (range d1l (inc d2l)) j ticks]
             (if (>= i 0)
               (* (/ j base) (Math/pow base i))
               (* (/ j base) (- (Math/pow base (- i))))))
           (filter #(m/in-range? d1 d2 %)))))

  (defn log-axis
    [base domain range pos]
    {:scale (log-scale base domain range)
     :major (log-tick-marks-major base domain)
     :minor (log-tick-marks-minor base domain)
     :domain domain
     :range range
     :pos pos})
#+END_SRC

** 2D Cartesian Plotting (SVG)

*** Generic plotting helpers

#+BEGIN_SRC clojure :noweb-ref plot-2d
  (defn svg-axis-grid2d-cartesian
    [x-axis y-axis {:keys [attribs minor-x minor-y]}]
    (let [[x1 x2] (:range x-axis)
          [y1 y2] (:range y-axis)
          scale-x (:scale x-axis)
          scale-y (:scale y-axis)]
      (svg/group
       (merge {:stroke "#ccc" :stroke-dasharray "1 1"} attribs)
       (map #(let [x (scale-x %)] (svg/line [x y1] [x y2]))
            (if minor-x (concat (:minor x-axis) (:major x-axis)) (:major x-axis)))
       (map #(let [y (scale-y %)] (svg/line [x1 y] [x2 y]))
            (if minor-y (concat (:minor y-axis) (:major y-axis)) (:major y-axis))))))

  (defn- value-projector
    [scale-x scale-y] (fn [[x y]] [(scale-x x) (scale-y y)]))

  (defn svg-plot2d-cartesian
    [{:keys [x-axis y-axis grid data] :as opts}]
    (svg/group
     {}
     (if grid   (svg-axis-grid2d-cartesian x-axis y-axis grid))
     (map (fn [spec] ((:layout spec) opts spec)) data)
     (if x-axis (svg-x-axis x-axis))
     (if y-axis (svg-y-axis y-axis))))
#+END_SRC

*** Line plot

#+BEGIN_SRC clojure :noweb-ref plot-2d
  (defn svg-line-plot
    [{:keys [x-axis y-axis]} {:keys [values attribs]}]
    (let [scale-x (:scale x-axis)
          scale-y (:scale y-axis)
          [r1 r2] (:range y-axis)
          range'  (if (< r1 r2) [r1 r2] [r2 r1])]
      (svg/line-strip
       (sequence
        (comp
         (filter #(m/in-range? (:domain x-axis) (first %)))
         (map (value-projector scale-x scale-y))
         (filter #(m/in-range? range' (second %))))
        values)
       attribs)))
#+END_SRC

*** Scatter plot

#+BEGIN_SRC clojure :noweb-ref plot-2d
  (defn svg-scatter-plot
    [{:keys [x-axis y-axis]}
     {:keys [values attribs shape]
      :or   {shape #(svg/circle % 3)}}]
    (let [scale-x (:scale x-axis)
          scale-y (:scale y-axis)
          [r1 r2] (:range y-axis)
          range'  (if (< r1 r2) [r1 r2] [r2 r1])]
      (svg/group
       attribs
       (sequence
        (comp
         (filter #(m/in-range? (:domain x-axis) (first %)))
         (map (value-projector scale-x scale-y))
         (filter #(m/in-range? range' (second %)))
         (map shape))
        values))))
#+END_SRC

*** Contour lines

#+BEGIN_SRC clojure :noweb-ref plot-2d
  (defn contour-matrix
    [w h values]
    (let [mat (nd/ndarray :float32 values [h w])]
      (contours/set-border2d mat 1e9)))

  (defn contour->svg
    [scale-x scale-y]
    (fn [contour]
      (-> (map (fn [[y x]] [(scale-x x) (scale-y y)]) contour)
          (svg/polygon))))

  (defn svg-contour-plot
    [{:keys [x-axis y-axis]}
     {:keys [matrix attribs levels]}]
    (let [contour-fn (contour->svg (:scale x-axis) (:scale y-axis))]
      (svg/group
       attribs
       (map
        #(svg/group {} (map contour-fn (contours/find-contours2d matrix %)))
        (sort levels)))))
#+END_SRC

*** Stacked intervals

#+BEGIN_SRC clojure :noweb-ref plot-2d
  (defn overlap? [[a b] [c d]] (and (<= a d) (>= b c)))

  (defn compute-row-stacking
    [item-range coll]
    (reduce
     (fn [grid x]
       (let [r (item-range x)]
         (loop [[row & more] grid idx 0]
           (if (or (nil? row) (not (some #(overlap? r (item-range %)) row)))
             (update-in grid [idx] #(conj (or % []) x))
             (recur more (inc idx))))))
     [] coll))

  (defn svg-stacked-interval-plot
    [{:keys [x-axis y-axis]}
     {:keys [values attribs shape item-range]
      :or   {shape (fn [[a b]] (svg/line a b)) item-range identity}}]
    (let [scale-x (:scale x-axis)
          scale-y (:scale y-axis)
          [d1 d2] (:domain x-axis)
          project (value-projector scale-x scale-y)]
      (->> values
           (filter #(overlap? (:domain x-axis) (item-range %)))
           (sort-by (comp first item-range))
           (compute-row-stacking item-range)
           (mapcat
            (fn [i row]
              (map
               (fn [item]
                 (let [[a b] (item-range item)
                       a (max d1 a)
                       b (min d2 b)]
                   [(project [a i]) (project [b i]) item]))
               row))
            (range))
           (map shape)
           (svg/group attribs))))
#+END_SRC

** Custom shape drawing

#+BEGIN_SRC clojure :noweb-ref shapes
  (defn svg-triangle-up
    [r] (fn [[x y]] (svg/polygon [[(- x r) (+ y r)] [(+ x r) (+ y r)] [x (- y r)]])))

  (defn svg-triangle-down
    [r] (fn [[x y]] (svg/polygon [[(- x r) (- y r)] [(+ x r) (- y r)] [x (+ y r)]])))

  (defn svg-square
    [r] (let [d (* r 2.0)] (fn [[x y]] (svg/rect [(- x r) (- y r)] d d))))
#+END_SRC

** TODO 3D Plotting

TBD

** Complete namespace definition

#+BEGIN_SRC clojure :tangle ../babel/src/thi/ng/geom/viz/core.cljc :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.viz.core
    (:require
     [thi.ng.geom.core :as g]
     [thi.ng.geom.svg.core :as svg]
     [thi.ng.ndarray.core :as nd]
     [thi.ng.ndarray.contours :as contours]
     [thi.ng.math.core :as m]))

  <<scale>>

  <<axis>>

  <<shapes>>

  <<plot-2d>>
#+END_SRC
