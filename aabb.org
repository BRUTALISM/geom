#+SEQ_TODO:       TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:           Write(w) Update(u) Fix(f) Check(c) noexport(n)
#+EXPORT_EXCLUDE_TAGS: noexport

* thi.ng.geom.aabb
** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/aabb.cljx :mkdirp yes :padline no
  (ns thi.ng.geom.aabb
    (:refer-clojure :exclude [+ - * min max])
    (:refer-clojure :rename {+ c+, - c-, * c*, min cmin, max cmax})
    (:require
     [thi.ng.common.math.core :as m :refer [*eps*]]
     [thi.ng.geom.core :as g :refer [+ - * vec3 min max]]
     [thi.ng.geom.mesh :as mesh]
     [thi.ng.geom.types :as types])
    ,#+clj
    (:import
     [thi.ng.geom.types Line3 AABB Sphere]))
#+END_SRC
** Constructors
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/aabb.cljx
  (defn aabb
    ([] (thi.ng.geom.types.AABB. (vec3 0.0) (vec3 1.0)))
    ([size] (thi.ng.geom.types.AABB. (vec3 0.0) (vec3 size)))
    ([o size] (thi.ng.geom.types.AABB. (vec3 o) (vec3 size)))
    ([sx sy sz] (thi.ng.geom.types.AABB. (vec3 0.0) (vec3 sx sy sz))))

  (defn aabb-from-minmax
    [p q]
    (let [a (min p q) b (max p q)]
      (thi.ng.geom.types.AABB. a (- b a))))
#+END_SRC
** Type specific functions
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/aabb.cljx

#+END_SRC
** Protocol implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/aabb.cljx
  (extend-type thi.ng.geom.types.AABB
#+END_SRC
*** PGraph
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/aabb.cljx
  g/PGraph
  (vertices
   [{a :p size :size}]
   (let [[x1 y1 z1] a
         [x2 y2 z2 :as g] (+ a size)
         b (vec3 x1 y2 z1) c (vec3 x1 y2 z2)
         d (vec3 x1 y1 z2) e (vec3 x2 y1 z1)
         f (vec3 x2 y2 z1) h (vec3 x2 y1 z2)]
     [a b c d e f g h]))
  (edges
   [_]
   (let [[a b c d e f g h] (g/vertices _)]
     (for [[p q] [[a b] [b c] [c d] [d a] ;; left
                  [a e] [b f]             ;; back
                  [e f] [f g] [g h] [h e] ;; right
                  [c g] [d h]             ;; front
                  ]]
       (thi.ng.geom.types.Line3. p q))))
#+END_SRC
*** PBoundary
**** TODO implement closest-point
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/aabb.cljx
  g/PClassify
  (classify-point
   [{p :p size :size} [x y z :as q]]
   (let [[x1 y1 z1] p
         [x2 y2 z2] (+ p size)
         on-plane? (fn [[minp maxp p min1 max1 min2 max2 c1 c2]]
                     (and (or (m/delta= minp p *eps*)
                              (m/delta= maxp p *eps*))
                          (m/in-range? min1 max1 c1)
                          (m/in-range? min2 max2 c2)))]
     (if (some on-plane?
               [[x1 x2 x y1 y2 z1 z2 y z]
                [y1 y2 y x1 x2 z1 z2 x z]
                [z1 z2 z x1 x2 y1 y2 x y]])
       0
       (if (and (m/in-range? x1 x2 x)
                (m/in-range? y1 y2 y)
                (m/in-range? z1 z2 z))
         1 -1))))
  g/PBoundary
  (contains-point?
   [{p :p size :size} [qx qy qz]]
   (let [[x1 y1 z1] p
         [x2 y2 z2] (+ p size)]
     (and (m/in-range? x1 x2 qx)
          (m/in-range? y1 y2 qy)
          (m/in-range? z1 z2 qz))))
#+END_SRC
*** PSampleable
**** TODO implement point-at
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/aabb.cljx
  g/PSampleable
  (random-point-inside
   [{p :p size :size}]
   (let [[x1 y1 z1] p
         [x2 y2 z2] (+ p size)]
     (vec3 (m/random x1 x2) (m/random y1 y2) (m/random z1 z2))))
  (random-point
   [{p :p size :size}]
   (let [[x1 y1 z1] p
         [x2 y2 z2] (+ p size)
         id (int (m/random 6))]
     (cond
      (< id 2) (vec3 (if (zero? id) x1 x2) (m/random y1 y2) (m/random z1 z2))
      (< id 4) (vec3 (m/random x1 x2) (if (= 2 id) y1 y2) (m/random z1 z2))
      :default (vec3 (m/random x1 x2) (m/random y1 y2) (if (= 4 id) z1 z2)))))
#+END_SRC
*** PArea
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/aabb.cljx
  g/PArea
  (area [{[w h d] :size}] (c* 2 (c+ (c+ (c* w h) (c* d h)) (c* w d))))
#+END_SRC
*** PBounds
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/aabb.cljx
  g/PBounds
  (bounds [_] _)
  (width [_] ((:size _) 0))
  (height [_] ((:size _) 1))
  (depth [_] ((:size _) 2))
#+END_SRC
*** PCenter
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/aabb.cljx
  g/PCenter
  (center
   ([{p :p size :size}]
      (thi.ng.geom.types.AABB. (- p (* size 0.5)) size))
   ([{size :size} q]
      (thi.ng.geom.types.AABB. (- q (* size 0.5)) size)))
  (centroid [_] (+ (:p _) (* (:size _) 0.5)))
#+END_SRC
*** PBoundingSphere
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/aabb.cljx
  g/PBoundingSphere
  (bounding-sphere
   [{p :p size :size}]
   (let [e (* size 0.5)]
     (g/bounding-sphere* (+ p e) (g/mag e))))
#+END_SRC
*** PVolume
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/aabb.cljx
  g/PVolume
  (volume [{[w h d] :size}] (c* (c* w h) d))
#+END_SRC
*** PIntersectable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/aabb.cljx
  g/PIntersectable
  (intersect-shape
   [{pa :p sa :size} s]
   (cond
    (instance? thi.ng.geom.types.AABB s)
    (let [{pb :p sb :size} s]
      (every?
       #(and (<= (pa %) (c+ (pb %) (sb %)))
             (<= (pb %) (c+ (pa %) (sa %))))
       [0 1 2]))
    :default (g/type-error "AABB" s)))
#+END_SRC
*** TODO PMeshable
**** TODO add face flags as in gmesh/box
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/aabb.cljx
  g/PMeshable
  (as-mesh
   [_]
   (let [[a b c d e f g h] (g/vertices _)]
     (mesh/mesh3
      [a c b] [a d c] ;left
      [d g c] [d h g] ;front
      [h f g] [h e f] ;right
      [e b f] [e a b] ;back
      [c f b] [c g f] ;top
      [e h d] [e d a]))) ; bottom
#+END_SRC
*** End of implementation                                          :noexport:
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/aabb.cljx
  )
#+END_SRC
