#+SEQ_TODO:       TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:           Write(w) Update(u) Fix(f) Check(c) noexport(n)
#+EXPORT_EXCLUDE_TAGS: noexport

* thi.ng.geom.test.core
** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/spec/thi/ng/geom/test/core.clj :mkdirp yes :padline no
  (ns thi.ng.geom.test.core
    (:refer-clojure :exclude [+ - * min max])
    (:refer-clojure :rename {+ c+, - c-, * c*, min cmin, max cmax})
    (:require
     [thi.ng.common.math.core :as m :refer [*eps*]]
     [thi.ng.geom.core :as g :refer [+ - * vec2 vec3 min max]]
     [thi.ng.geom.types :as types]
     [speclj.core :refer :all]))
#+END_SRC
** Vector creation
#+BEGIN_SRC clojure :tangle babel/spec/thi/ng/geom/test/core.clj
  (describe "Vector creation"
#+END_SRC
*** 2d
#+BEGIN_SRC clojure :tangle babel/spec/thi/ng/geom/test/core.clj
  (describe
   "2d"
   (it "vec2?" (g/vec2? (vec2 1)))
   (it "uniform from single number" (should= (vec2 1) [1.0 1.0]))
   (it "two numbers" (should= (vec2 1 2) [1.0 2.0]))
   (it "single 2-vector" (should= (vec2 [1 2]) [1.0 2.0]))
   (it "single 3-vector" (should= (vec2 [1 2 3]) [1.0 2.0]))
   (it "single :x/:y map" (should= (vec2 {:x 1 :y 2}) [1.0 2.0]))
   (it "single :x map" (should= (vec2 {:x 1}) [1.0 0.0]))
   (it "single :y map" (should= (vec2 {:y 2}) [0.0 2.0]))
   (it "single empty map" (should= (vec2 {}) [0.0 0.0]))
   (it "fail w/ str arg v2" (should-throw (vec2 "a")))
   (it "fail w/ [str] arg v2" (should-throw (vec2 ["a"])))
   (it "fail w/ str map v2" (should-throw (vec2 {:x "a"})))
   (it "fail w/ str args v2" (should-throw (vec2 "a" "a"))))
#+END_SRC
*** 3d
#+BEGIN_SRC clojure :tangle babel/spec/thi/ng/geom/test/core.clj
  (describe
   "3d"
   (it "vec3?" (g/vec3? (vec3 1)))
   (it "uniform from single number" (should= (vec3 1) [1.0 1.0 1.0]))
   (it "2 numbers" (should= (vec3 1 2) [1.0 2.0 0.0]))
   (it "3 numbers" (should= (vec3 1 2 3) [1.0 2.0 3.0]))
   (it "single 2-vector" (should= (vec3 [1 2]) [1.0 2.0 0.0]))
   (it "single 3-vector" (should= (vec3 [1 2 3]) [1.0 2.0 3.0]))
   (it "single :x :y map" (should= (vec3 {:x 1 :y 2}) [1.0 2.0 0.0]))
   (it "single :x :y :z map" (should= (vec3 {:x 1 :y 2 :z 3.0}) [1.0 2.0 3.0]))
   (it "single :x map" (should= (vec3 {:x 1}) [1.0 0.0 0.0]))
   (it "single :y map" (should= (vec3 {:y 2}) [0.0 2.0 0.0]))
   (it "single :z map" (should= (vec3 {:z 3}) [0.0 0.0 3.0]))
   (it "single empty map" (should= (vec3 {}) [0.0 0.0 0.0]))
   (it "fail w/ str arg v3" (should-throw (vec3 "a")))
   (it "fail w/ [str] arg v3" (should-throw (vec3 ["a"])))
   (it "fail w/ str map v3" (should-throw (vec3 {:x "a"})))
   (it "fail w/ str args v3" (should-throw (vec3 "a" "a"))))
#+END_SRC
#+BEGIN_SRC clojure :tangle babel/spec/thi/ng/geom/test/core.clj
   )
#+END_SRC
** Swizzling
#+BEGIN_SRC clojure :tangle babel/spec/thi/ng/geom/test/core.clj
  (describe
   "Vector swizzling"
   (with v2 (vec2 1 2))
   (with v3 (vec3 1 2 3))
  
   (describe
    "reading..."
    (it ":x" (should (= 1.0 (:x @v2) (:x @v3))))
    (it ":y" (should (= 2.0 (:y @v2) (:y @v3))))
    (it ":z" (should= 3.0 (:z @v3)))
    (it ":z fail v2" (should-throw (:z @v2)))
    (it ":xy v2=v3" (should= (:xy @v2) (:xy @v3)))
    (it ":xy" (should= (:xy @v2) [1.0 2.0]))
    (it ":yx v2=v3" (should= (:yx @v2) (:yx @v3)))
    (it ":yx" (should= (:yx @v2) [2.0 1.0]))
    (it ":yy v2=v3" (should= (:yy @v2) (:yy @v3)))
    (it ":yy" (should= (:yy @v2) [2.0 2.0]))
    (it ":yy" (should= (:yy @v3) [2.0 2.0]))
    (it ":yz" (should= (:yz @v3) [2.0 3.0]))
    (it ":xyz fail v2" (should-throw (:xyz @v2)))
    (it ":xyz v3" (should= (:xyz @v3) [1.0 2.0 3.0]))
    (it ":zxy v3" (should= (:zxy @v3) [3.0 1.0 2.0]))
    (it "idx 0" (should= (@v2 0) (@v3 0)))
    (it "idx 1" (should= (@v2 1) (@v3 1)))
    (it "idx 2" (should= (@v3 2) 3.0))
    (it "idx 2 fail v2" (should-throw (@v2 2)))
    (it "idx 3 fail v3" (should-throw (@v3 3)))
    )
  
   (describe
    "writing..."
    (it ":x" (should= (assoc @v2 :x 10) [10.0 2.0]))
    (it ":x" (should= (assoc @v3 :x 10) [10.0 2.0 3.0]))
    (it ":y" (should= (assoc @v2 :y 20) [1.0 20.0]))
    (it ":y" (should= (assoc @v3 :y 20) [1.0 20.0 3.0]))
    (it ":z" (should= (assoc @v3 :z 30) [1.0 2.0 30.0]))
    (it ":xy" (should= (assoc @v2 :xy [10 20]) [10.0 20.0]))
    (it ":xy" (should= (assoc @v3 :xy [10 20]) [10.0 20.0 3.0]))
    (it ":yx" (should= (assoc @v2 :yx [10 20]) [20.0 10.0]))
    (it ":yx" (should= (assoc @v3 :yx [10 20]) [20.0 10.0 3.0]))
    (it ":xz" (should= (assoc @v3 :xz [10 20]) [10.0 2.0 20.0]))
    (it ":xz fail 2d" (should-throw (assoc @v2 :xz [10 20])))
    (it ":zx" (should= (assoc @v3 :zx [10 20]) [20.0 2.0 10.0]))
    (it ":zx fail 2d" (should-throw (assoc @v2 :zx [10 20])))
    (it ":yz" (should= (assoc @v3 :yz [10 20]) [1.0 10.0 20.0]))
    (it ":yz fail 2d" (should-throw (assoc @v2 :yz [10 20])))
    (it ":zy" (should= (assoc @v3 :zy [10 20]) [1.0 20.0 10.0]))
    (it ":zy fail 2d" (should-throw (assoc @v2 :zy [10 20])))
    (it ":xyz fail 2d" (should-throw (assoc @v2 :xyz [10 20 30])))
    (it ":xyz fail 3d" (should-throw (assoc @v3 :xyz [10 20 30])))
    ))
#+END_SRC
** Clojure/Java protocol impls
#+BEGIN_SRC clojure :tangle babel/spec/thi/ng/geom/test/core.clj
  (describe
   "Protocol impls"
  
   (with v2 (vec2 1 2))
   (with v3 (vec3 1 2 3))
  
   (it "meta v2" (should= {:foo "bar"} (meta (with-meta @v2 {:foo "bar"}))))
   (it "meta v3" (should= {:foo "bar"} (meta (with-meta @v3 {:foo "bar"}))))
   (it "seq v2" (should= (seq @v2) (seq '(1.0 2.0))))
   (it "rseq v2" (should= (rseq @v2) (rseq [1.0 2.0])))
   (it "rseq a vec2?" (should (g/vec2? (rseq @v2))))
   (it "seq v3" (should= (seq @v3) (seq '(1.0 2.0 3.0))))
   (it "rseq v3" (should= (rseq @v3) (rseq [1.0 2.0 3.0])))
   (it "rseq a vec3?" (should (g/vec3? (rseq @v3))))
   (it "first v2" (should= 1.0 (first @v2)))
   (it "first v3" (should= 1.0 (first @v3)))
   (it "rest v2" (should= (rest @v2) [2.0]))
   (it "next v2" (should= (next @v2) [2.0]))
   (it "nnext v2 nil?" (should-be-nil (nnext @v2)))
   (it "rest v3" (should= (rest @v3) [2.0 3.0]))
   (it "next v3" (should= (next @v3) [2.0 3.0]))
   (it "nnext v3" (should= (nnext @v3) [3.0]))
   (it "nnext v3 nil?" (should-be-nil (next (nnext @v2))))
   (it "nth v2" (should= 2.0 (nth @v2 1)))
   (it "nth v2 default" (should= -1 (nth @v2 2 -1)))
   (it "nth v2 fail" (should-throw (nth @v2 2)))
   (it "nth v3" (should= 3.0 (nth @v3 2)))
   (it "nth v3 default" (should= -1 (nth @v3 3 -1)))
   (it "nth v3 fail" (should-throw (nth @v3 3)))
   (it "peek v2" (should= 2.0 (peek @v2)))
   (it "peek v3" (should= 3.0 (peek @v3)))
   (it "pop v2" (should= (pop @v2) [1.0]))
   (it "pop v2 type" (should= (type (pop @v2)) clojure.lang.PersistentVector))
   (it "pop v3" (should= (pop @v3) [1.0 2.0]))
   (it "pop v3 vec2?" (should (g/vec2? (pop @v3))))
   (it "destructure v2" (should (let [[x y z] @v2] (and (= @v2 [x y]) (nil? z)))))
   (it "destructure v3" (should (let [[x y z w] @v3] (and (= @v3 [x y z]) (nil? w)))))
   (it "contains keys v2" (should (every? #(contains? @v2 %) [:x :y 0 1])))
   (it "contains keys v3" (should (every? #(contains? @v3 %) [:x :y :z 0 1 2])))
   (it "vec = v2" (should= [1.0 2.0] @v2))
   (it "seq = v2" (should= (seq @v2) @v2))
   (it "vec = v3" (should= [1.0 2.0 3.0] @v3))
   (it "seq = v3" (should= (seq @v3) @v3))
   (it "v2 != v3" (should-not= @v2 @v3))
   (it "v3 != v2" (should-not= @v3 @v2))
   (it "v2 != rseq" (should-not= @v2 (rseq @v2)))
   (it "v3 != rseq" (should-not= @v3 (rseq @v3)))
   (it "v2 != x" (should-not= @v2 1))
   (it "v3 != x" (should-not= @v3 1))
   (it "#{v2 a2}" (should= 2 (count (into #{} [@v2 [1.0 2.0] @v2]))))
   (it "#{v3 a3}" (should= 2 (count (into #{} [@v3 [1.0 2.0 3.0] @v3]))))
   (it "count v2" (should= 2 (count @v2)))
   (it "count v3" (should= 3 (count @v3)))
   (it "size v2" (should= 2 (.size @v2)))
   (it "size v3" (should= 3 (.size @v3)))
   (it "iterator v2" (should= [1.0 2.0] (iterator-seq (.iterator @v2))))
   (it "iterator v3" (should= [1.0 2.0 3.0] (iterator-seq (.iterator @v3))))
   (it "apply v2" (should= 1.0 (apply @v2 [0])))
   (it "apply v2 kw" (should= 2.0 (apply @v2 [:y])))
   (it "apply v2 swizzle" (should= [2.0 1.0] (apply @v2 [:yx])))
   (it "apply v2 w/ default" (should= -1 (apply @v2 [:z -1])))
   (it "apply v2 fail" (should-throw (apply @v2 [:z])))
   (it "apply v3" (should= 1.0 (apply @v3 [0])))
   (it "apply v3 kw" (should= 2.0 (apply @v3 [:y])))
   (it "apply v3 swizzle" (should= [2.0 1.0 3.0] (apply @v3 [:yxz])))
   (it "apply v3 w/ default" (should= -1 (apply @v3 [:w -1])))
   (it "apply v3 fail" (should-throw (apply @v3 [:w])))
   )
#+END_SRC
** Vector algebra
#+BEGIN_SRC clojure :tangle babel/spec/thi/ng/geom/test/core.clj
  (describe
   "Vector algebra"
  
   (with a2 (vec2 1 2))
   (with b2 (vec2 10 20))
   (with a3 (vec3 1 2 3))
   (with b3 (vec3 10 20 30))
  
   (it "+ v2" (should= @a2 (+ @a2)))
   (it "+ v2 b2" (should= [11.0 22.0] (+ @a2 @b2)))
   (it "+ v2 n" (should= [11.0 12.0] (+ @a2 10)))
   (it "+ v2 n m" (should= [11.0 22.0] (+ @a2 10 20)))
   (it "+ v2 b2 m" (should= [31.0 42.0] (+ @a2 @b2 20)))
   (it "+ v2 b2 b2" (should= [21.0 42.0] (+ @a2 @b2 @b2)))
   (it "+ v2 n b2 fail" (should-throw (+ @a2 10 @b2)))
  
   (it "+ v3" (should= @a3 (+ @a3)))
   (it "+ v3 b3" (should= [11.0 22.0 33.0] (+ @a3 @b3)))
   (it "+ v3 n" (should= [11.0 12.0 13.0] (+ @a3 10)))
   (it "+ v3 n m" (should= [11.0 22.0 3.0] (+ @a3 10 20)))
   (it "+ v3 b3 m" (should= [31.0 42.0 53.0] (+ @a3 @b3 20)))
   (it "+ v3 b3 b3" (should= [21.0 42.0 63.0] (+ @a3 @b3 @b3)))
   (it "+ v3 n b3 fail" (should-throw (+ @a3 10 @b3)))
   (it "+ v3 n m o" (should= [11.0 22.0 33.0] (+ @a3 10 20 30)))
   (it "+ v3 b3 n m" (should= [61.0 72.0 83.0] (+ @a3 @b3 20 30)))
   (it "+ v3 b3 b3 m" (should= [51.0 72.0 93.0] (+ @a3 @b3 @b3 30)))
   (it "+ v3 n m b3 fail" (should-throw (+ @a3 10 20 @b3)))
  
   (it "- v2" (should= [-1.0 -2.0] (- @a2)))
   (it "- v2 b2" (should= [-9.0 -18.0] (- @a2 @b2)))
   (it "- v2 n" (should= [-9.0 -8.0] (- @a2 10)))
   (it "- v2 n m" (should= [-9.0 -18.0] (- @a2 10 20)))
   (it "- v2 b2 m" (should= [-29.0 -38.0] (- @a2 @b2 20)))
   (it "- v2 b2 b2" (should= [-19.0 -38.0] (- @a2 @b2 @b2)))
   (it "- v2 n b2 fail" (should-throw (- @a2 10 @b2)))
  
   (it "- v3" (should= [-1.0 -2.0 -3.0] (- @a3)))
   (it "- v3 b3" (should= [-9.0 -18.0 -27.0] (- @a3 @b3)))
   (it "- v3 n" (should= [-9.0 -8.0 -7.0] (- @a3 10)))
   (it "- v3 n m" (should= [-29.0 -28.0 -27.0] (- @a3 10 20))) ;; FIXME shouldn't be component wise unless 3 args given
   (it "- v3 b3 m" (should= [-29.0 -38.0 -47.0] (- @a3 @b3 20)))
   (it "- v3 b3 b3" (should= [-19.0 -38.0 -57.0] (- @a3 @b3 @b3)))
   (it "- v3 n b3 fail" (should-throw (- @a3 10 @b3)))
   (it "- v3 n m o" (should= (- @a3 @b3) (- @a3 10 20 30)))
   (it "- v3 b3 n m" (should= [-59.0 -68.0 -77.0] (- @a3 @b3 20 30)))
   (it "- v3 b3 b3 m" (should= [-49.0 -68.0 -87.0] (- @a3 @b3 @b3 30)))
   (it "- v3 n m b3 fail" (should-throw (- @a3 10 20 @b3)))
  
   (it "* v2" (should= @a2 (* @a2)))
   (it "* v2 b2" (should= [10.0 40.0] (* @a2 @b2)))
   (it "* v2 n" (should= [10.0 20.0] (* @a2 10)))
   (it "* v2 n m" (should= (* @a2 @b2) (* @a2 10 20)))
   (it "* v2 b2 m" (should= [200.0 800.0] (* @a2 @b2 20)))
   (it "* v2 b2 b2" (should= [100.0 800.0] (* @a2 @b2 @b2)))
   (it "* v2 n b2 fail" (should-throw (* @a2 10 @b2)))
  
   (it "* v3" (should= @a3 (* @a3)))
   (it "* v3 b3" (should= [10.0 40.0 90.0] (* @a3 @b3)))
   (it "* v3 n" (should= [10.0 20.0 30.0] (* @a3 10)))
   (it "* v3 n m" (should= [200.0 ] (* @a3 10 20))) ;; FIXME shouldn't be component wise unless 3 args given
   (it "* v3 b3 m" (should= [] (* @a3 @b3 20)))
   (it "* v3 b3 b3" (should= [] (* @a3 @b3 @b3)))
   (it "* v3 n b3 fail" (should-throw (* @a3 10 @b3)))
   (it "* v3 n m o" (should= (* @a3 @b3) (* @a3 10 20 30)))
   (it "* v3 b3 n m" (should= [] (* @a3 @b3 20 30)))
   (it "* v3 b3 b3 m" (should= [] (* @a3 @b3 @b3 30)))
   (it "* v3 n m b3 fail" (should-throw (* @a3 10 20 @b3)))
   )
#+END_SRC
** Trigger tests
#+BEGIN_SRC clojure :tangle babel/spec/thi/ng/geom/test/core.clj
  (run-specs)
#+END_SRC
