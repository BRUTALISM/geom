#+SEQ_TODO:       TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:           Write(w) Update(u) Fix(f) Check(c) noexport(n)
#+EXPORT_EXCLUDE_TAGS: noexport

* thi.ng.geom.test.core
** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/spec/thi/ng/geom/test/core.clj :mkdirp yes :padline no
  (ns thi.ng.geom.test.core
    (:refer-clojure :exclude [+ - * min max])
    (:refer-clojure :rename {+ c+, - c-, * c*, min cmin, max cmax})
    (:require
     [thi.ng.common.math.core :as m :refer [*eps*]]
     [thi.ng.geom.core :as g :refer [+ - * div vec2 vec3 min max]]
     [thi.ng.geom.types :as types]
     [speclj.core :refer :all]))
#+END_SRC
** Vector creation
#+BEGIN_SRC clojure :tangle babel/spec/thi/ng/geom/test/core.clj
  (describe "Vector creation"
#+END_SRC
*** 2d
#+BEGIN_SRC clojure :tangle babel/spec/thi/ng/geom/test/core.clj
  (context
   "2d"
   (it "vec2?" (g/vec2? (vec2 1)))
   (it "uniform from single number" (should= [1.0 1.0] (vec2 1)))
   (it "two numbers" (should= [1.0 2.0] (vec2 1 2)))
   (it "single 2-vector" (should= [1.0 2.0] (vec2 [1 2])))
   (it "single 3-vector" (should= [1.0 2.0] (vec2 [1 2 3])))
   (it "single :x/:y map" (should= [1.0 2.0] (vec2 {:x 1 :y 2})))
   (it "single :x map" (should= [1.0 0.0] (vec2 {:x 1})))
   (it "single :y map" (should= [0.0 2.0] (vec2 {:y 2})))
   (it "single empty map" (should= [0.0 0.0] (vec2 {})))
   (it "fail w/ str arg v2" (should-throw (vec2 "a")))
   (it "fail w/ [str] arg v2" (should-throw (vec2 ["a"])))
   (it "fail w/ str map v2" (should-throw (vec2 {:x "a"})))
   (it "fail w/ str args v2" (should-throw (vec2 "a" "a"))))
#+END_SRC
*** 3d
#+BEGIN_SRC clojure :tangle babel/spec/thi/ng/geom/test/core.clj
  (context
   "3d"
   (it "vec3?" (g/vec3? (vec3 1)))
   (it "uniform from single number" (should= (vec3 1) [1.0 1.0 1.0]))
   (it "2 numbers" (should= (vec3 1 2) [1.0 2.0 0.0]))
   (it "3 numbers" (should= (vec3 1 2 3) [1.0 2.0 3.0]))
   (it "single 2-vector" (should= (vec3 [1 2]) [1.0 2.0 0.0]))
   (it "single 3-vector" (should= (vec3 [1 2 3]) [1.0 2.0 3.0]))
   (it "single :x :y map" (should= (vec3 {:x 1 :y 2}) [1.0 2.0 0.0]))
   (it "single :x :y :z map" (should= (vec3 {:x 1 :y 2 :z 3.0}) [1.0 2.0 3.0]))
   (it "single :x map" (should= (vec3 {:x 1}) [1.0 0.0 0.0]))
   (it "single :y map" (should= (vec3 {:y 2}) [0.0 2.0 0.0]))
   (it "single :z map" (should= (vec3 {:z 3}) [0.0 0.0 3.0]))
   (it "single empty map" (should= (vec3 {}) [0.0 0.0 0.0]))
   (it "fail w/ str arg v3" (should-throw (vec3 "a")))
   (it "fail w/ [str] arg v3" (should-throw (vec3 ["a"])))
   (it "fail w/ str map v3" (should-throw (vec3 {:x "a"})))
   (it "fail w/ str args v3" (should-throw (vec3 "a" "a"))))
#+END_SRC
#+BEGIN_SRC clojure :tangle babel/spec/thi/ng/geom/test/core.clj
   )
#+END_SRC
** Test constants
#+BEGIN_SRC clojure :tangle babel/spec/thi/ng/geom/test/core.clj
  (def a2 (vec2 1 2))
  (def b2 (vec2 10 20))
  (def a3 (vec3 1 2 3))
  (def b3 (vec3 10 20 30))
#+END_SRC
** Swizzling
#+BEGIN_SRC clojure :tangle babel/spec/thi/ng/geom/test/core.clj
  (describe
   "Vector swizzling"
  
   (context
    "reading..."
    (it ":x" (should (= 1.0 (:x a2) (:x a3))))
    (it ":y" (should (= 2.0 (:y a2) (:y a3))))
    (it ":z" (should= 3.0 (:z a3)))
    (it ":z fail a2" (should-throw (:z a2)))
    (it ":xy a2=a3" (should= (:xy a2) (:xy a3)))
    (it ":xy" (should= [1.0 2.0] (:xy a2)))
    (it ":yx a2=a3" (should= (:yx a2) (:yx a3)))
    (it ":yx" (should= [2.0 1.0] (:yx a2)))
    (it ":yy a2=a3" (should= (:yy a2) (:yy a3)))
    (it ":yy" (should= [2.0 2.0] (:yy a2)))
    (it ":yy" (should= [2.0 2.0] (:yy a3)))
    (it ":yz" (should= [2.0 3.0] (:yz a3)))
    (it ":xyz fail a2" (should-throw (:xyz a2)))
    (it ":xyz a3" (should= [1.0 2.0 3.0] (:xyz a3)))
    (it ":zxy a3" (should= [3.0 1.0 2.0] (:zxy a3)))
    (it "idx 0" (should= (a2 0) (a3 0)))
    (it "idx 1" (should= (a2 1) (a3 1)))
    (it "idx 2" (should= 3.0 (a3 2)))
    (it "idx 2 fail a2" (should-throw (a2 2)))
    (it "idx 3 fail a3" (should-throw (a3 3)))
    )
  
   (context
    "writing..."
    (it ":x" (should= [10.0 2.0] (assoc a2 :x 10)))
    (it ":x" (should= [10.0 2.0 3.0] (assoc a3 :x 10)))
    (it ":y" (should= [1.0 20.0] (assoc a2 :y 20)))
    (it ":y" (should= [1.0 20.0 3.0] (assoc a3 :y 20)))
    (it ":z" (should= [1.0 2.0 30.0] (assoc a3 :z 30)))
    (it ":xy" (should= [10.0 20.0] (assoc a2 :xy [10 20])))
    (it ":xy" (should= [10.0 20.0 3.0] (assoc a3 :xy [10 20])))
    (it ":yx" (should= [20.0 10.0] (assoc a2 :yx [10 20])))
    (it ":yx" (should= [20.0 10.0 3.0] (assoc a3 :yx [10 20])))
    (it ":xz" (should= [10.0 2.0 20.0] (assoc a3 :xz [10 20])))
    (it ":xz fail 2d" (should-throw (assoc a2 :xz [10 20])))
    (it ":zx" (should= [20.0 2.0 10.0] (assoc a3 :zx [10 20])))
    (it ":zx fail 2d" (should-throw (assoc a2 :zx [10 20])))
    (it ":yz" (should= [1.0 10.0 20.0] (assoc a3 :yz [10 20])))
    (it ":yz fail 2d" (should-throw (assoc a2 :yz [10 20])))
    (it ":zy" (should= [1.0 20.0 10.0] (assoc a3 :zy [10 20])))
    (it ":zy fail 2d" (should-throw (assoc a2 :zy [10 20])))
    (it ":xyz fail 2d" (should-throw (assoc a2 :xyz [10 20 30])))
    (it ":xyz fail 3d" (should-throw (assoc a3 :xyz [10 20 30])))
    ))
#+END_SRC
** Clojure/Java protocol impls
#+BEGIN_SRC clojure :tangle babel/spec/thi/ng/geom/test/core.clj
  (describe
   "Protocol impls"
  
   (with v2 (vec2 1 2))
   (with v3 (vec3 1 2 3))
  
   (it "meta v2" (should= {:foo "bar"} (meta (with-meta @v2 {:foo "bar"}))))
   (it "meta v3" (should= {:foo "bar"} (meta (with-meta @v3 {:foo "bar"}))))
   (it "seq v2" (should= (seq @v2) (seq '(1.0 2.0))))
   (it "rseq v2" (should= (rseq @v2) (rseq [1.0 2.0])))
   (it "rseq a vec2?" (should (g/vec2? (rseq @v2))))
   (it "seq v3" (should= (seq @v3) (seq '(1.0 2.0 3.0))))
   (it "rseq v3" (should= (rseq @v3) (rseq [1.0 2.0 3.0])))
   (it "rseq a vec3?" (should (g/vec3? (rseq @v3))))
   (it "first v2" (should= 1.0 (first @v2)))
   (it "first v3" (should= 1.0 (first @v3)))
   (it "rest v2" (should= (rest @v2) [2.0]))
   (it "next v2" (should= (next @v2) [2.0]))
   (it "nnext v2 nil?" (should-be-nil (nnext @v2)))
   (it "rest v3" (should= (rest @v3) [2.0 3.0]))
   (it "next v3" (should= (next @v3) [2.0 3.0]))
   (it "nnext v3" (should= (nnext @v3) [3.0]))
   (it "nnext v3 nil?" (should-be-nil (next (nnext @v2))))
   (it "nth v2" (should= 2.0 (nth @v2 1)))
   (it "nth v2 default" (should= -1 (nth @v2 2 -1)))
   (it "nth v2 fail" (should-throw (nth @v2 2)))
   (it "nth v3" (should= 3.0 (nth @v3 2)))
   (it "nth v3 default" (should= -1 (nth @v3 3 -1)))
   (it "nth v3 fail" (should-throw (nth @v3 3)))
   (it "peek v2" (should= 2.0 (peek @v2)))
   (it "peek v3" (should= 3.0 (peek @v3)))
   (it "pop v2" (should= (pop @v2) [1.0]))
   (it "pop v2 type" (should= (type (pop @v2)) clojure.lang.PersistentVector))
   (it "pop v3" (should= (pop @v3) [1.0 2.0]))
   (it "pop v3 vec2?" (should (g/vec2? (pop @v3))))
   (it "destructure v2" (should (let [[x y z] @v2] (and (= @v2 [x y]) (nil? z)))))
   (it "destructure v3" (should (let [[x y z w] @v3] (and (= @v3 [x y z]) (nil? w)))))
   (it "contains keys v2" (should (every? #(contains? @v2 %) [:x :y 0 1])))
   (it "contains keys v3" (should (every? #(contains? @v3 %) [:x :y :z 0 1 2])))
   (it "vec = v2" (should= [1.0 2.0] @v2))
   (it "seq = v2" (should= (seq @v2) @v2))
   (it "vec = v3" (should= [1.0 2.0 3.0] @v3))
   (it "seq = v3" (should= (seq @v3) @v3))
   (it "v2 != v3" (should-not= @v2 @v3))
   (it "v3 != v2" (should-not= @v3 @v2))
   (it "v2 != rseq" (should-not= @v2 (rseq @v2)))
   (it "v3 != rseq" (should-not= @v3 (rseq @v3)))
   (it "v2 != x" (should-not= @v2 1))
   (it "v3 != x" (should-not= @v3 1))
   (it "#{v2 a2}" (should= 2 (count (into #{} [@v2 [1.0 2.0] @v2]))))
   (it "#{v3 a3}" (should= 2 (count (into #{} [@v3 [1.0 2.0 3.0] @v3]))))
   (it "count v2" (should= 2 (count @v2)))
   (it "count v3" (should= 3 (count @v3)))
   (it "size v2" (should= 2 (.size @v2)))
   (it "size v3" (should= 3 (.size @v3)))
   (it "iterator v2" (should= [1.0 2.0] (iterator-seq (.iterator @v2))))
   (it "iterator v3" (should= [1.0 2.0 3.0] (iterator-seq (.iterator @v3))))
   (it "apply v2" (should= 1.0 (apply @v2 [0])))
   (it "apply v2 kw" (should= 2.0 (apply @v2 [:y])))
   (it "apply v2 swizzle" (should= [2.0 1.0] (apply @v2 [:yx])))
   (it "apply v2 w/ default" (should= -1 (apply @v2 [:z -1])))
   (it "apply v2 fail" (should-throw (apply @v2 [:z])))
   (it "apply v3" (should= 1.0 (apply @v3 [0])))
   (it "apply v3 kw" (should= 2.0 (apply @v3 [:y])))
   (it "apply v3 swizzle" (should= [2.0 1.0 3.0] (apply @v3 [:yxz])))
   (it "apply v3 w/ default" (should= -1 (apply @v3 [:w -1])))
   (it "apply v3 fail" (should-throw (apply @v3 [:w])))
   )
#+END_SRC
** Vector algebra
#+BEGIN_SRC clojure :tangle babel/spec/thi/ng/geom/test/core.clj
  (defn context-vec2-op
    [op]
    (context
     (str "op: " op)
     (it "op v2 b3" (should= (op a2 b2) (op a2 b3)))
     (it "op v2 n m" (should= (op a2 b2) (op a2 10 20)))
     (it "op v2 [n m]" (should= (op a2 b2) (op a2 [10 20])))
     (it "op v2 b2 m" (should= (op (op a2 b2) 20) (op a2 b2 20)))
     (it "op v2 b2 b2" (should= (op (op a2 b2) b2) (op a2 b2 b2)))
     (it "op v2 n b2" (should= (op (op a2 10) b2) (op a2 10 b2)))))
  
  (defn context-vec3-op
    [op]
    (context
     (str "op:" op)
     (it "op v3 n m" (should= (op (op a3 10) 20) (op a3 10 20)))
     (it "op v3 b3 n" (should= (op (op a3 b3) 20) (op a3 b3 20)))
     (it "op v3 b3 b3" (should= (op (op a3 b3) b3) (op a3 b3 b3)))
     (it "op v3 n b3" (should= (op (op a3 10) b3) (op a3 10 b3)))
     (it "op v3 n m o" (should= (op a3 b3) (op a3 10 20 30)))
     (it "op v3 [n m o]" (should= (op a3 b3) (op a3 [10 20 30])))
     (it "op v3 b3 n m" (should= (op (op (op a3 b3) 20) 30) (op a3 b3 20 30)))
     (it "op v3 b3 b3 m" (should= (op (op (op a3 b3) b3) 30) (op a3 b3 b3 30)))
     (it "op v3 b3 b3 a3" (should= (op (op (op a3 b3) b3) a3) (op a3 b3 b3 a3)))
     (it "op v3 n m b3" (should= (op (op (op a3 10) 20) b3) (op a3 10 20 b3)))))
  
  (describe
   "Vector algebra"
  
   (context
    "2d ops"
    (it "+ v2" (should= a2 (+ a2)))
    (it "+ v2 b2" (should= [11.0 22.0] (+ a2 b2)))
    (it "+ v2 n" (should= [11.0 12.0] (+ a2 10)))
    (it "+ v2 [n]" (should= (+ a2 10 0) (+ a2 [10])))
    (context-vec2-op +)
  
    (it "- v2" (should= [-1.0 -2.0] (- a2)))
    (it "- v2 b2" (should= [-9.0 -18.0] (- a2 b2)))
    (it "- v2 n" (should= [-9.0 -8.0] (- a2 10)))
    (it "- v2 [n]" (should= (+ a2 10 0) (+ a2 [10])))
    (context-vec2-op -)
  
    (it "* v2" (should= a2 (* a2)))
    (it "* v2 b2" (should= [10.0 40.0] (* a2 b2)))
    (it "* v2 n" (should= [10.0 20.0] (* a2 10)))
    (it "* v2 [n]" (should= (* a2 10 1) (* a2 [10])))
    (context-vec2-op *)
  
    (it "/ v2" (should= [1.0 0.5] (div a2)))
    (it "/ v2 b2" (should= [0.1 0.1] (div a2 b2)))
    (it "/ v2 n" (should= [0.1 0.2] (div a2 10)))
    (it "/ v2 [n] fail" (should-throw (div a2 [10])))
    (context-vec2-op div))
  
   (context
    "3d ops"
    (it "+ v3" (should= a3 (+ a3)))
    (it "+ v3 b3" (should= [11.0 22.0 33.0] (+ a3 b3)))
    (it "+ v3 n" (should= [11.0 12.0 13.0] (+ a3 10)))
    (it "+ v3 [n m]" (should= (+ a3 10 20 0) (+ a3 [10 20])))
    (context-vec3-op +)
  
    (it "- v3" (should= [-1.0 -2.0 -3.0] (- a3)))
    (it "- v3 b3" (should= [-9.0 -18.0 -27.0] (- a3 b3)))
    (it "- v3 n" (should= [-9.0 -8.0 -7.0] (- a3 10)))
    (it "- v3 [n m]" (should= (- a3 10 20 0) (- a3 [10 20])))
    (context-vec3-op -)
  
    (it "* v3" (should= a3 (* a3)))
    (it "* v3 b3" (should= [10.0 40.0 90.0] (* a3 b3)))
    (it "* v3 n" (should= [10.0 20.0 30.0] (* a3 10)))
    (it "* v3 [n m]" (should= (* a3 10 20 1) (* a3 [10 20])))
    (context-vec3-op *)
  
    (it "/ v3" (should= [1.0 0.5 (/ 3.0)] (div a3)))
    (it "/ v3 b3" (should= [0.1 0.1 0.1] (div a3 b3)))
    (it "/ v3 n" (should= [0.1 0.2 0.3] (div a3 10)))
    (it "/ v3 [n m] fail" (should-throw (div a3 [10 20])))
    (context-vec3-op div))
  
   (context
    "madd"
    (it "madd v2 n m" (should= (+ (* a2 10) 20) (g/madd a2 10 20)))
    (it "madd v2 b2 n" (should= (+ (* a2 b2) 10) (g/madd a2 b2 10)))
    (it "madd v2 n b2" (should= (+ (* a2 10) b2) (g/madd a2 10 b2)))
    (it "madd v2 n b2 != madd v2 b2 n" (should-not= (g/madd a2 10 b2) (g/madd a3 b3 10)))
    (it "madd v2 b2 a2" (should= (+ (* a2 b2) a2) (g/madd a2 b2 a2)))
  
    (it "madd v3 n m" (should= (+ (* a3 10) 20) (g/madd a3 10 20)))
    (it "madd v3 b3 n" (should= (+ (* a3 b3) 10) (g/madd a3 b3 10)))
    (it "madd v3 n b3" (should= (+ (* a3 10) b3) (g/madd a3 10 b3)))
    (it "madd v3 n b3 != madd v3 b3 n" (should-not= (g/madd a3 10 b3) (g/madd a3 b3 10)))
    (it "madd v3 b3 a3" (should= (+ (* a3 b3) a3) (g/madd a3 b3 a3))))
  
   )
#+END_SRC
** Trigger tests
#+BEGIN_SRC clojure :tangle babel/spec/thi/ng/geom/test/core.clj
  (run-specs)
#+END_SRC
