#+SETUPFILE: ../../src/setup.org

* Namespace: thi.ng.geom.svg.core

** Constants & presets

#+BEGIN_SRC clojure :noweb-ref const
  (def stroke-round {:stroke-linecap "round" :stroke-linejoin "round"})
#+END_SRC

** Protocols

*** PSVGConvert
#+BEGIN_SRC clojure :noweb-ref protos
  (defprotocol PSVGConvert
    (as-svg [_ opts]))
#+END_SRC

** SVG serialization

*** Formatters

#+BEGIN_SRC clojure :noweb-ref const
  (def xml-preamble "<?xml version=\"1.0\"?>\n")

  (def ^:dynamic *ff* (f/float 2))
  (def ^:dynamic *fmt-vec* (fn [p] (str (*ff* (nth p 0)) "," (*ff* (nth p 1)))))
  (def ^:dynamic *fmt-percent* (fn [x] (str (int (* x 100)) "%")))

  (def point-seq-format2 [*fmt-vec* " " *fmt-vec*])
  (def point-seq-format3 [*fmt-vec* " " *fmt-vec* " " *fmt-vec*])
  (def point-seq-format4 [*fmt-vec* " " *fmt-vec* " " *fmt-vec* " " *fmt-vec*])

  (defn point-seq-format
    [n]
    (case (int n)
      1 [*fmt-vec*]
      2 point-seq-format2
      3 point-seq-format3
      4 point-seq-format4
      (->> *fmt-vec*
           (repeat n)
           (interpose " "))))
#+END_SRC

Actual conversion to SVG XML strings is only directly supported for
the Clojure version using James Reeve's [[https://github.com/weavejester/hiccup][hiccup]] library. For
ClojureScript it is more likely (and efficient) to directly translate
a SVG data structure into a DOM tree for which there're many different
libraries available and we don't want to be prescriptive here and
introduce uneccessary dependencies.

#+BEGIN_SRC clojure :noweb-ref svg
  ,#+clj
  (defn serialize
    [svg] (str xml-preamble (html {:mode :xml} svg)))

  ,#+clj
  (defn serialize-as-byte-array
    [svg] (.getBytes (serialize svg) "UTF-8"))
#+END_SRC

** Color attribute conversion

Colors in SVG need to be defined as CSS color strings and hence are
completely opaque to other parts of the code base and which might deal
with the dynamic generation of color values. Therefore we allow the
=:stroke= and =:fill= attributes to be defined as RGB(A) or HSB(A)
vectors (e.g. in conjuction with the color utilities defined in the
=thi.ng.common.color= namespace. If these attributes are present and
*not* already a string value, they will be converted into a CSS color
automatically (using the =rgba->css= or =hsba->css= fns). In order to
specify HSB colors, use the =:stoke-hsb= or =:fill-hsb= attributes.

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn color-attrib
    [attribs id id2 f]
    (if-let [att (attribs id)]
      (if (string? att)
        attribs
        (-> attribs (dissoc id) (assoc id2 (apply f att))))
      attribs))

  (defn svg-attribs
    [attribs base]
    (if (seq attribs)
      (-> attribs
          (color-attrib :stroke :stroke col/rgba->css)
          (color-attrib :stroke-hsb :stroke col/hsba->css)
          (color-attrib :fill :fill col/rgba->css)
          (color-attrib :fill-hsb :fill col/hsba->css)
          (into base))
      base))
#+END_SRC

** SVG primitives

#+BEGIN_SRC clojure :noweb-ref prims
  (defn svg
    [attribs & body]
    [:svg
     (svg-attribs
      attribs
      {:xmlns "http://www.w3.org/2000/svg"
       :version "1.1"})
     body])

  (defn defs
    [& defs]
    [:defs defs])

  (defn gradient-stop
    [[pos col]]
    (let [col (if (string? col) col (apply col/rgba->css col))]
      [:stop {:offset (*fmt-percent* pos) :stop-color col}]))

  (defn linear-gradient
    [id & stops]
    [:linearGradient
     {:id id}
     (map gradient-stop stops)])

  (defn radial-gradient
    [id & stops]
    [:radialGradient
     {:id id}
     (map gradient-stop stops)])

  (defn group
    [attribs & body]
    [:g (svg-attribs attribs nil) body])

  (defn text
    [[x y] txt & [attribs]]
    [:text
     (svg-attribs attribs {:x (*ff* x) :y (*ff* y)})
     txt])

  (defn circle
    [[x y] radius & [attribs]]
    [:circle
     (svg-attribs
      attribs
      {:cx (*ff* x) :cy (*ff* y)
       :r radius})])

  (defn rect
    [[x y] w h & [attribs]]
    [:rect
     (svg-attribs
      attribs
      {:x (*ff* x) :y (*ff* y)
       :width w :height h})])

  (defn line
    [[ax ay] [bx by] & [attribs]]
    [:line
     (svg-attribs
      attribs
      {:x1 (*ff* ax) :y1 (*ff* ay)
       :x2 (*ff* bx) :y2 (*ff* by)})])

  (defn line-strip
    [points & [attribs]]
    [:polyline
     (svg-attribs
      attribs
      {:fill "none"
       :points (apply f/format (point-seq-format (count points)) points)})])

  (defn polygon
    [points & [attribs]]
    [:polygon
     (svg-attribs
      attribs
      {:points (apply f/format (point-seq-format (count points)) points)})])
#+END_SRC

** SVG conversions for geom.types

The =thi.ng.geom.svg.adapater= namespace provides some simple wrappers
to allow direct use of the shape entities defined in the [[file:~/work/clj/thing/geom/geom-types/src/index.org][geom-types]]
module without having to manually convert them into their SVG
representations.

The adapaters work by providing implementations of the [[PSVGConvert]]
protocol for all built-in 2D types and a simple helper function to
recursively transform any such types used within an SVG scene.

Any 3D entities (e.g. meshes) need to be processed via the
[[file:renderer.org][geom.svg.renderer]] namespace.

*** Example use case

The entities defined by the geom library are purely mathematical and
are intented to help solving geometric problems, but without any
regard to specific means of visualization. In the example below we
construct three circles, compute their points of intersection and then
visualize the result in SVG:

#+BEGIN_SRC clojure :tangle ../babel/examples/svgdemo01.clj :noweb yes :mkdirp yes :padline no
  (ns svgdemo01
    (:require
     [thi.ng.geom.core :as g]
     [thi.ng.geom.circle :as c]
     [thi.ng.geom.svg.core :as svg]
     [thi.ng.geom.svg.adapter :as adapt]))

  (defn labeled-dot
    [p label] (list (c/circle p 3) (svg/text (g/+ p 10 0) label)))

  ;; This scene defines 2 circles and their intersection points
  (def scene
    (let [c1    (c/circle 50 150 50)
          c2    (c/circle 250 150 50)
          c3    (c/circle 150 150 100)
          [a b] (g/intersect-shape c1 c3)
          [c d] (g/intersect-shape c2 c3)]
      (svg/svg
       {:width 300 :height 300}
       (svg/group
        {:fill "yellow"}
        ;; these circles inherit all attributes from parent group
        c1 c2
        ;; we can use metadata to override specific attribs per shape
        ;; here we also demonstrate automatic color attrib conversion
        (with-meta c3 {:fill [0 1 1 0.25] :stroke-hsb [0 1 1]}))
       (svg/group
        {:fill "#000"
         :font-family "Arial, sans-serif"
         :font-size 10}
        (mapcat labeled-dot [a b c d] ["A" "B" "C" "D"])))))

  (->> scene
       (adapt/all-as-svg)    ;; transform all scene elements
       (svg/serialize)       ;; serialize as SVG XML string
       (spit "circles.svg")) ;; write to disk
#+END_SRC

[[http://media.thi.ng/geom/svgdemo01-circles.svg]]

Btw. This example can be run from the REPL via this command:

#+BEGIN_SRC clojure
  (load-file "examples/circles.clj")
#+END_SRC

*** Adapter implementation

#+BEGIN_SRC clojure :noweb-ref adapter
  (extend-protocol svg/PSVGConvert

    thi.ng.geom.types.Line2
    (as-svg [{p :points} opts] (svg/line (p 0) (p 1) opts))

    thi.ng.geom.types.Circle2
    (as-svg [_ opts] (svg/circle (:p _) (:r _) opts))

    thi.ng.geom.types.LineStrip2
    (as-svg [_ opts] (svg/line-strip (:points _) opts))

    thi.ng.geom.types.Polygon2
    (as-svg [_ opts] (svg/polygon (:points _) opts))

    thi.ng.geom.types.Rect2
    (as-svg [{:keys [p size]} opts] (svg/rect p (size 0) (size 1) opts))

    thi.ng.geom.types.Triangle2
    (as-svg [_ opts] (svg/polygon (:points _) opts))

    )

  (defn all-as-svg
    [form]
    (postwalk
     (fn [x] (if (satisfies? svg/PSVGConvert x) (svg/as-svg x (meta x)) x))
     form))
#+END_SRC

** Complete namespace: svg.core                                    :noexport:
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/svg/core.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.svg.core
    (:require
     [thi.ng.geom.core :as g]
     [thi.ng.geom.core.utils :as gu]
     [thi.ng.geom.core.vector :refer [vec3 V3Z]]
     [thi.ng.geom.core.matrix :as mat :refer [M44]]
     [thi.ng.common.stringformat :as f]
     [thi.ng.common.color :as col]
     #+clj [hiccup.core :refer [html]]))

  <<const>>

  <<protos>>

  <<svg>>

  <<helpers>>

  <<prims>>
#+END_SRC

** Complete namespace: svg.adapter                                 :noexport:
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/svg/adapter.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.svg.adapter
    (:require
     [thi.ng.geom.svg.core :as svg]
     [thi.ng.geom.core :as g]
     [thi.ng.geom.types]
     [clojure.walk :refer [postwalk]])
    ,#+clj
    (:import
     [thi.ng.geom.types Circle2 Line2 LineStrip2 Polygon2 Rect2 Triangle2]))

  <<adapter>>
#+END_SRC
