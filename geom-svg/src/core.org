#+SETUPFILE: ../../src/setup.org

* Namespace: thi.ng.geom.svg.core

** Constants & presets

#+BEGIN_SRC clojure :noweb-ref const
  (def stroke-round {:stroke-linecap "round" :stroke-linejoin "round"})
#+END_SRC

** Protocols

*** PSVGConvert
#+BEGIN_SRC clojure :noweb-ref protos
  (defprotocol PSVGConvert
    (as-svg [_ opts]))
#+END_SRC

** SVG serialization

*** Formatters

#+BEGIN_SRC clojure :noweb-ref const
  (def xml-preamble "<?xml version=\"1.0\"?>\n")

  (def ^:dynamic *ff* (f/float 2))
  (def ^:dynamic *fmt-vec* (fn [p] (str (*ff* (nth p 0)) "," (*ff* (nth p 1)))))
  (def ^:dynamic *fmt-percent* (fn [x] (str (int (* x 100)) "%")))

  (def ^:dynamic *fmt-matrix* ["matrix(" *ff* "," *ff* "," *ff* "," *ff* "," *ff* "," *ff* ")"])

  (def point-seq-format2 [*fmt-vec* " " *fmt-vec*])
  (def point-seq-format3 [*fmt-vec* " " *fmt-vec* " " *fmt-vec*])
  (def point-seq-format4 [*fmt-vec* " " *fmt-vec* " " *fmt-vec* " " *fmt-vec*])

  (defn point-seq-format
    [n]
    (case (int n)
      1 [*fmt-vec*]
      2 point-seq-format2
      3 point-seq-format3
      4 point-seq-format4
      (->> *fmt-vec*
           (repeat n)
           (interpose " "))))
#+END_SRC

Actual conversion to SVG XML strings is only directly supported for
the Clojure version using James Reeve's [[https://github.com/weavejester/hiccup][hiccup]] library. For
ClojureScript it is more likely (and efficient) to directly translate
a SVG data structure into a DOM tree for which there're many different
libraries available and we don't want to be prescriptive here and
introduce uneccessary dependencies.

#+BEGIN_SRC clojure :noweb-ref svg
  ,#+clj
  (defn serialize
    [svg] (str xml-preamble (html {:mode :xml} svg)))

  ,#+clj
  (defn serialize-as-byte-array
    [svg] (.getBytes (serialize svg) "UTF-8"))
#+END_SRC

** Attribute conversion

*** Colors

Colors in SVG need to be defined as CSS color strings and hence are
completely opaque to other parts of the code base and which might deal
with the dynamic generation of color values. Therefore we allow the
=:stroke= and =:fill= attributes to be defined as RGB(A) or HSB(A)
vectors (e.g. in conjuction with the color utilities defined in the
=thi.ng.common.color= namespace. If these attributes are present and
*not* already a string value, they will be converted into a CSS color
automatically (using the =rgba->css= or =hsba->css= fns). In order to
specify HSB colors, use the =:stoke-hsb= or =:fill-hsb= attributes.

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn color-attrib
    [attribs id id2 f]
    (if-let [att (attribs id)]
      (if (string? att)
        attribs
        (-> attribs (dissoc id) (assoc id2 (apply f att))))
      attribs))
#+END_SRC

*** Transforms

Many SVG elements support the attachment of local coordinate
transformations. If a =:transform= attribute has a non-string value, it
will be interpreted as a =Matrix32= or equivalent vector and will be
automatically converted.

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn matrix-attrib
    [attribs id]
    (if-let [mat (attribs id)]
      (if (string? mat)
        attribs
        (assoc attribs id (apply f/format *fmt-matrix* (g/transpose mat))))
      attribs))
#+END_SRC

*** Attribute processing

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn filter-attribs
    [attribs]
    (loop [acc (transient attribs), ks (keys attribs)]
      (if ks
        (recur
         (if (= "__" (subs (name (first ks)) 0 2)) (dissoc! acc (first ks)) acc)
         (next ks))
        (persistent! acc))))

  (defn svg-attribs
    [attribs base]
    (if (seq attribs)
      (-> (filter-attribs attribs)
          (color-attrib :stroke :stroke col/rgba->css)
          (color-attrib :stroke-hsb :stroke col/hsba->css)
          (color-attrib :fill :fill col/rgba->css)
          (color-attrib :fill-hsb :fill col/hsba->css)
          (matrix-attrib :transform)
          (into base))
      base))
#+END_SRC

** SVG primitives

#+BEGIN_SRC clojure :noweb-ref prims
  (defn svg
    [attribs & body]
    [:svg
     (svg-attribs
      attribs
      {"xmlns" "http://www.w3.org/2000/svg"
       "xmlns:xlink" "http://www.w3.org/1999/xlink"
       "version" "1.1"})
     body])

  (defn defs
    [& defs]
    [:defs defs])

  (defn gradient-stop
    [f [pos col]]
    (let [col (if (string? col) col (apply f col))]
      [:stop {:offset (*fmt-percent* pos) :stop-color col}]))

  (defn linear-gradient-rgb
    [id & stops]
    [:linearGradient
     {:id id}
     (map #(gradient-stop col/rgba->css %) stops)])

  (defn radial-gradient-rgb
    [id & stops]
    [:radialGradient
     {:id id}
     (map #(gradient-stop col/rgba->css %) stops)])

  (defn linear-gradient-hsb
    [id & stops]
    [:linearGradient
     {:id id}
     (map #(gradient-stop col/hsba->css %) stops)])

  (defn radial-gradient-hsb
    [id & stops]
    [:radialGradient
     {:id id}
     (map #(gradient-stop col/hsba->css %) stops)])

  (defn group
    [attribs & body]
    [:g (svg-attribs attribs nil) body])

  (defn text
    [[x y] txt & [attribs]]
    [:text
     (svg-attribs attribs {:x (*ff* x) :y (*ff* y)})
     txt])

  (defn circle
    [[x y] radius & [attribs]]
    [:circle
     (svg-attribs
      attribs
      {:cx (*ff* x) :cy (*ff* y)
       :r radius})])

  (defn rect
    [[x y] w h & [attribs]]
    [:rect
     (svg-attribs
      attribs
      {:x (*ff* x) :y (*ff* y)
       :width w :height h})])

  (defn line
    [[ax ay] [bx by] & [attribs]]
    [:line
     (svg-attribs
      attribs
      {:x1 (*ff* ax) :y1 (*ff* ay)
       :x2 (*ff* bx) :y2 (*ff* by)})])

  (defn line-decorated
    [p q start end & [attribs]]
    (list
     (line p q attribs)
     (if start (start q p 0 attribs))
     (if end   (end p q 0 attribs))))

  (defn line-strip
    [points & [attribs]]
    [:polyline
     (svg-attribs
      attribs
      {:fill "none"
       :points (apply f/format (point-seq-format (count points)) points)})])

  (defn line-strip-decorated
    [points start seg end & [attribs]]
    (let [n (dec (count points))]
      (list
       (line-strip points attribs)
       (if start (start (points 1) (points 0) 0 attribs))
       (if seg   (map-indexed (fn [i [p q]] (seg p q i attribs)) (d/successive-nth 2 points)))
       (if end   (end (points (dec n)) (peek points) n attribs)))))

  (defn polygon
    [points & [attribs]]
    [:polygon
     (svg-attribs
      attribs
      {:points (apply f/format (point-seq-format (count points)) points)})])

  (defn instance
    [id & [attribs]]
    [:use (svg-attribs attribs {"xlink:href" (str "#" id)})])
#+END_SRC

** Decorators

#+BEGIN_SRC clojure :noweb-ref decorators
  (defn arrow-head
    [len theta solid? & [opts]]
    (fn [p q idx & [attribs]]
      (let [q (vec2 q)
            d (g/normalize (g/- q p) len)]
        (list
         ((if solid? polygon line-strip)
          [(g/- q (g/rotate d (- theta))) q (g/- q (g/rotate d theta))]
            (merge attribs opts))))))

  (defn line-label
    [& [{:keys [__rotate? __offset] :as opts}]]
    (let [opts (-> opts
                   (dissoc :__rotate? :__offset)
                   (update-in [:text-anchor] #(or % "middle")))]
      (fn [p q idx & [attribs]]
        (if-let [label (get-in attribs [:__label idx])]
          (let [p (vec2 p)
                m (g/+ (g/mix p q) __offset)
                opts (if __rotate?
                       (assoc opts
                         :transform (str "rotate("
                                         (m/degrees (g/heading (g/normal (g/- p q))))
                                         " " (m 0) " " (m 1) ")"))
                       opts)]
            (list (text m label (merge (dissoc attribs :__label) opts))))))))

  (defn comp-decorators
    [& fns]
    (fn [p q idx & [attribs]]
      (reduce
       (fn [acc f] (concat acc (f p q idx attribs))) () fns)))
#+END_SRC

** SVG conversions for geom.types

The =thi.ng.geom.svg.adapater= namespace provides some simple wrappers
to allow direct use of the shape entities defined in the [[file:~/work/clj/thing/geom/geom-types/src/index.org][geom-types]]
module without having to manually convert them into their SVG
representations.

The adapaters work by providing implementations of the [[PSVGConvert]]
protocol for all built-in 2D types and a simple helper function to
recursively transform any such types used within an SVG scene.

Any 3D entities (e.g. meshes) need to be processed via the
[[file:renderer.org][geom.svg.renderer]] namespace.

*** Example use case

The entities defined by the geom library are purely mathematical and
are intented to help solving geometric problems, but without any
regard to specific means of visualization. In the example below we
construct three circles, compute their points of intersection and then
visualize the result in SVG:

#+BEGIN_SRC clojure :tangle ../babel/examples/svgdemo01.clj :noweb yes :mkdirp yes :padline no
  (ns svgdemo01
    (:require
     [thi.ng.geom.core :as g]
     [thi.ng.geom.circle :as c]
     [thi.ng.geom.svg.core :as svg]
     [thi.ng.geom.svg.adapter :as adapt]))

  (defn labeled-dot
    [p label] (list (c/circle p 3) (svg/text (g/+ p 10 0) label)))

  ;; This scene defines 2 circles and their intersection points
  (def scene
    (let [c1    (c/circle 50 150 50)
          c2    (c/circle 250 150 50)
          c3    (c/circle 150 150 100)
          [a b] (g/intersect-shape c1 c3)
          [c d] (g/intersect-shape c2 c3)]
      (svg/svg
       {:width 300 :height 300}
       (svg/group
        {:fill "yellow"}
        ;; these circles inherit all attributes from parent group
        c1 c2
        ;; we can use metadata to override specific attribs per shape
        ;; here we also demonstrate automatic color attrib conversion
        (with-meta c3 {:fill [0 1 1 0.25] :stroke-hsb [0 1 1]}))
       (svg/group
        {:fill "#000"
         :font-family "Arial, sans-serif"
         :font-size 10}
        (mapcat labeled-dot [a b c d] ["A" "B" "C" "D"])))))

  (->> scene
       (adapt/all-as-svg)    ;; transform all scene elements
       (svg/serialize)       ;; serialize as SVG XML string
       (spit "svgdemo01-circles.svg")) ;; write to disk
#+END_SRC

[[http://media.thi.ng/geom/svg/svgdemo01-circles.svg]]

Btw. This example can be run from the REPL via this command:

#+BEGIN_SRC clojure
  (load-file "examples/circles.clj")
#+END_SRC

*** Adapter implementation

#+BEGIN_SRC clojure :noweb-ref adapter
  (extend-protocol svg/PSVGConvert

    thi.ng.geom.types.Line2
    (as-svg
      [{p :points} {:keys [__start __end] :as opts}]
      (if (or __start __end)
        (svg/line-decorated (p 0) (p 1) __start __end opts)
        (svg/line (p 0) (p 1) opts)))

    thi.ng.geom.types.Circle2
    (as-svg
      [_ opts] (svg/circle (:p _) (:r _) opts))

    thi.ng.geom.types.LineStrip2
    (as-svg
      [{:keys [points]} {:keys [__start __segment __end] :as opts}]
      (if (or __start __segment __end)
        (svg/line-strip-decorated points __start __segment __end opts)
        (svg/line-strip points opts)))

    thi.ng.geom.types.Polygon2
    (as-svg
      [_ opts] (svg/polygon (:points _) opts))

    thi.ng.geom.types.Rect2
    (as-svg
      [{:keys [p size]} opts] (svg/rect p (size 0) (size 1) opts))

    thi.ng.geom.types.Triangle2
    (as-svg
      [_ opts] (svg/polygon (:points _) opts))

    )

  (defn all-as-svg
    [form]
    (postwalk
     (fn [x] (if (satisfies? svg/PSVGConvert x) (svg/as-svg x (meta x)) x))
     form))
#+END_SRC

** Complete namespace: svg.core                                    :noexport:
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/svg/core.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.svg.core
    (:require
     [thi.ng.geom.core :as g]
     [thi.ng.geom.core.utils :as gu]
     [thi.ng.geom.core.vector :refer [vec2]]
     [thi.ng.geom.core.matrix :as mat :refer [M32]]
     [thi.ng.common.data.core :as d]
     [thi.ng.common.math.core :as m]
     [thi.ng.common.stringformat :as f]
     [thi.ng.common.color :as col]
     #+clj [hiccup.core :refer [html]]))

  <<const>>

  <<protos>>

  <<svg>>

  <<helpers>>

  <<prims>>

  <<decorators>>
#+END_SRC

** Complete namespace: svg.adapter                                 :noexport:
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/svg/adapter.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.svg.adapter
    (:require
     [thi.ng.geom.svg.core :as svg]
     [thi.ng.geom.core :as g]
     [thi.ng.geom.types]
     [clojure.walk :refer [postwalk]])
    ,#+clj
    (:import
     [thi.ng.geom.types Circle2 Line2 LineStrip2 Polygon2 Rect2 Triangle2]))

  <<adapter>>
#+END_SRC
