* Vector deftype experiments

** Helper macros
*** Namespace declarations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/macros.cljx
  (ns thi.ng.geom.macros)
#+END_SRC
** Vector types
*** Namespace declarations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/vectors.cljx
  (ns thi.ng.geom.vectors
    (:require
     [thi.ng.math.core :as m]))
#+END_SRC
*** Protocols
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/vectors.cljx
  (defprotocol PVector
    (abs [this])
    (add [this a] [this a b] [this a b c])
    (add-n [this n])
    (sub [this a] [this a b] [this a b c])
    (sub-n [this n])
    (scale [this a] [this a b] [this a b c])
    (scale-n [this n])
    (dot [this a])
    (cross [this a])
    (mag [this])
    (mag-squared [this])
    (dist [this a])
    (dist-squared [this a])
    (normalize [this] [this len])
    (limit [this len])
    (invert [this])
    (inverse [this])
    (reflect [this r])
    (minv [this a] [this a b])
    (maxv [this a] [this a b]))
#+END_SRC
*** Helper functions
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/vectors.cljx
  (declare key-error swizzle2 swizzle3)

  #+clj
  (defn map-entry [k v]
    (reify
      clojure.lang.IMapEntry
      java.util.Map$Entry

      (key [_] k)
      (getKey [_] k)

      (val [_] v)
      (getValue [_] v)

      (hashCode [_]
        (bit-xor (clojure.lang.Util/hash k) (clojure.lang.Util/hash v)))
      (equals [_ x]
        (and (instance? java.util.Map$Entry x)
             (clojure.lang.Util/equals k (.getKey ^java.util.Map$Entry x))
             (clojure.lang.Util/equals v (.getValue ^java.util.Map$Entry x))))))
#+END_SRC
*** Type implementations
**** 2D
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/vectors.cljx
  (deftype Vec2
      ,#+clj [^double x ^double y _meta]
      ,#+cljs [x y _meta]

      ,#+clj clojure.lang.IObj
      ,#+clj (meta [_] _meta)
      ,#+clj (withMeta [_ m*] (Vec2. x y m*))
      ,#+cljs IMeta
      ,#+cljs (-meta [_] _meta)
      ,#+cljs IWithMeta
      ,#+cljs (-with-meta [_ m*] (Vec2. x y m*))

      ,#+clj clojure.lang.ILookup
      ,#+clj (valAt [this k] (swizzle2 this k nil))
      ,#+clj (valAt [this k nf] (swizzle2 this k nf))
      ,#+cljs ILookup
      ,#+cljs (-lookup [this k] (swizzle2 this k nil))
      ,#+cljs (-lookup [this k nf] (swizzle2 this k nf))

      ,#+clj clojure.lang.IFn
      ,#+clj (invoke [this k] (swizzle2 this k nil))
      ,#+cljs IFn
      ,#+cljs (-invoke [this k] (swizzle2 this k nil))

      ,#+clj clojure.lang.Associative
      ,#+clj clojure.lang.IPersistentVector
      ,#+clj (count [_] 2)
      ,#+clj (length [_] 2)
      ,#+clj (containsKey [_ k] (not (nil? (#{0 1 :x :y} k))))
      ,#+clj (entryAt [this k] (map-entry k (swizzle2 this k nil)))
      ,#+clj (assoc [_ k v]
              (condp = k
                0 (Vec2. v y _meta) 1 (Vec2. x v _meta)
                :x (Vec2. v y _meta) :y (Vec2. x v _meta)
                (key-error k)))
      ,#+clj (assocN [_ k v]
              (condp = k 0 (Vec2. v y _meta) 1 (Vec2. x v _meta) (key-error k)))
      ,#+cljs ICounted
      ,#+cljs (-count [this] 2)
      ,#+cljs IAssociative
      ,#+cljs IVector
      ,#+cljs (-contains-key? [this k]
               (not (nil? (#{0 1 :x :y} k))))
      ,#+cljs (-assoc [this k v]
               (condp = k
                 0 (Vec2. v y _meta) 1 (Vec2. x v _meta)
                 :x (Vec2. v y _meta) :y (Vec2. x v _meta)
                 (key-error k)))
      ,#+cljs (-assoc-n [this k v]
               (condp = k
                 0 (Vec2. v y _meta) 1 (Vec2. x v _meta) (key-error k)))

      ,#+clj clojure.lang.IPersistentCollection
      ,#+clj clojure.lang.Indexed
      ,#+clj clojure.lang.Sequential
      ,#+clj clojure.lang.ISeq
      ,#+clj clojure.lang.Seqable
      ,#+clj (first [_] x)
      ,#+clj (next [_] (cons y nil))
      ,#+clj (more [_] (cons y nil))
      ,#+clj (cons [_ _] (throw (UnsupportedOperationException.)))
      ,#+clj (peek [_] y)
      ,#+clj (pop [_] x)
      ,#+clj (rseq [_] (Vec2. y x _meta))
      ,#+clj (seq [this] this)
      ,#+clj (nth [this k] (condp = k 0 x 1 y (key-error k)))
      ,#+clj (nth [_ k nf] (condp = k 0 x 1 y nf))
      ,#+clj (equiv [this o]
              (if (instance? Vec2 o)
                (and (clojure.lang.Util/equiv x (.-x ^Vec2 o))
                     (clojure.lang.Util/equiv y (.-y ^Vec2 o)))
                (and (= 2 (count o))
                     (clojure.lang.Util/equiv o this))))
      ,#+clj (equals [this o]
              (if (instance? Vec2 o)
                (and (clojure.lang.Util/equals x (.-x ^Vec2 o))
                     (clojure.lang.Util/equals y (.-y ^Vec2 o)))
                (and (= 2 (count o))
                     (clojure.lang.Util/equals o this))))
      ,#+cljs ISequential
      ,#+cljs ISeq
      ,#+cljs (-first [this] x)
      ,#+cljs (-rest [this] (cons y nil))
      ,#+cljs ISeqable
      ,#+cljs (-seq [this] (cons x (cons y nil)))
      ,#+cljs IReversible
      ,#+cljs (-rseq [this] (cons y (cons x nil)))
      ,#+cljs IIndexed
      ,#+cljs (-nth [this n] (case n 0 x 1 y))
      ,#+cljs (-nth [this n nf] (case n 0 x 1 y nf))

      ,#+clj Comparable
      ,#+clj (compareTo [this o]
              (if (instance? Vec2 o)
                (let [c (compare x (.-x o))]
                  (if (== 0 c) (compare y (.-y o)) c))
                (let [c (count o)]
                  (if (== 2 c) (compare o this) (- 2 c)))))
      ,#+clj (hashCode [_]
              (hash-combine (clojure.lang.Util/hash x) (clojure.lang.Util/hash y)))

      ,#+cljs IComparable
      ,#+cljs (-compare [this o]
               (let [c (compare x (.-x o))]
                 (if (== 0 c) (compare y (.-y o)) c)))

      ,#+cljs IHash
      ,#+cljs (-hash [_] (hash-combine (hash x) (hash y)))

      Object
      (toString [_] (str "[" x " " y "]"))

      PVector
      (abs [this]
        (Vec2. (m/abs x) (m/abs y) _meta))
      (add [this a]
        (if (instance? Vec2 a)
          (Vec2. (+ x (.-x a)) (+ y (.-y a)) _meta)
          (Vec2. (+ x (nth a 0 0)) (+ y (nth a 1 0)) _meta)))
      (add [this a b]
        (if (number? a)
          (Vec2. (+ x a) (+ y b) _meta)
          (let [[ax ay] a [bx by] b]
            (Vec2. (+ (+ x ax) bx) (+ (+ y ay) by) _meta))))
      (add-n [this n]
        (Vec2. (+ x n) (+ y n) _meta))

      (sub [this a]
        (if (instance? Vec2 a)
          (Vec2. (- x (.-x a)) (- y (.-y a)) _meta)
          (Vec2. (- x (nth a 0 0)) (- y (nth a 1 0)) _meta)))
      (sub [this a b]
        (if (number? a)
          (Vec2. (- x a) (- y b) _meta)
          (let [[ax ay] a [bx by] b]
            (Vec2. (- (- x ax) bx) (- (- y ay) by) _meta))))
      (sub-n [this n]
        (Vec2. (- x n) (- y n) _meta))

      (scale [this a]
        (if (instance? Vec2 a)
          (Vec2. (* x (.-x a)) (* y (.-y a)) _meta)
          (Vec2. (* x (nth a 0 1)) (* y (nth a 1 1)) _meta)))
      (scale [this a b]
        (if (number? a)
          (Vec2. (* x a) (* y b) _meta)
          (let [[ax ay] a [bx by] b]
            (Vec2. (* (* x ax) bx) (* (* y ay) by) _meta))))
      (scale-n [this n]
        (Vec2. (* x n) (* y n) _meta))

      (dot [this [ax ay]] (+ (* x ax) (* y ay)))
      (cross [this [ax ay]] (- (* x ay) (* y ax)))

      (mag [this] (Math/sqrt (+ (* x x) (* y y))))
      (mag-squared [this] (+ (* x x) (* y y)))

      (dist [this [ax ay]]
        (let [dx (- x ax) dy (- y ay)]
          (Math/sqrt (+ (* dx dx) (* dy dy)))))
      (dist-squared [this [ax ay]]
        (let [dx (- x ax) dy (- y ay)]
          (+ (* dx dx) (* dy dy))))

      (limit [this len]
        (if (> (mag-squared this) (* len len))
          (normalize this len) this))

      (normalize [this]
        (let [l (mag this)]
          (if (pos? l) (Vec2. (/ x l) (/ y l) _meta) this)))
      (normalize [this len]
        (let [l (mag this)]
          (if (pos? l)
            (let [l (/ len l)] (Vec2. (* x l) (* y l) _meta)) this)))

      (invert [this] (Vec2. (- x) (- y) _meta))
      (inverse [this] (Vec2. (/ x) (/ y) _meta))

      (reflect [this [rx ry :as r]]
        (let [d (* (dot this r) 2.0)]
          (Vec2. (- (* rx d) x) (- (* ry d) y) _meta)))

      (minv [this [ax ay]]
        (Vec2. (min x ax) (min y ay) _meta))
      (minv [this [ax ay] [bx by]]
        (Vec2. (min (min x ax) bx) (min (min y ay) by) _meta))
      (maxv [this [ax ay]]
        (Vec2. (max x ax) (max y ay) _meta))
      (maxv [this [ax ay] [bx by]]
        (Vec2. (max (max x ax) bx) (max (max y ay) by) _meta))
      )
#+END_SRC
**** 3D
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/vectors.cljx
  (deftype Vec3
      ,#+clj [^double x ^double y ^double z _meta]
      ,#+cljs [x y z _meta]

      ,#+clj clojure.lang.IObj
      ,#+clj (meta [_] _meta)
      ,#+clj (withMeta [_ m*] (Vec3. x y z m*))
      ,#+cljs IMeta
      ,#+cljs (-meta [_] _meta)
      ,#+cljs IWithMeta
      ,#+cljs (-with-meta [_ m*] (Vec3. x y z m*))

      ,#+clj clojure.lang.ILookup
      ,#+clj (valAt [this k] (swizzle3 this k nil))
      ,#+clj (valAt [this k nf] (swizzle3 this k nf))
      ,#+cljs ILookup
      ,#+cljs (-lookup [this k] (swizzle3 this k nil))
      ,#+cljs (-lookup [this k nf] (swizzle3 this k nf))

      ,#+clj clojure.lang.IFn
      ,#+clj (invoke [this k] (swizzle3 this k nil))
      ,#+cljs IFn
      ,#+cljs (-invoke [this k] (swizzle3 this k nil))

      ,#+clj clojure.lang.Associative
      ,#+clj clojure.lang.IPersistentVector
      ,#+clj (count [_] 3)
      ,#+clj (length [_] 3)
      ,#+clj (containsKey [_ k] (not (nil? (#{0 1 2 :x :y :z} k))))
      ,#+clj (entryAt [_ k])
      ,#+clj (assoc [_ k v]
              (condp = k
                0 (Vec3. v y z _meta)
                1 (Vec3. x v z _meta)
                2 (Vec3. x y v _meta)
                :x (Vec3. v y z _meta)
                :y (Vec3. x v z _meta)
                :z (Vec3. x y v _meta)
                (key-error k)))
      ,#+clj (assocN [_ k v]
              (condp = k
                0 (Vec3. v y z _meta)
                1 (Vec3. x v z _meta)
                2 (Vec3. x y v _meta)
                (key-error k)))
      ,#+cljs ICounted
      ,#+cljs (-count [this] 2)
      ,#+cljs IAssociative
      ,#+cljs IVector
      ,#+cljs (-contains-key? [this k]
               (not (nil? (#{0 1 2 :x :y :z} k))))
      ,#+cljs (-assoc [this k v]
               (condp = k
                 0 (Vec3. v y z _meta)
                 1 (Vec3. x v z _meta)
                 2 (Vec3. x y v _meta)
                 :x (Vec3. v y z _meta)
                 :y (Vec3. x v z _meta)
                 :z (Vec3. x y v _meta)
                 (key-error k)))
      ,#+cljs (-assoc-n [this k v]
               (condp = k
                 0 (Vec3. v y z _meta)
                 1 (Vec3. x v z _meta)
                 2 (Vec3. x y v _meta)
                 (key-error k)))

      ,#+clj clojure.lang.IPersistentCollection
      ,#+clj clojure.lang.Indexed
      ,#+clj clojure.lang.Sequential
      ,#+clj clojure.lang.ISeq
      ,#+clj clojure.lang.Seqable
      ,#+clj (first [_] x)
      ,#+clj (next [_] (cons y (cons z nil)))
      ,#+clj (more [_] (cons y (cons z nil)))
      ,#+clj (cons [_ _] (throw (UnsupportedOperationException.)))
      ,#+clj (peek [_] z)
      ,#+clj (pop [_] (Vec2. x y _meta))
      ,#+clj (rseq [_] (Vec3. z y x _meta))
      ,#+clj (seq [this] this)
      ,#+clj (nth [this n] (condp = n 0 x 1 y 2 z (key-error n)))
      ,#+clj (nth [_ n nf] (condp = n 0 x 1 y 2 z nf))
      ,#+clj (equiv [this o]
              (if (instance? Vec3 o)
                (and (clojure.lang.Util/equiv x (.-x ^Vec3 o))
                     (clojure.lang.Util/equiv y (.-y ^Vec3 o))
                     (clojure.lang.Util/equiv z (.-z ^Vec3 o)))
                (and (= 3 (count o))
                     (clojure.lang.Util/equiv o this))))
      ,#+clj (equals [this o]
              (if (instance? Vec3 o)
                (and (clojure.lang.Util/equals x (.-x ^Vec3 o))
                     (clojure.lang.Util/equals y (.-y ^Vec3 o))
                     (clojure.lang.Util/equals z (.-z ^Vec3 o)))
                (and (= 3 (count o))
                     (clojure.lang.Util/equals o this))))
      ,#+cljs ISequential
      ,#+cljs ISeq
      ,#+cljs (-first [this] x)
      ,#+cljs (-rest [this] (cons y (cons z nil)))
      ,#+cljs ISeqable
      ,#+cljs (-seq [this] this)
      ,#+cljs IReversible
      ,#+cljs (-rseq [this] (Vec3. z y x _meta))
      ,#+cljs IIndexed
      ,#+cljs (-nth [this n] (condp = n 0 x 1 y 2 z (key-error n)))
      ,#+cljs (-nth [this n nf] (condp = n 0 x 1 y 2 z nf))

      ,#+clj Comparable
      ,#+clj (compareTo [this o]
              (if (instance? Vec3 o)
                (let [c (compare x (.-x o))]
                  (if (== 0 c)
                    (let [c (compare y (.-y o))]
                      (if (== 0 c)
                        (compare z (.-z o))
                        c))
                    c))
                (let [c (count o)]
                  (if (== 3 c) (compare o this) (- 3 c)))))
      ,#+clj (hashCode [_]
              (hash-combine
               (hash-combine
                (clojure.lang.Util/hash x)
                (clojure.lang.Util/hash y))
               (clojure.lang.Util/hash z)))
      ,#+cljs IComparable
      ,#+cljs (-compare [this o]
               (let [c (compare x (.-x o))]
                 (if (== 0 c)
                   (let [c (compare y (.-y o))]
                     (if (== 0 c) (compare z (.-z o)) c))
                   c)))
      ,#+cljs IHash
      ,#+cljs (-hash [_]
               (let [seed (* 37 x)]
                 (bit-xor seed
                          (+ (+ (+ 0x9e3779b9 (* y 37))
                                (bit-shift-left seed 6))
                             (bit-shift-right seed 2)))))

      Object
      (toString [_] (str "[" x " " y " " z "]"))

      PVector
      (add [this a]
        (if (instance? Vec3 a)
          (Vec3. (+ x (.-x a)) (+ y (.-y a)) (+ z (.-z a)) _meta)
          (Vec3. (+ x (nth a 0 0)) (+ y (nth a 1 0)) (+ z (nth a 2 0)) _meta)))
      (add [this a b]
        (if (number? a)
          (Vec3. (+ x a) (+ y b) z _meta)
          (let [[ax ay az] a [bx by bz] b]
            (Vec3. (+ (+ x ax) bx) (+ (+ y ay) by) (+ (+ z az) bz) _meta))))
      (add [this a b c]
        (if (number? a)
          (Vec3. (+ x a) (+ y b) (+ z c) _meta)
          (let [[ax ay az] a [bx by bz] b [cx cy cz] c]
            (Vec3. (+ (+ (+ x ax) bx) cx) (+ (+ (+ y ay) by) cy) (+ (+ (+ z az) bz) cz) _meta))))
      (add-n [this n] (Vec3. (+ x n) (+ y n) (+ z n) _meta))

      (sub [this a]
        (if (instance? Vec3 a)
          (Vec3. (- x (.-x a)) (- y (.-y a)) (- z (.-z a)) _meta)
          (Vec3. (- x (nth a 0 0)) (- y (nth a 1 0)) (- z (nth a 2 0)) _meta)))
      (sub [this a b]
        (if (number? a)
          (Vec3. (- x a) (- y b) z _meta)
          (let [[ax ay az] a [bx by bz] b]
            (Vec3. (- (- x ax) bx) (- (- y ay) by) (- (- z az) bz) _meta))))
      (sub [this a b c]
        (if (number? a)
          (Vec3. (- x a) (- y b) (- z c) _meta)
          (let [[ax ay az] a [bx by bz] b [cx cy cz] c]
            (Vec3. (- (- (- x ax) bx) cx) (- (- (- y ay) by) cy) (- (- (- z az) bz) cz) _meta))))
      (sub-n [this n] (Vec3. (- x n) (- y n) (- z n) _meta))

      (scale [this a]
        (if (instance? Vec3 a)
          (Vec3. (* x (.-x a)) (* y (.-y a)) (* z (.-z a)) _meta)
          (Vec3. (* x (nth a 0 1)) (* y (nth a 1 1)) (* z (nth a 2 1)) _meta)))
      (scale [this a b]
        (if (number? a)
          (Vec3. (* x a) (* y b) z _meta)
          (let [[ax ay az] a [bx by bz] b]
            (Vec3. (* (* x ax) bx) (* (* y ay) by) (* (* z az) bz) _meta))))
      (scale [this a b c]
        (if (number? a)
          (Vec3. (* x a) (* y b) (* z c) _meta)
          (let [[ax ay az] a [bx by bz] b [cx cy cz] c]
            (Vec3. (* (* (* x ax) bx) cx) (* (* (* y ay) by) cy) (* (* (* z az) bz) cz) _meta))))
      (scale-n [this n] (Vec3. (* x n) (* y n) (* z n) _meta))

      (dot [this [ax ay az]] (+ (* x ax) (* y ay) (* z az)))
      (cross [this [ax ay az]]
        (Vec3. (- (* y az) (* ay z)) (- (* z ax) (* az x)) (- (* x ay) (* ax y)) _meta))

      (mag [this] (Math/sqrt (+ (+ (* x x) (* y y)) (* z z))))
      (mag-squared [this] (+ (+ (* x x) (* y y)) (* z z)))

      (dist [this [ax ay az]]
        (let [dx (- x ax) dy (- y ay) dz (- z az)]
          (Math/sqrt (+ (+ (* dx dx) (* dy dy)) (* dz dz)))))
      (dist-squared [this [ax ay az]]
        (let [dx (- x ax) dy (- y ay) dz (- z az)]
          (+ (+ (* dx dx) (* dy dy)) (* dz dz))))

      (limit [this len]
        (if (> (mag-squared this) (* len len)) (normalize this len) this))

      (normalize [this]
        (let [l (mag this)]
          (if (pos? l) (Vec3. (/ x l) (/ y l) (/ z l) _meta) this)))
      (normalize [this len]
        (let [l (mag this)]
          (if (pos? l)
            (let [l (/ len l)] (Vec3. (* x l) (* y l) (* z l) _meta)) this)))

      (invert [this] (Vec3. (- x) (- y) (- z) _meta))
      (inverse [this] (Vec3. (/ x) (/ y) (/ z) _meta))

      (reflect [this [rx ry rz :as r]]
        (let [d (* (dot this r) 2.0)]
          (Vec3. (- (* rx d) x) (- (* ry d) y) (- (* rz d) z) _meta)))

      (minv [this [ax ay az]]
        (Vec3. (min x ax) (min y ay) (min z az) _meta))
      (minv [this [ax ay az] [bx by bz]]
        (Vec3. (min (min x ax) bx) (min (min y ay) by) (min (min z az) bz) _meta))
      (maxv [this [ax ay az]]
        (Vec3. (max x ax) (max y ay) (min z az) _meta))
      (maxv [this [ax ay az] [bx by bz]]
        (Vec3. (max (max x ax) bx) (max (max y ay) by) (min (min z az) bz) _meta))
      )
#+END_SRC
*** Swizzling
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/vectors.cljx
  ,#+clj  (defn- key-error [k] (throw (IllegalArgumentException. (str "illegal lookup key: " k))))
  ,#+cljs (defn- key-error [k] (throw (js/Error. (str "illegal lookup key: " k))))

  (defn swizzle2
    [^Vec2 this k default]
    (if (number? k)
      (condp = k
        0 (.-x this)
        1 (.-y this)
        (or default (key-error k)))
      (condp = k
        :x (.-x this)
        :y (.-y this)
        (let [n (name k) c (count n)]
          (condp = c
            1 (or default (key-error k))
            2 (->> n
                   (map #(condp = % \x (.-x this) \y (.-y this) (or default (key-error k))))
                   ((fn [[x y]] (Vec2. x y (.-_meta this)))))
            3 (->> n
                   (map #(condp = % \x (.-x this) \y (.-y this) (or default (key-error k))))
                   ((fn [[x y z]] (Vec3. x y z (.-_meta this)))))
            (or default (key-error k)))))))

  (defn swizzle3
    [^Vec3 this k default]
    (if (number? k)
      (condp = k
        0 (.-x this)
        1 (.-y this)
        2 (.-z this)
        (or default (key-error k)))
      (condp = k
        :x (.-x this)
        :y (.-y this)
        :z (.-z this)
        (let [n (name k) c (count n)]
          (condp = c
            1 (or default (key-error k))
            2 (->> n
                   (map #(condp = % \x (.-x this) \y (.-y this) \z (.-z this) (or default (key-error k))))
                   ((fn [[x y]] (Vec2. x y (.-_meta this)))))
            3 (->> n
                   (map #(condp = % \x (.-x this) \y (.-y this) \z (.-z this) (or default (key-error k))))
                   ((fn [[x y z]] (Vec3. x y z (.-_meta this)))))
            (or default (key-error k)))))))
#+END_SRC
*** Constructors
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/vectors.cljx
  (defn vec2
    [x y] (Vec2. x y nil))

  (defn vec3
    [x y z] (Vec3. x y z nil))
#+END_SRC
