* thi.ng.geom.circle
** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  (ns thi.ng.geom.circle
    (:require
     [thi.ng.data.core :as d]
     [thi.ng.math.core :as m :refer [PI TWO_PI *eps*]]
     [thi.ng.geom.core :as g :refer [vec2 *resolution*]]
     [thi.ng.geom.types :as types])
    #+clj
    (:import
     [thi.ng.geom.types Circle Line2 Polygon Rect Triangle2]))
#+END_SRC
** Constructor
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
(defn circle
  ([] (thi.ng.geom.types.Circle. (vec2) 1.0))
  ([r] (thi.ng.geom.types.Circle. (vec2) r))
  ([p r] (thi.ng.geom.types.Circle. (vec2 p) r))
  ([x y r] (thi.ng.geom.types.Circle. (vec2 x y) r)))
#+END_SRC
** Protocol implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  (extend-type thi.ng.geom.types.Circle
#+END_SRC
*** PGraph
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PGraph
  (vertices
   ([this] (g/vertices this *resolution*))
   ([this res]
      (map #(g/point-at this %) (range 0.0 1.0 (/ 1.0 res)))))
  (edges
   ([this] (g/edges this *resolution*))
   ([this res]
      (let [verts (g/vertices this res)]
        (map (fn [[p q]] (thi.ng.geom.types.Line2. p q))
             (d/successive-nth 2 (concat verts [(first verts)]))))))
#+END_SRC
*** PShape
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PShape
  (area [{r :r}] (* PI (* r r)))
  (bounds
   [{p :p r :r}]
   (let [d (* 2 r)] (thi.ng.geom.types.Rect. (g/sub-n p r) d d)))
  (center
   ([this] (thi.ng.geom.types.Circle. (vec2) (:r this)))
   ([this p] (thi.ng.geom.types.Circle. (vec2 p) (:r this))))
  (centroid [this] (:p this))
  (width  [this] (* 2.0 (:r this)))
  (height [this] (* 2.0 (:r this)))
  (depth  [this] 0)
#+END_SRC
*** PShape2
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
    g/PShape2
    (bounding-circle [this] this)
    (circumference [this] (* TWO_PI (:r this)))
#+END_SRC
*** PBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PBoundary
  (classify-point
   [this q]
   (m/signum (- (:r this) (g/dist (:p this) q)) *eps*))
  (closest-point
   [{p :p r :r} q]
   (g/add p (g/normalize (g/sub q p) r)))
  (contains-point?
   [{p :p r :r} q]
   (<= (g/mag-squared (g/sub p q)) (* r r)))
#+END_SRC
*** PSampleable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PSampleable
  (point-at
   [this t]
   (g/add (:p this) (g/cartesian (vec2 (:r this) (* t TWO_PI)))))
  (random-point
   [this] (g/point-at this (m/random)))
  (random-point-inside
   [this]
   (g/add (:p this) (g/scale-n (g/randvec2) (m/random (:r this)))))
  (sample-uniform [this dist]) ;; TODO
#+END_SRC
*** PPolygonizable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PPolygonizable
  (as-polygon
   ([this] (g/as-polygon this *resolution*))
   ([this res] (thi.ng.geom.types.Polygon. (vec (g/vertices this res)) [])))
#+END_SRC
*** PTessellateable
     A circle can be tessellated into a list of uniform triangles,
     each sharing the circle's centroid. If called without 2nd
     argument the default circle =*resolution*= (a dynamic var defined
     in [[file:geom.org][thi.ng.geom.core]]) will be used.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PTessellateable
  (tessellate
   ([this] (g/tessellate this *resolution*))
   ([{p :p :as this} res]
      (let [verts (g/vertices this res)]
        (->> [(first verts)]
             (concat verts)
             (d/successive-nth 2)
             (map
              (fn [[a b]]
                (thi.ng.geom.types.Triangle2. b p a)))))))
#+END_SRC
*** PExtrudeable
**** TODO use cone implementation
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  g/PExtrudeable
  (extrude
   [this opts])
#+END_SRC
*** End of implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  )
#+END_SRC
** Type specific functions
*** TODO refactor as intersect-shape
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  (defn intersect-circle
    [{p :p r1 :r} {q :p r2 :r}]
    (let [delta (g/sub q p)
          d (g/mag delta)]
      (when (and (<= d (+ r1 r2)) (>= d (m/abs (- r1 r2))))
        (let [a (/ (+ (- (* r1 r1) (* r2 r2)) (* d d)) (* 2.0 d))
              invd (/ 1.0 d)
              p (g/add p (g/scale-n delta (* a invd)))
              h (Math/sqrt (- (* r1 r1) (* a a)))
              perp (g/scale-n (g/normal delta) (* h invd))]
          [(g/add p perp) (g/sub p perp)]))))

  (defn tangent-points
    [{p :p :as c} q]
    (let [m (g/mid p q)]
      (intersect-circle c (circle m (g/dist m p)))))
#+END_SRC
