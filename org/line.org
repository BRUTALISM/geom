* thi.ng.geom.line
** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  (ns thi.ng.geom.line
    (:require
     [thi.ng.data.core :as d]
     [thi.ng.math.core :as m :refer [*eps*]]
     [thi.ng.geom.core :as g :refer [vec2 vec3]]
     [thi.ng.geom.types :as types])
    #+clj
    (:import
     [thi.ng.geom.types Circle Line2 Line3 Polygon]))
#+END_SRC
** Constructors
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  (defn line2
    ([p q] (thi.ng.geom.types.Line2. (vec2 p) (vec2 q)))
    ([px py qx qy] (thi.ng.geom.types.Line2. (vec2 px py) (vec2 qx qy))))

  (defn line3
    ([p q] (thi.ng.geom.types.Line3. (vec3 p) (vec3 q)))
    ([px py qx qy] (thi.ng.geom.types.Line3. (vec3 px py) (vec3 qx qy)))
    ([px py pz qx qy qz] (thi.ng.geom.types.Line3. (vec3 px py pz) (vec3 qx qy qz))))
#+END_SRC
** Shared helper functions
    This function is going to be used for both 2D/3D implementations:
*** TODO replace closest-point-coeff with full closest-point impl
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  (defn closest-point*
    [p a b]
    (let [d (g/sub b a)
          t (/ (g/dot (g/sub p a) d) (g/mag-squared d))]
      (cond
        (<= t 0.0) a
        (> t 1.0) b
        :default (g/mix a b t))))

  (defn as-linestrip
    [a b res include-b?]
    (let [ls (for [t (range 0 1.0 (/ 1.0 res))] (g/mix a b t))]
      (if include-b? (concat ls [b]) ls)))

  (defn arc-length
    [points]
    (->> points
         (d/successive-nth 2)
         (map #(g/dist (% 0) (% 1)))
         (reductions + 0)
         (vec)))

  (defn sample-uniform*
    [step include-last? points]
    (let [idx (arc-length points)
          total (peek idx)
          delta (/ step total)
          samples (loop [t 0.0 i 1 acc []]
                    (if (< t 1.0)
                      (let [ct (* t total)
                            i (loop [i i] (if (>= ct (idx i)) (recur (inc i)) i))
                            p (nth points (dec i))
                            q (nth points i)
                            pi (idx (dec i))
                            frac (/ (- ct pi) (- (idx i) pi))]
                        (recur (+ t delta) i (conj acc (g/mix p q frac))))
                      acc))]
      (if include-last?
        (conj samples (last points))
        samples)))
#+END_SRC
** Line2
*** Protocol implementations
**** TODO verify point equiv if arg is clj vector, not vec2/3
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  (extend-type thi.ng.geom.types.Line2
#+END_SRC
**** PGraph
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PGraph
  (vertices
   [this] [(:p this) (:q this)])
  (edges
   [this] [this])
  (vertex-neighbors
   [{p :p q :q} v] (condp = v p q q p nil))
  (vertex-valence
   [this v] (if (or (= v (:p this)) (= v (:q this))) 1 0))
#+END_SRC
**** PShape
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PShape
  (area [this] 0)
  (bounds
   [this] (g/bounding-rect* [(:p this) (:q this)]))
  (center
   ([{p :p q :q}]
      (let [c (g/mix p q)] (thi.ng.geom.types.Line2. (g/sub p c) (g/sub q c))))
   ([{p :p q :q} o]
      (let [c (g/sub o (g/mix p q))] (thi.ng.geom.types.Line2. (g/add p c) (g/add q c)))))
  (centroid
   [this] (g/mix (:p this) (:q this)))
  (width  [this] (m/abs (- ((:p this) 0) ((:q this) 0))))
  (height [this] (m/abs (- ((:p this) 1) ((:q this) 1))))
  (depth  [this] 0)
#+END_SRC
**** PShape2
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PShape2
  (bounding-circle
   [{p :p q :q}]
   (thi.ng.geom.types.Circle. (g/mix p q) (* 0.5 (g/dist p q))))
  (circumference
   [this] (* 2.0 (g/dist (:p this) (:q this))))
#+END_SRC
**** PBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PBoundary
  (classify-point
   [{p :p q :q} v]
   (m/signum (g/dot (g/sub v p) (g/normal (g/sub q p))) *eps*))
  (closest-point
   [this a] (closest-point* a (:p this) (:q this)))
  (contains-point?
   [this a] (m/delta= (closest-point* a (:p this) (:q this)) a *eps*))
#+END_SRC
**** PSampleable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PSampleable
  (point-at
   [this t] (g/mix (:p this) (:q this) t))
  (random-point
   [this] (g/mix (:p this) (:q this) (m/random)))
  (random-point-inside
   [this] (g/mix (:p this) (:q this) (m/random)))
  (sample-uniform
   [this dist] nil) ;; TODO
#+END_SRC
**** PIntersectable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PIntersectable
  (intersect-line
   [{[px1 py1 :as p] :p [qx1 qy1 :as q] :q :as this}
    {[px2 py2 :as lp] :p [qx2 qy2 :as lq] :q}]
   (let [denom (- (* (- qy2 py2) (- qx1 px1)) (* (- qx2 px2) (- qy1 py1)))
         na (- (* (- qx2 px2) (- py1 py2)) (* (- qy2 py2) (- px1 px2)))
         nb (- (* (- qx1 px1) (- py1 py2)) (* (- qy1 py1) (- px1 px2)))]
     (if-not (zero? denom)
       (let [ua (/ na denom) ub (/ nb denom) ipos (g/mix p q ua)]
         (if (and (>= ua 0.0) (<= ua 1.0) (>= ub 0.0) (<= ub 1.0))
           {:type :intersect :p ipos :ua ua :ub ub}
           {:type :intersect-outside :p ipos :ua ua :ub ub}))
       (if (and (zero? na) (zero? nb))
         (let [ip (g/closest-point this lp)
               iq (g/closest-point this lq)]
           (if (or (m/delta= ip lp) (m/delta= iq lq))
             {:type :coincident :p ip :q iq}
             {:type :coincident-no-intersect :p ip :q iq}))
         {:type :parallel}))))
#+END_SRC
**** End of implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  )
#+END_SRC
** Line3
*** Protocol implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  (extend-type thi.ng.geom.types.Line3
#+END_SRC
**** PGraph
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PGraph
  (vertices
   [this] [(:p this) (:q this)])
  (edges
   [this] [this])
  (vertex-neighbors
   [{p :p q :q} v] (condp = v p q q p nil))
  (vertex-valence
   [this v] (if (or (= v (:p this)) (= v (:q this))) 1 0))
#+END_SRC
**** PShape
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PShape
  (area [this] 0)
  (bounds
   [this] (g/bounding-box* [(:p this) (:q this)]))
  (center
   ([{p :p q :q}]
      (let [c (g/mix p q)] (thi.ng.geom.types.Line3. (g/sub p c) (g/sub q c))))
   ([{p :p q :q} o]
      (let [c (g/sub o (g/mix p q))]
        (thi.ng.geom.types.Line3. (g/add p c) (g/add q c)))))
  (centroid
   [this] (g/mix (:p this) (:q this)))
  (width  [this] (m/abs (- ((:p this) 0) ((:q this) 0))))
  (height [this] (m/abs (- ((:p this) 1) ((:q this) 1))))
  (depth  [this] (m/abs (- ((:p this) 2) ((:q this) 2))))
#+END_SRC
**** PShape3
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PShape3
  (bounding-sphere
   [{p :p q :q}]
   (g/bounding-sphere* (g/mix p q) (* 0.5 (g/dist p q))))
  (volume [this] 0.0)
#+END_SRC
**** PBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PBoundary
  (classify-point
   [{p :p q :q} p] nil) ; TODO
  (closest-point
   [this a] (closest-point* a (:p this) (:q this)))
  (contains-point?
   [this a] (m/delta= (closest-point* a (:p this) (:q this)) a *eps*))
#+END_SRC
**** PSampleable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PSampleable
  (point-at
   [this t] (g/mix (:p this) (:q this) t))
  (random-point
   [this] (g/mix (:p this) (:q this) (m/random)))
  (random-point-inside
   [this] (g/mix (:p this) (:q this) (m/random)))
#+END_SRC
**** TODO PIntersectable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx

#+END_SRC
**** End of implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  )
#+END_SRC
