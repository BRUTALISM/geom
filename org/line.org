* thi.ng.geom.line
** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  (ns thi.ng.geom.line
    (:require
     [thi.ng.data.core :as d]
     [thi.ng.math.core :as m :refer [*eps*]]
     [thi.ng.geom.core :as g]
     [thi.ng.geom.types :as types])
    #+clj
    (:import
     [thi.ng.geom.types Circle Line2 Line3 Polygon]))
#+END_SRC
** Constructors
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  (defn line2
    ([p q] (thi.ng.geom.types.Line2. (g/vec2 p) (g/vec2 q)))
    ([px py qx qy] (thi.ng.geom.types.Line2. (g/vec2 px py) (g/vec2 qx qy))))

  (defn line3
    ([p q] (thi.ng.geom.types.Line3. (g/vec3 p) (g/vec3 q)))
    ([px py qx qy] (thi.ng.geom.types.Line3. (g/vec3 px py) (g/vec3 qx qy)))
    ([px py pz qx qy qz] (thi.ng.geom.types.Line3. (g/vec3 px py pz) (g/vec3 qx qy qz))))
#+END_SRC
** Shared helper functions
    This function is going to be used for both 2D/3D implementations:
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  (defn closest-point-coeff
    [fsub fdot fmag p a b]
    (let [d (fsub b a)] (/ (fdot (fsub p a) d) (fmag d))))

  (defn as-linestrip
    [mix a b res include-b?]
    (let [ls (for [t (range 0 1.0 (/ 1.0 res))] (mix a b t))]
      (if include-b? (concat ls [b]) ls)))

  (defn arc-length
    [mag points]
    (->> points
         (d/successive-nth 2)
         (map #(mag (% 0) (% 1)))
         (reductions + 0)
         (vec)))

  (defn sample-uniform*
    [mix mag step include-last? points]
    (let [idx (arc-length mag points)
          total (peek idx)
          delta (/ step total)
          samples (loop [t 0.0 i 1 acc []]
                    (if (< t 1.0)
                      (let [ct (* t total)
                            i (loop [i i] (if (>= ct (idx i)) (recur (inc i)) i))
                            p (nth points (dec i))
                            q (nth points i)
                            pi (idx (dec i))
                            frac (/ (- ct pi) (- (idx i) pi))]
                        (recur (+ t delta) i (conj acc (mix p q frac))))
                      acc))]
      (if include-last?
        (conj samples (last points))
        samples)))
#+END_SRC
** Line2
*** Protocol implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  (extend-type thi.ng.geom.types.Line2
#+END_SRC
**** IGraph
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/IGraph
  (vertices [this] [(:p this) (:q this)])
  (edges [this] [this])
#+END_SRC
**** IShape
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/IShape
  (area [this] 0)
  (bounds
   [this] (g/bounding-rect* [(:p this) (:q this)]))
  (center
   ([{p :p q :q}]
      (let [c (g/mid2 p q)] (thi.ng.geom.types.Line2. (g/sub2 p c) (g/sub2 q c))))
   ([{p :p q :q} o]
      (let [c (g/sub2 o (g/mid2 p q))] (thi.ng.geom.types.Line2. (g/add2 p c) (g/add2 q c)))))
  (centroid
   [this] (g/mid2 (:p this) (:q this)))
  (width  [this] (m/abs (- ((:p this) 0) ((:q this) 0))))
  (height [this] (m/abs (- ((:p this) 1) ((:q this) 1))))
  (depth  [this] 0)
#+END_SRC
**** IShape2
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/IShape2
  (bounding-circle
   [{p :p q :q}]
   (g/bounding-circle* (g/mid2 p q) (* 0.5 (g/dist2 p q))))
  (circumference
   [this] (* 2 (g/dist2 (:p this) (:q this))))
#+END_SRC
**** IBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/IBoundary
  (classify-point
   [{p :p q :q} v]
   ;; TODO use -> macro
   (m/signum (g/dot2 (g/sub2 v p) (g/perpendicular2 (g/sub2 q p))) *eps*))
  (closest-point
   [{p :p q :q} a]
   (let [t (closest-point-coeff g/sub2 g/dot2 g/mag2-squared a p q)]
     (cond
      (<= t 0.0) p
      (> t 1.0) q
      :default (g/mix2 p q t))))
  (contains-point?
   [this p] (= (g/closest-point this p) p))
#+END_SRC
**** ISampleable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/ISampleable
  (point-at
   [this t] (g/mix2 (:p this) (:q this) t))
  (random-point
   [this] (g/mix2 (:p this) (:q this) (m/random)))
  (random-point-inside
   [this] (g/mix2 (:p this) (:q this) (m/random)))
  (sample-uniform
   [this dist] nil) ;; TODO
#+END_SRC
**** IIntersectable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/IIntersectable
  (intersect-line
   [{[px1 py1 :as p] :p [qx1 qy1 :as q] :q :as this}
    {[px2 py2 :as lp] :p [qx2 qy2 :as lq] :q}]
   (let [denom (- (* (- qy2 py2) (- qx1 px1)) (* (- qx2 px2) (- qy1 py1)))
         na (- (* (- qx2 px2) (- py1 py2)) (* (- qy2 py2) (- px1 px2)))
         nb (- (* (- qx1 px1) (- py1 py2)) (* (- qy1 py1) (- px1 px2)))]
     (if-not (zero? denom)
       (let [ua (/ na denom) ub (/ nb denom) ipos (g/mix2 p q ua)]
         (if (and (>= ua 0.0) (<= ua 1.0) (>= ub 0.0) (<= ub 1.0))
           {:type :intersect :p ipos :ua ua :ub ub}
           {:type :intersect-outside :p ipos :ua ua :ub ub}))
       (if (and (zero? na) (zero? nb))
         (let [ip (g/closest-point this lp)
               iq (g/closest-point this lq)]
           (if (or (m/delta= ip lp) (m/delta= iq lq))
             {:type :coincident :p ip :q iq}
             {:type :coincident-no-intersect :p ip :q iq}))
         {:type :parallel}))))
#+END_SRC
**** End of implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  )
#+END_SRC
** Line3
*** Protocol implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  (extend-type thi.ng.geom.types.Line3
#+END_SRC
**** IGraph
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/IGraph
  (vertices [this] [(:p this) (:q this)])
  (edges [this] [this])
#+END_SRC
**** IShape
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/IShape
  (area [this] 0)
  (bounds
   [this] (g/bounding-box* [(:p this) (:q this)]))
  (center
   ([{p :p q :q}]
      (let [c (g/mid3 p q)] (thi.ng.geom.types.Line3. (g/sub3 p c) (g/sub3 q c))))
   ([{p :p q :q} o]
      (let [c (g/sub3 o (g/mid3 p q))]
        (thi.ng.geom.types.Line3. (g/add3 p c) (g/add3 q c)))))
  (centroid
   [this] (g/mid3 (:p this) (:q this)))
  (width  [this] (m/abs (- ((:p this) 0) ((:q this) 0))))
  (height [this] (m/abs (- ((:p this) 1) ((:q this) 1))))
  (depth  [this] (m/abs (- ((:p this) 2) ((:q this) 2))))
#+END_SRC
**** IShape3
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/IShape3
  (bounding-sphere
   [{p :p q :q}]
   (g/bounding-sphere* (g/mid3 p q) (* 0.5 (g/dist3 p q))))
  (volume [this] 0.0)
#+END_SRC
**** IBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/IBoundary
  (classify-point
   [{p :p q :q} p] nil) ; TODO
  (closest-point
   [{p :p q :q} a]
   (let [t (closest-point-coeff g/sub3 g/dot3 g/mag3-squared a p q)]
     (cond
      (<= t 0.0) p
      (>= t 1.0) q
      :default (g/mix3 p q t))))
  (contains-point?
   [{p :p q :q} p] nil) ; TODO
#+END_SRC
**** ISampleable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/ISampleable
  (point-at
   [this t] (g/mix3 (:p this) (:q this) t))
  (random-point
   [this] (g/mix3 (:p this) (:q this) (m/random)))
  (random-point-inside
   [this] (g/mix3 (:p this) (:q this) (m/random)))
#+END_SRC
**** TODO IIntersectable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx

#+END_SRC
**** End of implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  )
#+END_SRC
