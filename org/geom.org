* Namespace: thi.ng.geom
  Providing an easy-to-use & easy-to-learn API for both common and
  advanced geometry operations is one of this project's main focal
  points. We attempt to realise this by defining all operations in
  the form of protocols which are then implemented by various core
  types.
** Outstanding tasks
*** TODO Re-insert advanced polygon fns and update ns decl
*** TODO extract LineStrip defrecords & protocols
*** TODO refactor bezier ns to use linestrips
*** TODO implement shape/shape intersections
*** TODO add NURBS
*** TODO add voxel ns
** Core API
*** thi.ng.geom.types
**** 2D types
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (ns thi.ng.geom.types)
#+END_SRC
***** Line
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Line2 [p q])
#+END_SRC
***** Triangle
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Triangle2 [a b c])
#+END_SRC
***** Ellipse
     Even though a circle is a specialization of an Ellipse, we define
     an extra Circle type for performance reasons.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  #+clj  (defrecord Ellipse [p ^double rx ^double ry])
  #+clj  (defrecord Circle [p ^double r])

  #+cljs (defrecord Ellipse [p rx ry])
  #+cljs (defrecord Circle [p r])
#+END_SRC
***** Rectangle
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  #+clj  (defrecord Rect [p ^double w ^double h])
  #+cljs (defrecord Rect [p w h])
#+END_SRC
***** Polygon
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Polygon [points holes])
#+END_SRC
***** Mesh
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Mesh2 [vertices normals fnormals vnormals edges faces attribs])
#+END_SRC
**** 3D types
***** Line
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Line3 [p q])
#+END_SRC
***** Plane
      A plane in cartesian 3D space can be defined as a point =p=
      lying on the plane and normal vector =n= standing perpendicular
      on the plane. The latter defines the plane's orientation in space.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Plane [p n])
#+END_SRC
***** Triangle
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Triangle3 [a b c])
#+END_SRC
***** AABB
      An Axis-aligned bounding box is defined as the cartesian volume
      extending for =size= units (a 3D vector) from point =p= toward
      positive infinity.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord AABB [p size])
#+END_SRC
***** Sphere
      Just like a circle in 2D, a 3D sphere is uniquely defined via
      its center point =o= and radius =r=.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  #+clj  (defrecord Sphere [o ^double r])
  #+cljs (defrecord Sphere [o r])
#+END_SRC
***** Mesh
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Mesh3 [vertices normals fnormals vnormals edges faces attribs])
#+END_SRC
*** thi.ng.geom.core
    This namespace contains all basic vector operations and core
    protocols related to common higher level geometric operations.
**** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (ns thi.ng.geom.core
    (:require
     [thi.ng.math.core :as m :refer [*eps* PI TWO_PI]]
     [thi.ng.geom.types :as types])
    #+clj
    (:import
     [thi.ng.geom.types Circle Rect AABB Sphere]))
#+END_SRC
**** Protocols
***** Vector operations
****** PVector
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PVector
    (abs [this])
    (add [this a] [this a b] [this a b c])
    (add-n [this n])
    (sub [this a] [this a b] [this a b c])
    (sub-n [this n])
    (scale [this a] [this a b] [this a b c])
    (scale-n [this n])
    (madd [this a b])
    (dot [this a])
    (cross [this a])
    (mag [this])
    (mag-squared [this])
    (dist [this a])
    (dist-squared [this a])
    (normalize [this] [this len])
    (limit [this len])
    (invert [this])
    (inverse [this])
    (reflect [this r])
    (minv [this a] [this a b])
    (maxv [this a] [this a b]))
#+END_SRC
****** PHeading
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PHeading
    (heading-xy [this])
    (heading-xz [this])
    (heading-yz [this])
    (angle-between [this a])
    (normal [this] [this a])
    (slope-xy [this])
    (slope-xz [this])
    (slope-yz [this]))
#+END_SRC
****** PPolar
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PPolar
    (polar [this])
    (cartesian [this]))
#+END_SRC
***** Spatial transform operations
      The position, size and orientation of spatial entities can
      usually be manipulated via the three basic operations: rotate,
      scale & translate. Other, more complex transformations can be
      achieved through combination and repetition of these.
****** TODO merge all into PTransformable??
****** PRotatable
       Rotation is always relative to the world origin. For 2D
       implementations, the rotation angle \theta (theta) is always
       interpreted clockwise and only the =rotate= method is
       implemented.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PRotatable
    (rotate [this t])
    (rotate-x [this t])
    (rotate-y [this t])
    (rotate-z [this t])
    (rotate-axis [this a t]))
#+END_SRC
******* TODO Maybe rotate-x etc could be implemented to, but return a 3D entity instead?
****** PScalable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PScalable
    (scale-x [this x])
    (scale-y [this y])
    (scale-z [this z]))
#+END_SRC
****** PTranslatable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PTranslatable
    (translate [this t])
    (translate-x [this x])
    (translate-y [this y])
    (translate-z [this z]))
#+END_SRC
****** PTransformable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol ITransform
    (transform [this matrix]))
#+END_SRC
***** Shape based & structural operations
****** PGraph
      Most geometric shape constructs can be understood as an
      undirected graph of vertices, connected by edges. This protocol
      provides read access to entities in this context.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PGraph
    (edges [this] [this res])
    (vertices [this] [this res])
    (vertex-valence [this v])
    (vertex-neighbors [this v]))
#+END_SRC
****** PShape
      We use the term "shape" as the most general spatial entity
      above the layer of simple points in space. In this context they
      can be understood as having several shared properties, like
      surface area, a bounding shape etc.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PShape
    (area [this]
      "Returns surface area")
    (bounds [this]
      "Returns bounding rect for 2d entities or box for 3d")
    (center [this] [this o]
      "Returns updated entity centered around world origin or given point")
    (centroid [this]
      "Returns centroid of entity")
    (width [this]
      "Returns entity's extent along X axis")
    (height [this]
      "Returns entity's extent along Y axis")
    (depth [this]
      "Returns entity's extent along Z (zero for 2d)"))
#+END_SRC
****** PShape2
       This protocol provides access to more shape properties only
       available in 2d space.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PShape2
    (bounding-circle [this])
    (circumference [this]))
#+END_SRC
****** PShape3
       This protocol provides access to more shape properties only
       available in 3d space.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PShape3
    (bounding-sphere [this])
    (volume [this]))
#+END_SRC
****** PBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PBoundary
    (classify-point [this p])
    (closest-point [this p])
    (contains-point? [this p]))
#+END_SRC
****** PInterpolateable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PInterpolateable
    (mix [this x] [this x t]))
#+END_SRC
****** PSampleable
******* TODO move random-point-inside into PBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PSampleable
    (point-at [this t])
    (random-point [this])
    (random-point-inside [this])
    (sample-uniform [this dist]))
#+END_SRC
****** PPolygonizable
       Anything which can be turned into a 2D polygon will implement this
       protocol consisting of just this one function: =as-polygon=.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PPolygonizable
    (as-polygon [this] [this res]
      "Transforms current entity into a Polygon instance"))
#+END_SRC
****** PMeshable
       Anything which can be turned into a 2D or 3D mesh will implement this
       protocol consisting of just this one function: =as-mesh=.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PMeshable
    (as-mesh [this] [this opts]
      "Transforms the current enitity into a Mesh instance"))
 #+END_SRC
****** PIntersectable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PIntersectable
    (intersect-line [this l])
    (intersect-ray [this r])
    (intersects-shape? [this s]))
#+END_SRC
****** PSliceable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PSliceable
    (slice-with [this e] [this e classifier] [this e classifier parts]))
#+END_SRC
****** PSubdivideable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PSubdivideable
    (subdivide [this] [this opts])
    (subdivide-edge [this a b splits])
    (subdivide-face [this f p displace splits]))
#+END_SRC
****** PTessellateable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PTessellateable
    (tessellate [this] [this opts]))
#+END_SRC
****** PExtrudeable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PExtrudeable
    (extrude [this opts]))
#+END_SRC
***** Type specific operations
****** PLineStrip
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PLineStrip
    (arc-length [this]))
#+END_SRC
****** PMesh
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PMesh
    (add-face [this f])
    (add-mesh [this m])
    (remove-face [this f])
    (remove-vertex [this v])
    (replace-vertex [this v])
    (vertex-faces [this v])
    (merge-vertices [this a b]))
#+END_SRC
**** Constants
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (def ^:dynamic *resolution* 20)
#+END_SRC
**** Declarations
     Some functions used by the following vector types will be
     defined further on, but need to be declared already.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (declare map-entry key-error swizzle2 swizzle3)
#+END_SRC
**** Vector implementations
     For performance reasons, we decided to define custom datatypes
     for handling vectors & matrices. These types can be used much
     like standard Clojure vectors since they all implement the same
     protocols and interfaces, but also provide implementations for
     [[PVector]] and provide custom key lookups to provide swizzling features.

     Furthermore, since we aim for full ClojureScript compatibiliy,
     the following implementations are quite lengthy.
***** 2D
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (deftype Vec2 [^double x ^double y _meta]

    ,#+clj clojure.lang.IObj
    ,#+clj (meta [_] _meta)
    ,#+clj (withMeta [_ m*] (Vec2. x y m*))
    ,#+cljs IMeta
    ,#+cljs (-meta [_] _meta)
    ,#+cljs IWithMeta
    ,#+cljs (-with-meta [_ m*] (Vec2. x y m*))

    ,#+clj clojure.lang.ILookup
    ,#+clj (valAt [this k] (swizzle2 this k nil))
    ,#+clj (valAt [this k nf] (swizzle2 this k nf))
    ,#+cljs ILookup
    ,#+cljs (-lookup [this k] (swizzle2 this k nil))
    ,#+cljs (-lookup [this k nf] (swizzle2 this k nf))

    ,#+clj clojure.lang.IFn
    ,#+clj (invoke [this k] (swizzle2 this k nil))
    ,#+cljs IFn
    ,#+cljs (-invoke [this k] (swizzle2 this k nil))

    ,#+clj clojure.lang.Associative
    ,#+clj clojure.lang.IPersistentVector
    ,#+clj (count [_] 2)
    ,#+clj (length [_] 2)
    ,#+clj (containsKey [_ k] (not (nil? (#{0 1 :x :y} k))))
    ,#+clj (entryAt [this k] (map-entry k (swizzle2 this k nil)))
    ,#+clj (assoc [_ k v]
            (condp = k
              0 (Vec2. v y _meta) 1 (Vec2. x v _meta)
              :x (Vec2. v y _meta) :y (Vec2. x v _meta)
              (key-error k)))
    ,#+clj (assocN [_ k v]
            (condp = k 0 (Vec2. v y _meta) 1 (Vec2. x v _meta) (key-error k)))
    ,#+cljs ICounted
    ,#+cljs (-count [this] 2)
    ,#+cljs IAssociative
    ,#+cljs IVector
    ,#+cljs (-contains-key? [this k]
             (not (nil? (#{0 1 :x :y} k))))
    ,#+cljs (-assoc [this k v]
             (condp = k
               0 (Vec2. v y _meta) 1 (Vec2. x v _meta)
               :x (Vec2. v y _meta) :y (Vec2. x v _meta)
               (key-error k)))
    ,#+cljs (-assoc-n [this k v]
             (condp = k
               0 (Vec2. v y _meta) 1 (Vec2. x v _meta) (key-error k)))

    ,#+clj clojure.lang.IPersistentCollection
    ,#+clj clojure.lang.Indexed
    ,#+clj clojure.lang.Sequential
    ,#+clj clojure.lang.ISeq
    ,#+clj clojure.lang.Seqable
    ,#+clj (first [_] x)
    ,#+clj (next [_] (cons y nil))
    ,#+clj (more [_] (cons y nil))
    ,#+clj (cons [_ _] (throw (UnsupportedOperationException.)))
    ,#+clj (peek [_] y)
    ,#+clj (pop [_] x)
    ,#+clj (rseq [_] (Vec2. y x _meta))
    ,#+clj (seq [this] this)
    ,#+clj (nth [this k] (condp = k 0 x 1 y (key-error k)))
    ,#+clj (nth [_ k nf] (condp = k 0 x 1 y nf))
    ,#+clj (equiv [this o]
            (if (instance? Vec2 o)
              (and (clojure.lang.Util/equiv x (.-x ^Vec2 o))
                   (clojure.lang.Util/equiv y (.-y ^Vec2 o)))
              (and (= 2 (count o))
                   (clojure.lang.Util/equiv o this))))
    ,#+clj (equals [this o]
            (if (instance? Vec2 o)
              (and (clojure.lang.Util/equals x (.-x ^Vec2 o))
                   (clojure.lang.Util/equals y (.-y ^Vec2 o)))
              (and (= 2 (count o))
                   (clojure.lang.Util/equals o this))))
    ,#+cljs ISequential
    ,#+cljs ISeq
    ,#+cljs (-first [this] x)
    ,#+cljs (-rest [this] (cons y nil))
    ,#+cljs ISeqable
    ,#+cljs (-seq [this] (cons x (cons y nil)))
    ,#+cljs IReversible
    ,#+cljs (-rseq [this] (cons y (cons x nil)))
    ,#+cljs IIndexed
    ,#+cljs (-nth [this n] (case n 0 x 1 y))
    ,#+cljs (-nth [this n nf] (case n 0 x 1 y nf))

    ,#+clj Comparable
    ,#+clj (compareTo [this o]
            (if (instance? Vec2 o)
              (let [c (compare x (.-x ^Vec2 o))]
                (if (== 0 c) (compare y (.-y ^Vec2 o)) c))
              (let [c (count o)]
                (if (== 2 c) (compare o this) (- 2 c)))))
    ,#+clj (hashCode [_]
            (hash-combine (clojure.lang.Util/hash x) (clojure.lang.Util/hash y)))

    ,#+cljs IComparable
    ,#+cljs (-compare [this o]
             (let [c (compare x (.-x ^Vec2 o))]
               (if (== 0 c) (compare y (.-y ^Vec2 o)) c)))

    ,#+cljs IHash
    ,#+cljs (-hash [_] (hash-combine (hash x) (hash y)))

    Object
    (toString [_] (str "[" x " " y "]"))

    PVector
    (abs [this]
      (Vec2. (m/abs x) (m/abs y) _meta))
    (add [this a]
      (if (instance? Vec2 a)
        (Vec2. (+ x (.-x ^Vec2 a)) (+ y (.-y ^Vec2 a)) _meta)
        (Vec2. (+ x (nth a 0 0)) (+ y (nth a 1 0)) _meta)))
    (add [this a b]
      (if (number? a)
        (Vec2. (+ x a) (+ y b) _meta)
        (let [[ax ay] a [bx by] b]
          (Vec2. (+ (+ x ax) bx) (+ (+ y ay) by) _meta))))
    (add-n [this n]
      (Vec2. (+ x n) (+ y n) _meta))

    (sub [this a]
      (if (instance? Vec2 a)
        (Vec2. (- x (.-x ^Vec2 a)) (- y (.-y ^Vec2 a)) _meta)
        (Vec2. (- x (nth a 0 0)) (- y (nth a 1 0)) _meta)))
    (sub [this a b]
      (if (number? a)
        (Vec2. (- x a) (- y b) _meta)
        (let [[ax ay] a [bx by] b]
          (Vec2. (- (- x ax) bx) (- (- y ay) by) _meta))))
    (sub-n [this n]
      (Vec2. (- x n) (- y n) _meta))

    (scale [this a]
      (if (instance? Vec2 a)
        (Vec2. (* x (.-x ^Vec2 a)) (* y (.-y ^Vec2 a)) _meta)
        (Vec2. (* x (nth a 0 1)) (* y (nth a 1 1)) _meta)))
    (scale [this a b]
      (if (number? a)
        (Vec2. (* x a) (* y b) _meta)
        (let [[ax ay] a [bx by] b]
          (Vec2. (* (* x ax) bx) (* (* y ay) by) _meta))))
    (scale-n [this n]
      (Vec2. (* x n) (* y n) _meta))

    (madd [this a b] (add ((if (number? a) scale-n scale) this a) b))

    (dot [this [ax ay]] (+ (* x ax) (* y ay)))
    (cross [this [ax ay]] (- (* x ay) (* y ax)))

    (mag [this] (Math/sqrt (+ (* x x) (* y y))))
    (mag-squared [this] (+ (* x x) (* y y)))

    (dist [this [ax ay]]
      (let [dx (- x ax) dy (- y ay)]
        (Math/sqrt (+ (* dx dx) (* dy dy)))))
    (dist-squared [this [ax ay]]
      (let [dx (- x ax) dy (- y ay)]
        (+ (* dx dx) (* dy dy))))

    (limit [this len]
      (if (> (mag-squared this) (* len len))
        (normalize this len) this))

    (normalize [this]
      (let [l (mag this)]
        (if (pos? l) (Vec2. (/ x l) (/ y l) _meta) this)))
    (normalize [this len]
      (let [l (mag this)]
        (if (pos? l)
          (let [l (/ len l)] (Vec2. (* x l) (* y l) _meta)) this)))

    (invert [this] (Vec2. (- x) (- y) _meta))
    (inverse [this] (Vec2. (/ 1.0 x) (/ 1.0 y) _meta))

    (reflect [this [rx ry :as r]]
      (let [d (* (dot this r) 2.0)]
        (Vec2. (- (* rx d) x) (- (* ry d) y) _meta)))

    (minv [this [ax ay]]
      (Vec2. (min x ax) (min y ay) _meta))
    (minv [this [ax ay] [bx by]]
      (Vec2. (min (min x ax) bx) (min (min y ay) by) _meta))
    (maxv [this [ax ay]]
      (Vec2. (max x ax) (max y ay) _meta))
    (maxv [this [ax ay] [bx by]]
      (Vec2. (max (max x ax) bx) (max (max y ay) by) _meta))

    PInterpolateable
    (mix [this [ax ay]]
      (Vec2. (+ x (* (- ax x) 0.5)) (+ y (* (- ay y) 0.5)) _meta))
    (mix [this [ax ay] t]
      (Vec2. (+ x (* (- ax x) t)) (+ y (* (- ay y) t)) _meta))

    PHeading
    (heading-xy [this]
      (let [t (Math/atan2 y x)]
        (if (neg? t) (+ TWO_PI t) t)))
    (angle-between [this a]
      (let [t (- (heading-xy a) (heading-xy this))]
        (if (neg? t) (+ TWO_PI t) t)))
    (slope-xy [this] (/ y x))
    (normal [this] (Vec2. (- y) x _meta))

    PPolar
    (polar [this]
      (Vec2. (mag this) (heading-xy this) _meta))
    (cartesian [this]
      (Vec2. (* x (Math/cos y)) (* x (Math/sin y)) _meta))
    )
#+END_SRC
***** 3D
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (deftype Vec3 [^double x ^double y ^double z _meta]

    ,#+clj clojure.lang.IObj
    ,#+clj (meta [_] _meta)
    ,#+clj (withMeta [_ m*] (Vec3. x y z m*))
    ,#+cljs IMeta
    ,#+cljs (-meta [_] _meta)
    ,#+cljs IWithMeta
    ,#+cljs (-with-meta [_ m*] (Vec3. x y z m*))

    ,#+clj clojure.lang.ILookup
    ,#+clj (valAt [this k] (swizzle3 this k nil))
    ,#+clj (valAt [this k nf] (swizzle3 this k nf))
    ,#+cljs ILookup
    ,#+cljs (-lookup [this k] (swizzle3 this k nil))
    ,#+cljs (-lookup [this k nf] (swizzle3 this k nf))

    ,#+clj clojure.lang.IFn
    ,#+clj (invoke [this k] (swizzle3 this k nil))
    ,#+cljs IFn
    ,#+cljs (-invoke [this k] (swizzle3 this k nil))

    ,#+clj clojure.lang.Associative
    ,#+clj clojure.lang.IPersistentVector
    ,#+clj (count [_] 3)
    ,#+clj (length [_] 3)
    ,#+clj (containsKey [_ k] (not (nil? (#{0 1 2 :x :y :z} k))))
    ,#+clj (entryAt [_ k])
    ,#+clj (assoc [_ k v]
            (condp = k
              0 (Vec3. v y z _meta)
              1 (Vec3. x v z _meta)
              2 (Vec3. x y v _meta)
              :x (Vec3. v y z _meta)
              :y (Vec3. x v z _meta)
              :z (Vec3. x y v _meta)
              (key-error k)))
    ,#+clj (assocN [_ k v]
            (condp = k
              0 (Vec3. v y z _meta)
              1 (Vec3. x v z _meta)
              2 (Vec3. x y v _meta)
              (key-error k)))
    ,#+cljs ICounted
    ,#+cljs (-count [this] 2)
    ,#+cljs IAssociative
    ,#+cljs IVector
    ,#+cljs (-contains-key? [this k]
             (not (nil? (#{0 1 2 :x :y :z} k))))
    ,#+cljs (-assoc [this k v]
             (condp = k
               0 (Vec3. v y z _meta)
               1 (Vec3. x v z _meta)
               2 (Vec3. x y v _meta)
               :x (Vec3. v y z _meta)
               :y (Vec3. x v z _meta)
               :z (Vec3. x y v _meta)
               (key-error k)))
    ,#+cljs (-assoc-n [this k v]
             (condp = k
               0 (Vec3. v y z _meta)
               1 (Vec3. x v z _meta)
               2 (Vec3. x y v _meta)
               (key-error k)))

    ,#+clj clojure.lang.IPersistentCollection
    ,#+clj clojure.lang.Indexed
    ,#+clj clojure.lang.Sequential
    ,#+clj clojure.lang.ISeq
    ,#+clj clojure.lang.Seqable
    ,#+clj (first [_] x)
    ,#+clj (next [_] (cons y (cons z nil)))
    ,#+clj (more [_] (cons y (cons z nil)))
    ,#+clj (cons [_ _] (throw (UnsupportedOperationException.)))
    ,#+clj (peek [_] z)
    ,#+clj (pop [_] (Vec2. x y _meta))
    ,#+clj (rseq [_] (Vec3. z y x _meta))
    ,#+clj (seq [this] this)
    ,#+clj (nth [this n] (condp = n 0 x 1 y 2 z (key-error n)))
    ,#+clj (nth [_ n nf] (condp = n 0 x 1 y 2 z nf))
    ,#+clj (equiv [this o]
            (if (instance? Vec3 o)
              (and (clojure.lang.Util/equiv x (.-x ^Vec3 o))
                   (clojure.lang.Util/equiv y (.-y ^Vec3 o))
                   (clojure.lang.Util/equiv z (.-z ^Vec3 o)))
              (and (= 3 (count o))
                   (clojure.lang.Util/equiv o this))))
    ,#+clj (equals [this o]
            (if (instance? Vec3 o)
              (and (clojure.lang.Util/equals x (.-x ^Vec3 o))
                   (clojure.lang.Util/equals y (.-y ^Vec3 o))
                   (clojure.lang.Util/equals z (.-z ^Vec3 o)))
              (and (= 3 (count o))
                   (clojure.lang.Util/equals o this))))
    ,#+cljs ISequential
    ,#+cljs ISeq
    ,#+cljs (-first [this] x)
    ,#+cljs (-rest [this] (cons y (cons z nil)))
    ,#+cljs ISeqable
    ,#+cljs (-seq [this] this)
    ,#+cljs IReversible
    ,#+cljs (-rseq [this] (Vec3. z y x _meta))
    ,#+cljs IIndexed
    ,#+cljs (-nth [this n] (condp = n 0 x 1 y 2 z (key-error n)))
    ,#+cljs (-nth [this n nf] (condp = n 0 x 1 y 2 z nf))

    ,#+clj Comparable
    ,#+clj (compareTo [this o]
            (if (instance? Vec3 o)
              (let [c (compare x (.-x ^Vec3 o))]
                (if (== 0 c)
                  (let [c (compare y (.-y ^Vec3 o))]
                    (if (== 0 c)
                      (compare z (.-z ^Vec3 o))
                      c))
                  c))
              (let [c (count o)]
                (if (== 3 c) (compare o this) (- 3 c)))))
    ,#+clj (hashCode [_]
            (hash-combine
             (hash-combine
              (clojure.lang.Util/hash x)
              (clojure.lang.Util/hash y))
             (clojure.lang.Util/hash z)))
    ,#+cljs IComparable
    ,#+cljs (-compare [this o]
             (let [c (compare x (.-x ^Vec3 o))]
               (if (== 0 c)
                 (let [c (compare y (.-y ^Vec3 o))]
                   (if (== 0 c) (compare z (.-z ^Vec3 o)) c))
                 c)))
    ,#+cljs IHash
    ,#+cljs (-hash [_]
             (let [seed (* 37 x)]
               (bit-xor seed
                        (+ (+ (+ 0x9e3779b9 (* y 37))
                              (bit-shift-left seed 6))
                           (bit-shift-right seed 2)))))

    Object
    (toString [_] (str "[" x " " y " " z "]"))

    PVector
    (add [this a]
      (if (instance? Vec3 a)
        (Vec3. (+ x (.-x ^Vec3 a)) (+ y (.-y ^Vec3 a)) (+ z (.-z ^Vec3 a)) _meta)
        (Vec3. (+ x (nth a 0 0)) (+ y (nth a 1 0)) (+ z (nth a 2 0)) _meta)))
    (add [this a b]
      (if (number? a)
        (Vec3. (+ x a) (+ y b) z _meta)
        (let [[ax ay az] a [bx by bz] b]
          (Vec3. (+ (+ x ax) bx) (+ (+ y ay) by) (+ (+ z az) bz) _meta))))
    (add [this a b c]
      (if (number? a)
        (Vec3. (+ x a) (+ y b) (+ z c) _meta)
        (let [[ax ay az] a [bx by bz] b [cx cy cz] c]
          (Vec3. (+ (+ (+ x ax) bx) cx) (+ (+ (+ y ay) by) cy) (+ (+ (+ z az) bz) cz) _meta))))
    (add-n [this n] (Vec3. (+ x n) (+ y n) (+ z n) _meta))

    (sub [this a]
      (if (instance? Vec3 a)
        (Vec3. (- x (.-x ^Vec3 a)) (- y (.-y ^Vec3 a)) (- z (.-z ^Vec3 a)) _meta)
        (Vec3. (- x (nth a 0 0)) (- y (nth a 1 0)) (- z (nth a 2 0)) _meta)))
    (sub [this a b]
      (if (number? a)
        (Vec3. (- x a) (- y b) z _meta)
        (let [[ax ay az] a [bx by bz] b]
          (Vec3. (- (- x ax) bx) (- (- y ay) by) (- (- z az) bz) _meta))))
    (sub [this a b c]
      (if (number? a)
        (Vec3. (- x a) (- y b) (- z c) _meta)
        (let [[ax ay az] a [bx by bz] b [cx cy cz] c]
          (Vec3. (- (- (- x ax) bx) cx) (- (- (- y ay) by) cy) (- (- (- z az) bz) cz) _meta))))
    (sub-n [this n] (Vec3. (- x n) (- y n) (- z n) _meta))

    (scale [this a]
      (if (instance? Vec3 a)
        (Vec3. (* x (.-x ^Vec3 a)) (* y (.-y ^Vec3 a)) (* z (.-z ^Vec3 a)) _meta)
        (Vec3. (* x (nth a 0 1)) (* y (nth a 1 1)) (* z (nth a 2 1)) _meta)))
    (scale [this a b]
      (if (number? a)
        (Vec3. (* x a) (* y b) z _meta)
        (let [[ax ay az] a [bx by bz] b]
          (Vec3. (* (* x ax) bx) (* (* y ay) by) (* (* z az) bz) _meta))))
    (scale [this a b c]
      (if (number? a)
        (Vec3. (* x a) (* y b) (* z c) _meta)
        (let [[ax ay az] a [bx by bz] b [cx cy cz] c]
          (Vec3. (* (* (* x ax) bx) cx) (* (* (* y ay) by) cy) (* (* (* z az) bz) cz) _meta))))
    (scale-n [this n] (Vec3. (* x n) (* y n) (* z n) _meta))

    (madd [this a b] (add ((if (number? a) scale-n scale) this a) b))

    (dot [this [ax ay az]] (+ (* x ax) (* y ay) (* z az)))
    (cross [this [ax ay az]]
      (Vec3. (- (* y az) (* ay z)) (- (* z ax) (* az x)) (- (* x ay) (* ax y)) _meta))

    (mag [this] (Math/sqrt (+ (+ (* x x) (* y y)) (* z z))))
    (mag-squared [this] (+ (+ (* x x) (* y y)) (* z z)))

    (dist [this [ax ay az]]
      (let [dx (- x ax) dy (- y ay) dz (- z az)]
        (Math/sqrt (+ (+ (* dx dx) (* dy dy)) (* dz dz)))))
    (dist-squared [this [ax ay az]]
      (let [dx (- x ax) dy (- y ay) dz (- z az)]
        (+ (+ (* dx dx) (* dy dy)) (* dz dz))))

    (limit [this len]
      (if (> (mag-squared this) (* len len)) (normalize this len) this))

    (normalize [this]
      (let [l (mag this)]
        (if (pos? l) (Vec3. (/ x l) (/ y l) (/ z l) _meta) this)))
    (normalize [this len]
      (let [l (mag this)]
        (if (pos? l)
          (let [l (/ len l)] (Vec3. (* x l) (* y l) (* z l) _meta)) this)))

    (invert [this] (Vec3. (- x) (- y) (- z) _meta))
    (inverse [this] (Vec3. (/ 1.0 x) (/ 1.0 y) (/ 1.0 z) _meta))

    (reflect [this [rx ry rz :as r]]
      (let [d (* (dot this r) 2.0)]
        (Vec3. (- (* rx d) x) (- (* ry d) y) (- (* rz d) z) _meta)))

    (minv [this [ax ay az]]
      (Vec3. (min x ax) (min y ay) (min z az) _meta))
    (minv [this [ax ay az] [bx by bz]]
      (Vec3. (min (min x ax) bx) (min (min y ay) by) (min (min z az) bz) _meta))
    (maxv [this [ax ay az]]
      (Vec3. (max x ax) (max y ay) (max z az) _meta))
    (maxv [this [ax ay az] [bx by bz]]
      (Vec3. (max (max x ax) bx) (max (max y ay) by) (max (max z az) bz) _meta))

    PInterpolateable
    (mix [this [ax ay az]]
      (Vec3. (+ x (* (- ax x) 0.5)) (+ y (* (- ay y) 0.5)) (+ z (* (- az z) 0.5)) _meta))
    (mix [this [ax ay az] t]
      (Vec3. (+ x (* (- ax x) t)) (+ y (* (- ay y) t)) (+ z (* (- az z) t)) _meta))

    PPolar
    (polar [this]
      (let [xx (if (m/delta= 0.0 (m/abs x))
                 (if (< x 0.0) (- *eps*) *eps*)
                 x)
            m (Math/sqrt (+ (+ (* xx xx) (* y y)) (* z z)))
            yy (+ (Math/atan (/ z xx)) (if (< xx 0.0) PI 0.0))
            zz (Math/asin (/ y m))]
        (Vec3. m yy zz _meta)))
    (cartesian [this]
      (let [a (* x (Math/cos z))]
        (Vec3. (* a (Math/cos y)) (* x (Math/sin z)) (* a (Math/sin y)) _meta)))
    )
#+END_SRC
***** Protocol helpers
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  #+clj
  (defn map-entry [k ^double v]
    (reify
      clojure.lang.IMapEntry
      java.util.Map$Entry

      (key [_] k)
      (getKey [_] k)

      (val [_] v)
      (getValue [_] v)

      (hashCode [_]
        (bit-xor (clojure.lang.Util/hash k) (clojure.lang.Util/hash v)))
      (equals [_ x]
        (and (instance? java.util.Map$Entry x)
             (clojure.lang.Util/equals k (.getKey ^java.util.Map$Entry x))
             (clojure.lang.Util/equals v (.getValue ^java.util.Map$Entry x))))))
#+END_SRC
***** Swizzling
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  ,#+clj  (defn- key-error [k] (throw (IllegalArgumentException. (str "illegal lookup key: " k))))
  ,#+cljs (defn- key-error [k] (throw (js/Error. (str "illegal lookup key: " k))))

  (defn swizzle2
    [^Vec2 this k default]
    (if (number? k)
      (condp = k
        0 (.-x this)
        1 (.-y this)
        (or default (key-error k)))
      (condp = k
        :x (.-x this)
        :y (.-y this)
        (let [n (name k) c (count n)]
          (condp = c
            1 (or default (key-error k))
            2 (->> n
                   (map #(condp = % \x (.-x this) \y (.-y this) (or default (key-error k))))
                   ((fn [[x y]] (Vec2. x y (.-_meta this)))))
            3 (->> n
                   (map #(condp = % \x (.-x this) \y (.-y this) (or default (key-error k))))
                   ((fn [[x y z]] (Vec3. x y z (.-_meta this)))))
            (or default (key-error k)))))))

  (defn swizzle3
    [^Vec3 this k default]
    (if (number? k)
      (condp = k
        0 (.-x this)
        1 (.-y this)
        2 (.-z this)
        (or default (key-error k)))
      (condp = k
        :x (.-x this)
        :y (.-y this)
        :z (.-z this)
        (let [n (name k) c (count n)]
          (condp = c
            1 (or default (key-error k))
            2 (->> n
                   (map #(condp = % \x (.-x this) \y (.-y this) \z (.-z this) (or default (key-error k))))
                   ((fn [[x y]] (Vec2. x y (.-_meta this)))))
            3 (->> n
                   (map #(condp = % \x (.-x this) \y (.-y this) \z (.-z this) (or default (key-error k))))
                   ((fn [[x y z]] (Vec3. x y z (.-_meta this)))))
            (or default (key-error k)))))))
#+END_SRC
***** Constructors
      To simplify vector type construction, factory functions
      are provided which coerce arguments into vectors with these
      rules:

      | Input                 | Behavior                                           | Examples call        | Example result  |
      |-----------------------+----------------------------------------------------+----------------------+-----------------|
      | Clojure vector or seq | select first =n= elements or fill missing with 0.0 | =(vec2 [1 2 3 4])=   | =[1.0 2.0]=     |
      |                       |                                                    | =(vec3 '(1 2)=       | =[1.0 2.0 0.0]= |
      | Map                   | select values of =:x :y :z= or fill with 0.0       | =(vec2 {:x 1 :y 2})= | =[1.0 2.0]=     |
      |                       |                                                    | =(vec3 {:x 1 :y 2})= | =[1.0 2.0 0.0]= |
      | Single number         | set all vector components                          | =(vec3 1)=           | =[1.0 1.0 1.0]= |

#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  ,#+clj
  (defn type-error
    [t x] (throw (IllegalArgumentException. (str "can't create " t " from " x))))
  ,#+cljs
  (defn type-error
    [t x] (throw (js/Error. (str "can't create " t " from " x))))

  (defn vec2
    ([] (Vec2. 0.0 0.0 nil))
    ([x] (cond
          (instance? Vec2 x) x
          (sequential? x) (Vec2. (nth x 0 0.0) (nth x 1 0.0) (meta x))
          (number? x) (Vec2. x x nil)
          (map? x) (Vec2. (get x :x 0.0) (get x :y 0.0) (meta x))
          :default (type-error "vec2" x)))
    ([x y] (Vec2. x y nil)))

  (defn vec3
    ([] (Vec3. 0.0 0.0 0.0 nil))
    ([x] (cond
          (instance? Vec3 x) x
          (sequential? x) (Vec3. (nth x 0 0.0) (nth x 1 0.0) (nth x 2 0.0) (meta x))
          (number? x) (Vec3. x x x nil)
          (map? x) (Vec3. (get x :x 0.0) (get x :y 0.0) (get x :z 0.0) (meta x))
          :default (type-error "vec3" x)))
    ([x y] (Vec3. x y 0.0 nil))
    ([x y z] (Vec3. x y z nil)))

  (defn vec2? [x] (instance? Vec2 x))
  (defn vec3? [x] (instance? Vec3 x))
#+END_SRC
***** Random vectors
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defn randvec2
    ([] (normalize (vec2 (m/randnorm) (m/randnorm))))
    ([n] (normalize (vec2 (m/randnorm) (m/randnorm)) n)))

  (defn randvec3
    ([] (normalize (vec3 (m/randnorm) (m/randnorm) (m/randnorm))))
    ([n] (normalize (vec3 (m/randnorm) (m/randnorm) (m/randnorm)) n)))
#+END_SRC
***** Rotation
#+BEGIN_SRC clojure
  ;; :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defn rotate2
    [[x y] theta]
    (let [c (Math/cos theta) s (Math/sin theta)]
      [(- (* x c) (* y s)) (+ (* x s) (* y c))]))
#+END_SRC
***** Translation
#+BEGIN_SRC clojure
  ;; :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defn translate2
    ([t points] (let [t (vec2 t)] (map #(add2 % t) points)))
    ([t p & more] (translate2 t (cons p more))))

  (defn translate3
    ([t points] (let [t (vec3 t)] (map #(add3 % t) points)))
    ([t p & more] (translate3 t (cons p more))))

  (defn translate4
    ([t points] (let [t (vec4 t)] (map #(add4 % t) points)))
    ([t p & more] (translate4 t (cons p more))))
#+END_SRC
***** Shared functions
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defn closest-point*
    [lines q]
    (reduce (fn [a b]
              (if (< (dist-squared q a) (dist-squared q b)) a b))
            (map #(closest-point % q) lines)))

  (defn from-barycentric*
    [points weights]
    (reduce add (map scale-n points weights)))

  (defn centroid*
    [coll]
    (when (seq coll)
      (scale-n (reduce add coll) (/ 1.0 (count coll)))))

  (defn bounding-rect*
    ([coll]
       (let [c (count coll)]
         (cond
          (> c 1) (let [p (reduce minv coll)
                        q (reduce maxv coll)
                        [w h] (sub q p)]
                    (thi.ng.geom.types.Rect. p w h))
          (= c 1) (thi.ng.geom.types.Rect. (first coll) 0.0 0.0)
          :default nil)))
    ([p w h] (thi.ng.geom.types.Rect. p w h)))

  (defn bounding-box*
    ([coll]
       (let [cnt (count coll)]
         (cond
          (> cnt 1) (let [p (reduce minv coll)
                          q (reduce maxv coll)]
                      (thi.ng.geom.types.AABB. p q))
          (= cnt 1) (thi.ng.geom.types.AABB. (first coll) [0.0 0.0 0.0])
          :default nil)))
    ([p q] (thi.ng.geom.types.AABB. p (sub q p))))

  (defn max-dist*
    [c points]
    (->> points
         (map #(mag-squared (sub c %)))
         (reduce max)
         (Math/sqrt)))

  (defn bounding-circle*
    [c r-or-points]
    (thi.ng.geom.types.Circle.
     (vec2 c)
     (if (coll? r-or-points)
       (max-dist* c r-or-points)
       r-or-points)))

  (defn bounding-sphere*
    [c r-or-points]
    (thi.ng.geom.types.Sphere.
     (vec3 c)
     (if (coll? r-or-points)
       (max-dist* c r-or-points)
       r-or-points)))

  (defn axis-bounds*
    [axis coll]
    (let [xs (map #(nth % axis) coll)]
      [(reduce min xs) (reduce max xs)]))

  (defn axis-range*
    [axis coll]
    (let [xs (map #(nth % axis) coll)]
      (- (reduce max xs) (reduce min xs))))

  (defn normal3
    ([a b c] (normalize (cross (sub b a) (sub c a))))
    ([[a b c]] (normalize (cross (sub b a) (sub c a)))))
#+END_SRC
** Geometric entities
#+INCLUDE: "bezier.org" :minlevel 4

#+INCLUDE: "circle.org" :minlevel 4

#+INCLUDE: "line.org" :minlevel 4

#+INCLUDE: "rect.org" :minlevel 4

#+INCLUDE: "polygon.org" :minlevel 4

#+INCLUDE: "triangle.org" :minlevel 4

#+INCLUDE: "plane.org" :minlevel 4

#+INCLUDE: "aabb.org" :minlevel 4

#+INCLUDE: "sphere.org" :minlevel 4

#+INCLUDE: "mesh.org" :minlevel 4

** Geometric operations
#+INCLUDE: "delaunay.org" :minlevel 4
** Geometry IO
#+INCLUDE: "meshio.org" :minlevel 4
