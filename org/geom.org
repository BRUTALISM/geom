* Namespace: thi.ng.geom
  Providing an easy-to-use & easy-to-learn API for both common and
  advanced geometry operations is one of this project's main focal
  points. We attempt to realise this by defining all operations in
  the form of protocols which are then implemented by various core
  types.
** Outstanding tasks
*** TODO Re-insert advanced polygon fns and update ns decl
*** TODO extract LineStrip defrecords & protocols
*** TODO refactor bezier ns to use linestrips
*** TODO implement shape/shape intersections
*** TODO add NURBS
*** TODO add voxel ns
*** TODO add typehints to defrecords
*** TODO remove obsolete cljs defrecords (typehints are ignored for cljs)
** Core API
*** thi.ng.geom.types
**** 2D types
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (ns thi.ng.geom.types)
#+END_SRC
***** Line
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Line2 [p q])
  (defrecord LineStrip2 [points])
#+END_SRC
***** Triangle
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Triangle2 [a b c])
#+END_SRC
***** Ellipse
****** TODO rename circle ns into ellipse and add ellipse impl
     Even though a circle is a specialization of an Ellipse, we define
     an extra Circle type for performance reasons.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  #+clj  (defrecord Ellipse [p ^double rx ^double ry])
  #+clj  (defrecord Circle [p ^double r])

  #+cljs (defrecord Ellipse [p rx ry])
  #+cljs (defrecord Circle [p r])
#+END_SRC
***** Rectangle
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  #+clj  (defrecord Rect [p ^double w ^double h])
  #+cljs (defrecord Rect [p w h])
#+END_SRC
***** Polygon
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Polygon [points holes])
#+END_SRC
***** Path
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Path2 [segments])
#+END_SRC
***** Mesh
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Mesh2 [vertices normals fnormals vnormals edges faces attribs])
#+END_SRC
**** 3D types
***** Line
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Line3 [p q])
#+END_SRC
***** Plane
      A plane in cartesian 3D space can be defined as a point =p=
      lying on the plane and normal vector =n= standing perpendicular
      on the plane. The latter defines the plane's orientation in space.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Plane [p n])
#+END_SRC
***** Triangle
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Triangle3 [a b c])
#+END_SRC
***** AABB
      An Axis-aligned bounding box is defined as the cartesian volume
      extending for =size= units (a 3D vector) from point =p= toward
      positive infinity.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord AABB [p size])
#+END_SRC
***** Sphere
      Just like a circle in 2D, a 3D sphere is uniquely defined via
      its center point =o= and radius =r=.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  #+clj  (defrecord Sphere [o ^double r])
  #+cljs (defrecord Sphere [o r])
#+END_SRC
***** Mesh
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Mesh3 [vertices normals fnormals vnormals edges faces attribs])
#+END_SRC
*** thi.ng.geom.core
    This namespace contains all basic vector operations and core
    protocols related to common higher level geometric operations.
**** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (ns thi.ng.geom.core
    (:require
     [thi.ng.data.core :as d]
     [thi.ng.math.core :as m :refer [*eps* PI TWO_PI]]
     [thi.ng.geom.types :as types]
    #+clj [thi.ng.geom.macros :as mac])
    #+cljs (:require-macros [thi.ng.geom.macros :as mac])
    #+clj
    (:import
     [thi.ng.geom.types Circle Rect AABB Sphere]))
#+END_SRC
**** Protocols
***** Vector & matrix operations
****** PVector
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PVector
    (abs [this])
    (add [this a] [this a b] [this a b c])
    (sub [this a] [this a b] [this a b c])
    (madd [this a b])
    (dot [this a])
    (cross [this a])
    (mag [this])
    (mag-squared [this])
    (dist [this a])
    (dist-squared [this a])
    (normalize [this] [this len])
    (limit [this len])
    (inverse [this])
    (reflect [this r])
    (minv [this a] [this a b])
    (maxv [this a] [this a b]))
#+END_SRC
****** PHeading
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PHeading
    (heading-xy [this])
    (heading-xz [this])
    (heading-yz [this])
    (angle-between [this a])
    (normal [this] [this a])
    (slope-xy [this])
    (slope-xz [this])
    (slope-yz [this]))
#+END_SRC
****** PPolar
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PPolar
    (polar [this])
    (cartesian [this]))
#+END_SRC
****** PMatrix
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PMatrix
    (multiply [this m])
    (set-position [this p])
    (set-scale [this s])
    (set-rotation [this r])
    (transpose [this])
    (determinant [this]))
#+END_SRC
***** Spatial transform operations
      The position, size and orientation of spatial entities can
      usually be manipulated via the three basic operations: rotate,
      scale & translate. Other, more complex transformations can be
      achieved through combination and repetition of these.
****** PTransformable
       Rotation is always relative to the world origin. For 2D
       implementations, the rotation angle \theta (theta) is always
       interpreted clockwise and only the =rotate= method is
       implemented.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PTransformable
    (rotate-x [this t])
    (rotate-y [this t])
    (rotate-z [this t])
    (rotate [this t]) ;; alias for rotate-z
    (rotate-around-axis [this a t])
    (scale [this s] [this a b] [this a b c])
    (scale-size [this s])
    (translate [this t])
    (transform [this matrix]))
#+END_SRC
***** Shape based & structural operations
****** PGraph
      Most geometric shape constructs can be understood as an
      undirected graph of vertices, connected by edges. This protocol
      provides read access to entities in this context.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PGraph
    (edges [this] [this res])
    (vertices [this] [this res])
    (vertex-valence [this v])
    (vertex-neighbors [this v]))
#+END_SRC
****** PShape
      We use the term "shape" as the most general spatial entity
      above the layer of simple points in space. In this context they
      can be understood as having several shared properties, like
      surface area, a bounding shape etc.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PShape
    (area [this]
      "Returns surface area")
    (bounds [this]
      "Returns bounding rect for 2d entities or box for 3d")
    (center [this] [this o]
      "Returns updated entity centered around world origin or given point")
    (centroid [this]
      "Returns centroid of entity")
    (width [this]
      "Returns entity's extent along X axis")
    (height [this]
      "Returns entity's extent along Y axis")
    (depth [this]
      "Returns entity's extent along Z (zero for 2d)"))
#+END_SRC
****** PShape2
       This protocol provides access to more shape properties only
       available in 2d space.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PShape2
    (bounding-circle [this])
    (circumference [this]))
#+END_SRC
****** PShape3
       This protocol provides access to more shape properties only
       available in 3d space.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PShape3
    (bounding-sphere [this])
    (volume [this]))
#+END_SRC
****** PBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PBoundary
    (classify-point [this p])
    (closest-point [this p])
    (contains-point? [this p]))
#+END_SRC
****** PInterpolateable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PInterpolateable
    (mix [this x] [this x t]))
#+END_SRC
****** PSampleable
******* TODO move random-point-inside into PBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PSampleable
    (point-at [this t] [this u v])
    (random-point [this])
    (random-point-inside [this])
    (sample-uniform [this dist include-last?]))
#+END_SRC
****** PPolygonizable
       Anything which can be turned into a 2D polygon will implement this
       protocol consisting of just this one function: =as-polygon=.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PPolygonizable
    (as-polygon [this] [this res]
      "Transforms current entity into a Polygon instance"))
#+END_SRC
****** PMeshable
       Anything which can be turned into a 2D or 3D mesh will implement this
       protocol consisting of just this one function: =as-mesh=.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PMeshable
    (as-mesh [this] [this opts]
      "Transforms the current enitity into a Mesh instance"))
 #+END_SRC
****** PIntersectable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PIntersectable
    (intersect-line [this l])
    (intersect-ray [this r])
    (intersect-shape [this s]))
#+END_SRC
****** PSliceable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PSliceable
    (slice-with [this e] [this e classifier] [this e classifier parts]))
#+END_SRC
****** PSubdivideable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PSubdivideable
    (subdivide [this] [this opts])
    (subdivide-edge [this a b splits])
    (subdivide-face [this f p displace splits]))
#+END_SRC
****** PTessellateable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PTessellateable
    (tessellate [this] [this opts]))
#+END_SRC
****** PExtrudeable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PExtrudeable
    (extrude [this opts]))
#+END_SRC
****** PInvertible
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PInvertible
    (invert [this]))
#+END_SRC
***** Type specific operations
****** PLineStrip
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PLineStrip
    (arc-length [this]))
#+END_SRC
****** PMesh
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol PMesh
    (add-face [this f])
    (add-mesh [this m])
    (compute-face-normals [this])
    (compute-vertex-normals [this])
    (remove-face [this f])
    (remove-vertex [this v])
    (replace-vertex [this a b])
    (vertex-faces [this v])
    (merge-vertices [this a b]))
#+END_SRC
**** Declarations
     Some functions used by the following vector types will be
     defined further on, but need to be declared already.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (declare map-entry key-error swizzle2 swizzle3)
  (declare IDENTITY32 IDENTITY44)
#+END_SRC
**** Matrix implementations
***** Helper macros
****** Matrix item calculation
#+BEGIN_SRC clojure :noweb-ref mat-item
  (ns thi.ng.geom.macros)
  (defmacro mat-item
    ([a1 a2 b1 b2]
       `(+ (* ~a1 ~a2) (* ~b1 ~b2)))
    ([a1 a2 b1 b2 c1 c2]
       `(+ (+ (* ~a1 ~a2) (* ~b1 ~b2)) (* ~c1 ~c2)))
    ([a1 a2 b1 b2 c1 c2 d]
       `(+ (+ (+ (* ~a1 ~a2) (* ~b1 ~b2)) (* ~c1 ~c2)) ~d))
    ([a1 a2 b1 b2 c1 c2 d1 d2]
       `(+ (+ (+ (* ~a1 ~a2) (* ~b1 ~b2)) (* ~c1 ~c2)) (* ~d1 ~d2))))
#+END_SRC
******* Tangle twice for CLJ & CLJS                                :noexport:
        CLJX doesn't process macros correctly and therefore they need to
        be defined twice, for CLJ & CLJS individually...
#+BEGIN_SRC clojure :tangle babel/src-clj/thi/ng/geom/macros.clj :noweb yes
  <<mat-item>>
#+END_SRC
#+BEGIN_SRC clojure :tangle babel/src-cljs/thi/ng/geom/macros.clj :noweb yes
  <<mat-item>>
#+END_SRC
***** 3x2 Matrix (Affine 2D transform)
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (deftype Matrix32
      [^double m00 ^double m01 ^double m02
       ^double m10 ^double m11 ^double m12
       _meta]

    PMatrix
    (multiply [this m]
      (Matrix32.
       (mac/mat-item m00 (.-m00 m) m01 (.-m10 m))
       (mac/mat-item m00 (.-m01 m) m01 (.-m11 m))
       (+ m02 (mac/mat-item m00 (.-m02 m) m01 (.-m12 m)))
       (mac/mat-item m10 (.-m00 m) m11 (.-m10 m))
       (mac/mat-item m10 (.-m01 m) m11 (.-m11 m))
       (+ m12 (mac/mat-item m10 (.-m02 m) m11 (.-m12 m)))
       _meta))
    (set-scale [this s]
      (let [[sx sy] (if (number? s) [s s] s)]
        (Matrix32. sx 0.0 0.0 sy 0.0 0.0 _meta)))
    (set-position [this [x y]]
      (Matrix32. 1.0 0.0 0.0 1.0 x y _meta))
    (determinant [this]
      (- (* m00 m11) (* m01 m10)))

    PInvertible
    (invert [this]
      (let [d (determinant this)]
        (when-not (zero? d)
          (Matrix32.
           (/ m11 d) (- (/ m10 d)) (- (/ m01 d))
           (/ m00 d) (/ (- (* m01 m12) (* m11 m02)) d) (/ (- (* m10 m02) (* m00 m12)) d)
           _meta))))
    )
#+END_SRC
***** 4x4 Matrix
****** TODO add unproject from [[file:/Users/toxi/dev/js/gl-matrix.orig/gl-matrix.js::385]]
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (deftype Matrix44
      [^double m00 ^double m01 ^double m02 ^double m03
       ^double m10 ^double m11 ^double m12 ^double m13
       ^double m20 ^double m21 ^double m22 ^double m23
       ^double m30 ^double m31 ^double m32 ^double m33
       _meta]

    PMatrix
    (multiply [this m]
      (let [^Matrix44 m m]
        (Matrix44.
         (mac/mat-item m00 (.-m00 m) m01 (.-m10 m) m02 (.-m20 m) m03 (.-m30 m))
         (mac/mat-item m00 (.-m01 m) m01 (.-m11 m) m02 (.-m21 m) m03 (.-m31 m))
         (mac/mat-item m00 (.-m02 m) m01 (.-m12 m) m02 (.-m22 m) m03 (.-m32 m))
         (mac/mat-item m00 (.-m03 m) m01 (.-m13 m) m02 (.-m23 m) m03 (.-m33 m))

         (mac/mat-item m10 (.-m00 m) m11 (.-m10 m) m12 (.-m20 m) m13 (.-m30 m))
         (mac/mat-item m10 (.-m01 m) m11 (.-m11 m) m12 (.-m21 m) m13 (.-m31 m))
         (mac/mat-item m10 (.-m02 m) m11 (.-m12 m) m12 (.-m22 m) m13 (.-m32 m))
         (mac/mat-item m10 (.-m03 m) m11 (.-m13 m) m12 (.-m23 m) m13 (.-m33 m))

         (mac/mat-item m20 (.-m00 m) m21 (.-m10 m) m22 (.-m20 m) m23 (.-m30 m))
         (mac/mat-item m20 (.-m01 m) m21 (.-m11 m) m22 (.-m21 m) m23 (.-m31 m))
         (mac/mat-item m20 (.-m02 m) m21 (.-m12 m) m22 (.-m22 m) m23 (.-m32 m))
         (mac/mat-item m20 (.-m03 m) m21 (.-m13 m) m22 (.-m23 m) m23 (.-m33 m))

         (mac/mat-item m20 (.-m00 m) m21 (.-m10 m) m22 (.-m20 m) m23 (.-m30 m))
         (mac/mat-item m20 (.-m01 m) m21 (.-m11 m) m22 (.-m21 m) m23 (.-m31 m))
         (mac/mat-item m20 (.-m02 m) m21 (.-m12 m) m22 (.-m22 m) m23 (.-m32 m))
         (mac/mat-item m20 (.-m03 m) m21 (.-m13 m) m22 (.-m23 m) m23 (.-m33 m))
         _meta)))

    (set-position [this [x y z]]
      (Matrix44.
       m00 m01 m02 x
       m10 m11 m12 y
       m20 m21 m22 z
       m30 m31 m32 m33 _meta))

    (set-scale [this s]
      (let [[x y z] (if (number? s) [s s s] s)]
        (Matrix44.
         x m01 m02 m03
         m10 y m12 m12
         m20 m21 z m23
         m30 m31 m32 m33 _meta)))

    (set-rotation [this [rx ry rz]] ;; TODO
      (Matrix44.
       m00 m01 m02 m03
       m10 m11 m12 m12
       m20 m21 m22 m23
       m30 m31 m32 m33 _meta))

    (transpose [this]
      (Matrix44.
       m00 m10 m20 m30
       m01 m11 m21 m31
       m02 m12 m22 m32
       m03 m13 m23 m33 _meta))

    (determinant [this]
      (+ (+ (- (- (* m30 m21 m12 m03) (* m20 m31 m12 m03)) (* m30 m11 m22 m03)) (* m10 m31 m22 m03))
         (+ (- (- (* m20 m11 m32 m03) (* m10 m21 m32 m03)) (* m30 m21 m02 m13)) (* m20 m31 m02 m13))
         (+ (- (- (* m30 m01 m22 m13) (* m00 m31 m22 m13)) (* m20 m01 m32 m13)) (* m00 m21 m32 m13))
         (+ (- (- (* m30 m11 m02 m23) (* m10 m31 m02 m23)) (* m30 m01 m12 m23)) (* m00 m31 m12 m23))
         (+ (- (- (* m10 m01 m32 m23) (* m00 m11 m32 m23)) (* m20 m11 m02 m33)) (* m10 m21 m02 m33))
         (+ (- (- (* m20 m01 m12 m33) (* m00 m21 m12 m33)) (* m10 m01 m22 m33)) (* m00 m11 m22 m33))))

    PInvertible
    (invert [this]
      (let [n00 (- (* m00 m11) (* m01 m10))
            n01 (- (* m00 m12) (* m02 m10))
            n02 (- (* m00 m13) (* m03 m10))
            n03 (- (* m01 m12) (* m02 m11))
            n04 (- (* m01 m13) (* m03 m11))
            n05 (- (* m02 m13) (* m03 m12))
            n06 (- (* m20 m31) (* m21 m30))
            n07 (- (* m20 m32) (* m22 m30))
            n08 (- (* m20 m33) (* m32 m30))
            n09 (- (* m21 m32) (* m22 m31))
            n10 (- (* m21 m33) (* m23 m31))
            n11 (- (* m22 m33) (* m23 m32))
            d (+ (- (+ (+ (- (* n00 n11) (* n01 n10)) (* n02 n09)) (* n03 n08)) (* n04 n07)) (* n05 n06))]
        (prn d)
        (when-not (zero? d)
          (let [invd (/ 1.0 d)]
            (Matrix44.
             (* invd (+ (- (* m11 n11) (* m12 n10)) (* m13 n09))) ;0
             (* invd (+ (- (* m02 n10) (* m03 n09)) (* (- m01) n11))) ;1
             (* invd (+ (- (* m31 n05) (* m32 n04)) (* m33 n03))) ;2
             (* invd (+ (- (* m22 n04) (* m23 n03)) (* (- m21) n05))) ;3
             (* invd (+ (- (* m12 n08) (* m13 n07)) (* (- m10) n11))) ;4
             (* invd (+ (- (* m00 n11) (* m02 n08)) (* m03 n07))) ;5
             (* invd (+ (- (* m32 n02) (* m33 n01)) (* (- m30) n05))) ;6
             (* invd (+ (- (* m20 n05) (* m22 n02)) (* m23 n01))) ;7
             (* invd (+ (- (* m10 n10) (* m11 n08)) (* m13 n06))) ;8
             (* invd (+ (- (* m01 n08) (* m03 n06)) (* (- m00) n10))) ;9
             (* invd (+ (- (* m30 n04) (* m31 n02)) (* m33 n00))) ;10
             (* invd (+ (- (* m21 n02) (* m23 n00)) (* (- m20) n04))) ;11
             (* invd (+ (- (* m11 n07) (* m12 n06)) (* (- m10) n09))) ;12
             (* invd (+ (- (* m00 n09) (* m01 n07)) (* m02 n06))) ;13
             (* invd (+ (- (* m31 n01) (* m32 n00)) (* (- m30) n03))) ;14
             (* invd (+ (- (* m20 n03) (* m21 n01)) (* m22 n00))) ;15
             _meta)))))

    PTransformable
    (scale [this s]
      (multiply this (set-scale IDENTITY44 s)))
    (translate [this t]
      (multiply this (set-position IDENTITY44 t)))
    (rotate-x [this theta]
      (let [s (Math/sin theta) c (Math/cos theta)]
        (multiply
         this
         (Matrix44.
          1 0 0 0
          0 c (- s) 0
          0 s c 0
          0 0 0 1 nil))))
    (rotate-y [this theta]
      (let [s (Math/sin theta) c (Math/cos theta)]
        (multiply
         this
         (Matrix44.
          c 0 s 0
          0 1 0 0
          (- s) 0 c 0
          0 0 0 1 nil))))
    (rotate-z [this theta]
      (let [s (Math/sin theta) c (Math/cos theta)]
        (multiply
         this
         (Matrix44.
          c (- s) 0 0
          s c 0 0
          0 0 1 0
          0 0 0 1 nil))))
    (rotate-around-axis [this [x y z] theta]
      (let [s (Math/sin theta) c (Math/cos theta)
            sx (* s x) sy (* s y) sz (* s z)
            t (- 1.0 c) tx (* t x) ty (* t y)]
        (multiply
         this
         (Matrix44.
          (+ (* tx x) c) (+ (* tx y) sz) (- (* tx z) sy) 0.0
          (- (* tx y) sz) (+ (* ty y) c) (+ (* ty z) sx) 0.0
          (+ (* tx z) sy) (- (* ty z) sx) (+ (* t z z) c) 0.0
          0.0 0.0 0.0 1.0 nil))))
    )
#+END_SRC
**** Vector implementations
     For performance reasons, we decided to define custom datatypes
     for handling vectors & matrices. These types can be used much
     like standard Clojure vectors since they all implement the same
     protocols and interfaces, but also provide implementations for
     [[PVector]] and provide custom key lookups to provide swizzling features.

     Furthermore, since we aim for full ClojureScript compatibiliy,
     the following implementations are quite lengthy.
***** 2D
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (deftype Vec2 [^double x ^double y _meta]

    ,#+clj clojure.lang.IObj
    ,#+clj (meta [_] _meta)
    ,#+clj (withMeta [_ m*] (Vec2. x y m*))
    ,#+cljs IMeta
    ,#+cljs (-meta [_] _meta)
    ,#+cljs IWithMeta
    ,#+cljs (-with-meta [_ m*] (Vec2. x y m*))

    ,#+clj clojure.lang.ILookup
    ,#+clj (valAt [this k] (swizzle2 this k nil))
    ,#+clj (valAt [this k nf] (swizzle2 this k nf))
    ,#+cljs ILookup
    ,#+cljs (-lookup [this k] (swizzle2 this k nil))
    ,#+cljs (-lookup [this k nf] (swizzle2 this k nf))

    ,#+clj clojure.lang.IFn
    ,#+clj (invoke [this k] (swizzle2 this k nil))
    ,#+cljs IFn
    ,#+cljs (-invoke [this k] (swizzle2 this k nil))

    ,#+clj clojure.lang.Associative
    ,#+clj clojure.lang.IPersistentVector
    ,#+clj (count [_] 2)
    ,#+clj (length [_] 2)
    ,#+clj (containsKey [_ k] (not (nil? (#{0 1 :x :y} k))))
    ,#+clj (entryAt [this k] (map-entry k (swizzle2 this k nil)))
    ,#+clj (assoc [_ k v]
            (condp = k
              0 (Vec2. v y _meta) 1 (Vec2. x v _meta)
              :x (Vec2. v y _meta) :y (Vec2. x v _meta)
              (key-error k)))
    ,#+clj (assocN [_ k v]
            (condp = k 0 (Vec2. v y _meta) 1 (Vec2. x v _meta) (key-error k)))
    ,#+cljs ICounted
    ,#+cljs (-count [this] 2)
    ,#+cljs IAssociative
    ,#+cljs IVector
    ,#+cljs (-contains-key? [this k]
             (not (nil? (#{0 1 :x :y} k))))
    ,#+cljs (-assoc [this k v]
             (condp = k
               0 (Vec2. v y _meta) 1 (Vec2. x v _meta)
               :x (Vec2. v y _meta) :y (Vec2. x v _meta)
               (key-error k)))
    ,#+cljs (-assoc-n [this k v]
             (condp = k
               0 (Vec2. v y _meta) 1 (Vec2. x v _meta) (key-error k)))

    ,#+clj clojure.lang.IPersistentCollection
    ,#+clj clojure.lang.Indexed
    ,#+clj clojure.lang.Sequential
    ,#+clj clojure.lang.ISeq
    ,#+clj clojure.lang.Seqable
    ,#+clj (first [_] x)
    ,#+clj (next [_] (cons y nil))
    ,#+clj (more [_] (cons y nil))
    ,#+clj (cons [_ _] (throw (UnsupportedOperationException.)))
    ,#+clj (peek [_] y)
    ,#+clj (pop [_] x)
    ,#+clj (rseq [_] (Vec2. y x _meta))
    ,#+clj (seq [this] this)
    ,#+clj (nth [this k] (condp = k 0 x 1 y (key-error k)))
    ,#+clj (nth [_ k nf] (condp = k 0 x 1 y nf))
    ,#+clj (equiv [this o]
            (if (instance? Vec2 o)
              (and (clojure.lang.Util/equiv x (.-x ^Vec2 o))
                   (clojure.lang.Util/equiv y (.-y ^Vec2 o)))
              (and (= 2 (count o))
                   (clojure.lang.Util/equiv o this))))
    ,#+clj (equals [this o]
            (if (instance? Vec2 o)
              (and (clojure.lang.Util/equals x (.-x ^Vec2 o))
                   (clojure.lang.Util/equals y (.-y ^Vec2 o)))
              (and (= 2 (count o))
                   (clojure.lang.Util/equals o this))))
    ,#+cljs ISequential
    ,#+cljs ISeq
    ,#+cljs (-first [this] x)
    ,#+cljs (-rest [this] (cons y nil))
    ,#+cljs ISeqable
    ,#+cljs (-seq [this] (cons x (cons y nil)))
    ,#+cljs IReversible
    ,#+cljs (-rseq [this] (cons y (cons x nil)))
    ,#+cljs IIndexed
    ,#+cljs (-nth [this n] (case n 0 x 1 y))
    ,#+cljs (-nth [this n nf] (case n 0 x 1 y nf))

    ,#+clj Comparable
    ,#+clj (compareTo [this o]
            (if (instance? Vec2 o)
              (let [c (compare x (.-x ^Vec2 o))]
                (if (== 0 c) (compare y (.-y ^Vec2 o)) c))
              (let [c (count o)]
                (if (== 2 c) (compare o this) (- 2 c)))))
    ,#+clj (hashCode [_]
            (hash-combine (clojure.lang.Util/hash x) (clojure.lang.Util/hash y)))

    ,#+cljs IComparable
    ,#+cljs (-compare [this o]
             (let [c (compare x (.-x ^Vec2 o))]
               (if (== 0 c) (compare y (.-y ^Vec2 o)) c)))

    ,#+cljs IHash
    ,#+cljs (-hash [_] (hash-combine (hash x) (hash y)))

    Object
    (toString [_] (str "[" x " " y "]"))

    PTransformable
    (scale [this a]
      (if (instance? Vec2 a)
        (Vec2. (* x (.-x ^Vec2 a)) (* y (.-y ^Vec2 a)) _meta)
        (if (number? a)
          (Vec2. (* x a) (* y a) _meta)
          (Vec2. (* x (nth a 0 1)) (* y (nth a 1 1)) _meta))))
    (scale [this a b]
      (if (number? a)
        (Vec2. (* x a) (* y b) _meta)
        (let [[ax ay] a [bx by] b]
          (Vec2. (* (* x ax) bx) (* (* y ay) by) _meta))))
    (translate [this [tx ty]]
      (add this tx ty))
    (rotate [this theta]
      (let [s (Math/sin theta) c (Math/cos theta)]
        (Vec2. (- (* x c) (* y s)) (+ (* x s) (* y c)) _meta)))
    (rotate-z [this theta]
      (rotate this theta))
    (transform [this m])

    PVector
    (abs [this]
      (Vec2. (m/abs x) (m/abs y) _meta))
    (add [this a]
      (if (instance? Vec2 a)
        (Vec2. (+ x (.-x ^Vec2 a)) (+ y (.-y ^Vec2 a)) _meta)
        (if (number? a)
          (Vec2. (+ x a) (+ y a) _meta)
          (Vec2. (+ x (nth a 0 0)) (+ y (nth a 1 0)) _meta))))
    (add [this a b]
      (if (number? a)
        (Vec2. (+ x a) (+ y b) _meta)
        (let [[ax ay] a [bx by] b]
          (Vec2. (+ (+ x ax) bx) (+ (+ y ay) by) _meta))))

    (sub [this a]
      (if (instance? Vec2 a)
        (Vec2. (- x (.-x ^Vec2 a)) (- y (.-y ^Vec2 a)) _meta)
        (if (number? a)
          (Vec2. (- x a) (- y a) _meta)
          (Vec2. (- x (nth a 0 0)) (- y (nth a 1 0)) _meta))))
    (sub [this a b]
      (if (number? a)
        (Vec2. (- x a) (- y b) _meta)
        (let [[ax ay] a [bx by] b]
          (Vec2. (- (- x ax) bx) (- (- y ay) by) _meta))))

    (madd [this a b]
      (if (instance? Vec2 a)
        (if (instance? Vec2 b)
          (Vec2. (+ (* x (.-x ^Vec2 a)) (.-x ^Vec2 b))
                 (+ (* y (.-y ^Vec2 a)) (.-y ^Vec2 b)) _meta)
          (if (number? b)
            (Vec2. (+ (* x (.-x ^Vec2 a)) b)
                   (+ (* y (.-y ^Vec2 a)) b) _meta)
            (Vec2. (+ (* x (.-x ^Vec2 a)) (nth b 0 0.0))
                   (+ (* y (.-y ^Vec2 a)) (nth b 1 0.0)) _meta)))
        (if (number? a)
          (if (instance? Vec2 b)
            (Vec2. (+ (* x a) (.-x ^Vec2 b))
                   (+ (* y a) (.-y ^Vec2 b)) _meta)
            (if (number? b)
              (Vec2. (+ (* x a) b) (+ (* y a) b) _meta)
              (Vec2. (+ (* x a) (nth b 0 0.0)) (+ (* y a) (nth b 1 0.0)) _meta)))
          (if (instance? Vec2 b)
            (Vec2. (+ (* x (nth a 0 0.0)) (.-x ^Vec2 b))
                   (+ (* y (nth a 1 0.0)) (.-y ^Vec2 b)) _meta)
            (if (number? b)
              (Vec2. (+ (* x (nth a 0 0.0)) b)
                     (+ (* y (nth a 1 0.0)) b) _meta)
              (Vec2. (+ (* x (nth a 0 0.0)) (nth b 0 0.0))
                     (+ (* y (nth a 1 0.0)) (nth b 1 0.0)) _meta))))))

    (dot [this [ax ay]] (+ (* x ax) (* y ay)))
    (cross [this [ax ay]] (- (* x ay) (* y ax)))

    (mag [this] (Math/sqrt (+ (* x x) (* y y))))
    (mag-squared [this] (+ (* x x) (* y y)))

    (dist [this [ax ay]]
      (let [dx (- x ax) dy (- y ay)]
        (Math/sqrt (+ (* dx dx) (* dy dy)))))
    (dist-squared [this [ax ay]]
      (let [dx (- x ax) dy (- y ay)]
        (+ (* dx dx) (* dy dy))))

    (limit [this len]
      (if (> (mag-squared this) (* len len))
        (normalize this len) this))

    (normalize [this]
      (let [l (mag this)]
        (if (pos? l) (Vec2. (/ x l) (/ y l) _meta) this)))
    (normalize [this len]
      (let [l (mag this)]
        (if (pos? l)
          (let [l (/ len l)] (Vec2. (* x l) (* y l) _meta)) this)))

    (inverse [this] (Vec2. (/ 1.0 x) (/ 1.0 y) _meta))

    (reflect [this [rx ry :as r]]
      (let [d (* (dot this r) 2.0)]
        (Vec2. (- (* rx d) x) (- (* ry d) y) _meta)))

    (minv [this [ax ay]]
      (Vec2. (min x ax) (min y ay) _meta))
    (minv [this [ax ay] [bx by]]
      (Vec2. (min (min x ax) bx) (min (min y ay) by) _meta))
    (maxv [this [ax ay]]
      (Vec2. (max x ax) (max y ay) _meta))
    (maxv [this [ax ay] [bx by]]
      (Vec2. (max (max x ax) bx) (max (max y ay) by) _meta))

    PInvertible
    (invert [this] (Vec2. (- x) (- y) _meta))

    PInterpolateable
    (mix [this [ax ay]]
      (Vec2. (+ x (* (- ax x) 0.5)) (+ y (* (- ay y) 0.5)) _meta))
    (mix [this [ax ay] t]
      (Vec2. (+ x (* (- ax x) t)) (+ y (* (- ay y) t)) _meta))

    PHeading
    (heading-xy [this]
      (let [t (Math/atan2 y x)]
        (if (neg? t) (+ TWO_PI t) t)))
    (angle-between [this a]
      (let [t (- (heading-xy a) (heading-xy this))]
        (if (neg? t) (+ TWO_PI t) t)))
    (slope-xy [this] (/ y x))
    (normal [this] (Vec2. (- y) x _meta))

    PPolar
    (polar [this]
      (Vec2. (mag this) (heading-xy this) _meta))
    (cartesian [this]
      (Vec2. (* x (Math/cos y)) (* x (Math/sin y)) _meta)))
#+END_SRC
***** 3D
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (deftype Vec3 [^double x ^double y ^double z _meta]

    ,#+clj clojure.lang.IObj
    ,#+clj (meta [_] _meta)
    ,#+clj (withMeta [_ m*] (Vec3. x y z m*))
    ,#+cljs IMeta
    ,#+cljs (-meta [_] _meta)
    ,#+cljs IWithMeta
    ,#+cljs (-with-meta [_ m*] (Vec3. x y z m*))

    ,#+clj clojure.lang.ILookup
    ,#+clj (valAt [this k] (swizzle3 this k nil))
    ,#+clj (valAt [this k nf] (swizzle3 this k nf))
    ,#+cljs ILookup
    ,#+cljs (-lookup [this k] (swizzle3 this k nil))
    ,#+cljs (-lookup [this k nf] (swizzle3 this k nf))

    ,#+clj clojure.lang.IFn
    ,#+clj (invoke [this k] (swizzle3 this k nil))
    ,#+cljs IFn
    ,#+cljs (-invoke [this k] (swizzle3 this k nil))

    ,#+clj clojure.lang.Associative
    ,#+clj clojure.lang.IPersistentVector
    ,#+clj (count [_] 3)
    ,#+clj (length [_] 3)
    ,#+clj (containsKey [_ k] (not (nil? (#{0 1 2 :x :y :z} k))))
    ,#+clj (entryAt [_ k])
    ,#+clj (assoc [_ k v]
            (condp = k
              0 (Vec3. v y z _meta)
              1 (Vec3. x v z _meta)
              2 (Vec3. x y v _meta)
              :x (Vec3. v y z _meta)
              :y (Vec3. x v z _meta)
              :z (Vec3. x y v _meta)
              (key-error k)))
    ,#+clj (assocN [_ k v]
            (condp = k
              0 (Vec3. v y z _meta)
              1 (Vec3. x v z _meta)
              2 (Vec3. x y v _meta)
              (key-error k)))
    ,#+cljs ICounted
    ,#+cljs (-count [this] 2)
    ,#+cljs IAssociative
    ,#+cljs IVector
    ,#+cljs (-contains-key? [this k]
             (not (nil? (#{0 1 2 :x :y :z} k))))
    ,#+cljs (-assoc [this k v]
             (condp = k
               0 (Vec3. v y z _meta)
               1 (Vec3. x v z _meta)
               2 (Vec3. x y v _meta)
               :x (Vec3. v y z _meta)
               :y (Vec3. x v z _meta)
               :z (Vec3. x y v _meta)
               (key-error k)))
    ,#+cljs (-assoc-n [this k v]
             (condp = k
               0 (Vec3. v y z _meta)
               1 (Vec3. x v z _meta)
               2 (Vec3. x y v _meta)
               (key-error k)))

    ,#+clj clojure.lang.IPersistentCollection
    ,#+clj clojure.lang.Indexed
    ,#+clj clojure.lang.Sequential
    ,#+clj clojure.lang.ISeq
    ,#+clj clojure.lang.Seqable
    ,#+clj (first [_] x)
    ,#+clj (next [_] (cons y (cons z nil)))
    ,#+clj (more [_] (cons y (cons z nil)))
    ,#+clj (cons [_ _] (throw (UnsupportedOperationException.)))
    ,#+clj (peek [_] z)
    ,#+clj (pop [_] (Vec2. x y _meta))
    ,#+clj (rseq [_] (Vec3. z y x _meta))
    ,#+clj (seq [this] this)
    ,#+clj (nth [this n] (condp = n 0 x 1 y 2 z (key-error n)))
    ,#+clj (nth [_ n nf] (condp = n 0 x 1 y 2 z nf))
    ,#+clj (equiv [this o]
            (if (instance? Vec3 o)
              (and (clojure.lang.Util/equiv x (.-x ^Vec3 o))
                   (clojure.lang.Util/equiv y (.-y ^Vec3 o))
                   (clojure.lang.Util/equiv z (.-z ^Vec3 o)))
              (and (= 3 (count o))
                   (clojure.lang.Util/equiv o this))))
    ,#+clj (equals [this o]
            (if (instance? Vec3 o)
              (and (clojure.lang.Util/equals x (.-x ^Vec3 o))
                   (clojure.lang.Util/equals y (.-y ^Vec3 o))
                   (clojure.lang.Util/equals z (.-z ^Vec3 o)))
              (and (= 3 (count o))
                   (clojure.lang.Util/equals o this))))
    ,#+cljs ISequential
    ,#+cljs ISeq
    ,#+cljs (-first [this] x)
    ,#+cljs (-rest [this] (cons y (cons z nil)))
    ,#+cljs ISeqable
    ,#+cljs (-seq [this] this)
    ,#+cljs IReversible
    ,#+cljs (-rseq [this] (Vec3. z y x _meta))
    ,#+cljs IIndexed
    ,#+cljs (-nth [this n] (condp = n 0 x 1 y 2 z (key-error n)))
    ,#+cljs (-nth [this n nf] (condp = n 0 x 1 y 2 z nf))

    ,#+clj Comparable
    ,#+clj (compareTo [this o]
            (if (instance? Vec3 o)
              (let [c (compare x (.-x ^Vec3 o))]
                (if (== 0 c)
                  (let [c (compare y (.-y ^Vec3 o))]
                    (if (== 0 c)
                      (compare z (.-z ^Vec3 o))
                      c))
                  c))
              (let [c (count o)]
                (if (== 3 c) (compare o this) (- 3 c)))))
    ,#+clj (hashCode [_]
            (hash-combine
             (hash-combine
              (clojure.lang.Util/hash x)
              (clojure.lang.Util/hash y))
             (clojure.lang.Util/hash z)))
    ,#+cljs IComparable
    ,#+cljs (-compare [this o]
             (let [c (compare x (.-x ^Vec3 o))]
               (if (== 0 c)
                 (let [c (compare y (.-y ^Vec3 o))]
                   (if (== 0 c) (compare z (.-z ^Vec3 o)) c))
                 c)))
    ,#+cljs IHash
    ,#+cljs (-hash [_]
             (let [seed (* 37 x)]
               (bit-xor seed
                        (+ (+ (+ 0x9e3779b9 (* y 37))
                              (bit-shift-left seed 6))
                           (bit-shift-right seed 2)))))

    Object
    (toString [_] (str "[" x " " y " " z "]"))

    PTransformable
    (scale [this a]
      (if (instance? Vec3 a)
        (Vec3. (* x (.-x ^Vec3 a)) (* y (.-y ^Vec3 a)) (* z (.-z ^Vec3 a)) _meta)
        (if (number? a)
          (Vec3. (* x a) (* y a) (* z a) _meta)
          (Vec3. (* x (nth a 0 1)) (* y (nth a 1 1)) (* z (nth a 2 1)) _meta))))
    (scale [this a b]
      (if (number? a)
        (Vec3. (* x a) (* y b) z _meta)
        (let [[ax ay az] a [bx by bz] b]
          (Vec3. (* (* x ax) bx) (* (* y ay) by) (* (* z az) bz) _meta))))
    (scale [this a b c]
      (if (number? a)
        (Vec3. (* x a) (* y b) (* z c) _meta)
        (let [[ax ay az] a [bx by bz] b [cx cy cz] c]
          (Vec3. (* (* (* x ax) bx) cx) (* (* (* y ay) by) cy) (* (* (* z az) bz) cz) _meta))))
    (translate [this t]
      (add this t))
    (rotate-x [this theta]
      (let [s (Math/sin theta) c (Math/cos theta)]
        (Vec3. x (+ (* z s) (* y c)) (- (* z c) (* y s)) _meta)))
    (rotate-y [this theta]
      (let [s (Math/sin theta) c (Math/cos theta)]
        (Vec3. (- (* x c) (* z s)) y (+ (* x s) (* z c)) _meta)))
    (rotate-z [this theta]
      (let [s (Math/sin theta) c (Math/cos theta)]
        (Vec3. (- (* x c) (* y s)) (+ (* x s) (* y c)) z _meta)))
    (rotate [this theta]
      (rotate-z this theta))
    (transform [this m]
      (let [^Matrix44 m m]
        (Vec3. (mac/mat-item x (.-m00 m) y (.-m01 m) z (.-m02 m) (.-m03 m))
               (mac/mat-item x (.-m10 m) y (.-m11 m) z (.-m12 m) (.-m13 m))
               (mac/mat-item x (.-m20 m) y (.-m21 m) z (.-m22 m) (.-m23 m))
               _meta)))

    PVector
    (add [this a]
      (if (instance? Vec3 a)
        (Vec3. (+ x (.-x ^Vec3 a)) (+ y (.-y ^Vec3 a)) (+ z (.-z ^Vec3 a)) _meta)
        (if (number? a)
          (Vec3. (+ x a) (+ y a) (+ z a) _meta)
          (Vec3. (+ x (nth a 0 0)) (+ y (nth a 1 0)) (+ z (nth a 2 0)) _meta))))
    (add [this a b]
      (if (number? a)
        (Vec3. (+ x a) (+ y b) z _meta)
        (let [[ax ay az] a [bx by bz] b]
          (Vec3. (+ (+ x ax) bx) (+ (+ y ay) by) (+ (+ z az) bz) _meta))))
    (add [this a b c]
      (if (number? a)
        (Vec3. (+ x a) (+ y b) (+ z c) _meta)
        (let [[ax ay az] a [bx by bz] b [cx cy cz] c]
          (Vec3. (+ (+ (+ x ax) bx) cx) (+ (+ (+ y ay) by) cy) (+ (+ (+ z az) bz) cz) _meta))))

    (sub [this a]
      (if (instance? Vec3 a)
        (Vec3. (- x (.-x ^Vec3 a)) (- y (.-y ^Vec3 a)) (- z (.-z ^Vec3 a)) _meta)
        (if (number? a)
          (Vec3. (- x a) (- y a) (- z a) _meta)
          (Vec3. (- x (nth a 0 0)) (- y (nth a 1 0)) (- z (nth a 2 0)) _meta))))
    (sub [this a b]
      (if (number? a)
        (Vec3. (- x a) (- y b) z _meta)
        (let [[ax ay az] a [bx by bz] b]
          (Vec3. (- (- x ax) bx) (- (- y ay) by) (- (- z az) bz) _meta))))
    (sub [this a b c]
      (if (number? a)
        (Vec3. (- x a) (- y b) (- z c) _meta)
        (let [[ax ay az] a [bx by bz] b [cx cy cz] c]
          (Vec3. (- (- (- x ax) bx) cx) (- (- (- y ay) by) cy) (- (- (- z az) bz) cz) _meta))))

    (madd [this a b]
      (if (instance? Vec3 a)
        (if (instance? Vec3 b)
          (Vec3. (+ (* x (.-x ^Vec3 a)) (.-x ^Vec3 b))
                 (+ (* y (.-y ^Vec3 a)) (.-y ^Vec3 b))
                 (+ (* z (.-z ^Vec3 a)) (.-z ^Vec3 b)) _meta)
          (if (number? b)
            (Vec3. (+ (* x (.-x ^Vec3 a)) b)
                   (+ (* y (.-y ^Vec3 a)) b)
                   (+ (* z (.-z ^Vec3 a)) b) _meta)
            (Vec3. (+ (* x (.-x ^Vec3 a)) (nth b 0 0.0))
                   (+ (* y (.-y ^Vec3 a)) (nth b 1 0.0))
                   (+ (* z (.-z ^Vec3 a)) (nth b 2 0.0)) _meta)))
        (if (number? a)
          (if (instance? Vec3 b)
            (Vec3. (+ (* x a) (.-x ^Vec3 b))
                   (+ (* y a) (.-y ^Vec3 b))
                   (+ (* z a) (.-z ^Vec3 b)) _meta)
            (if (number? b)
              (Vec3. (+ (* x a) b) (+ (* y a) b) (+ (* z a) b) _meta)
              (Vec3. (+ (* x a) (nth b 0 0.0)) (+ (* y a) (nth b 1 0.0)) (+ (* z a) (nth b 2 0.0)) _meta)))
          (if (instance? Vec3 b)
            (Vec3. (+ (* x (nth a 0 0.0)) (.-x ^Vec3 b))
                   (+ (* y (nth a 1 0.0)) (.-y ^Vec3 b))
                   (+ (* z (nth a 2 0.0)) (.-z ^Vec3 b)) _meta)
            (if (number? b)
              (Vec3. (+ (* x (nth a 0 0.0)) b)
                     (+ (* y (nth a 1 0.0)) b)
                     (+ (* z (nth a 2 0.0)) b) _meta)
              (Vec3. (+ (* x (nth a 0 0.0)) (nth b 0 0.0))
                     (+ (* y (nth a 1 0.0)) (nth b 1 0.0))
                     (+ (* z (nth a 2 0.0)) (nth b 2 0.0)) _meta))))))

    (dot [this [ax ay az]] (+ (* x ax) (* y ay) (* z az)))
    (cross [this [ax ay az]]
      (Vec3. (- (* y az) (* ay z)) (- (* z ax) (* az x)) (- (* x ay) (* ax y)) _meta))

    (mag [this] (Math/sqrt (+ (+ (* x x) (* y y)) (* z z))))
    (mag-squared [this] (+ (+ (* x x) (* y y)) (* z z)))

    (dist [this [ax ay az]]
      (let [dx (- x ax) dy (- y ay) dz (- z az)]
        (Math/sqrt (+ (+ (* dx dx) (* dy dy)) (* dz dz)))))
    (dist-squared [this [ax ay az]]
      (let [dx (- x ax) dy (- y ay) dz (- z az)]
        (+ (+ (* dx dx) (* dy dy)) (* dz dz))))

    (limit [this len]
      (if (> (mag-squared this) (* len len)) (normalize this len) this))

    (normalize [this]
      (let [l (mag this)]
        (if (pos? l) (Vec3. (/ x l) (/ y l) (/ z l) _meta) this)))
    (normalize [this len]
      (let [l (mag this)]
        (if (pos? l)
          (let [l (/ len l)] (Vec3. (* x l) (* y l) (* z l) _meta)) this)))

    (inverse [this] (Vec3. (/ 1.0 x) (/ 1.0 y) (/ 1.0 z) _meta))

    (reflect [this [rx ry rz :as r]]
      (let [d (* (dot this r) 2.0)]
        (Vec3. (- (* rx d) x) (- (* ry d) y) (- (* rz d) z) _meta)))

    (minv [this [ax ay az]]
      (Vec3. (min x ax) (min y ay) (min z az) _meta))
    (minv [this [ax ay az] [bx by bz]]
      (Vec3. (min (min x ax) bx) (min (min y ay) by) (min (min z az) bz) _meta))
    (maxv [this [ax ay az]]
      (Vec3. (max x ax) (max y ay) (max z az) _meta))
    (maxv [this [ax ay az] [bx by bz]]
      (Vec3. (max (max x ax) bx) (max (max y ay) by) (max (max z az) bz) _meta))

    PInvertible
    (invert [this] (Vec3. (- x) (- y) (- z) _meta))

    PInterpolateable
    (mix [this [ax ay az]]
      (Vec3. (+ x (* (- ax x) 0.5)) (+ y (* (- ay y) 0.5)) (+ z (* (- az z) 0.5)) _meta))
    (mix [this [ax ay az] t]
      (Vec3. (+ x (* (- ax x) t)) (+ y (* (- ay y) t)) (+ z (* (- az z) t)) _meta))

    PPolar
    (polar [this]
      (let [xx (if (m/delta= 0.0 (m/abs x))
                 (if (< x 0.0) (- *eps*) *eps*)
                 x)
            m (Math/sqrt (+ (+ (* xx xx) (* y y)) (* z z)))
            yy (+ (Math/atan (/ z xx)) (if (< xx 0.0) PI 0.0))
            zz (Math/asin (/ y m))]
        (Vec3. m yy zz _meta)))
    (cartesian [this]
      (let [a (* x (Math/cos z))]
        (Vec3. (* a (Math/cos y)) (* x (Math/sin z)) (* a (Math/sin y)) _meta)))
    )
#+END_SRC
***** Constants
****** Default circle resolution
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (def ^:dynamic *resolution* 20)
#+END_SRC
******* TODO Binding macro
#+BEGIN_SRC clojure
  ;; :tangle babel/src-cljs/thi/ng/geom/macros.clj
  (defmacro with-resolution
    [res & body]
    (binding [*resolution* res] ~@body))
#+END_SRC
****** Vectors
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (def ^:const VEC2 (Vec2. 0.0 0.0 nil))
  (def ^:const VEC3 (Vec3. 0.0 0.0 0.0 nil))

  (def ^:const V2_X (Vec2. 1.0 0.0 nil))
  (def ^:const V2_Y (Vec2. 0.0 1.0 nil))

  (def ^:const V3_X (Vec3. 1.0 0.0 0.0 nil))
  (def ^:const V3_Y (Vec3. 0.0 1.0 0.0 nil))
  (def ^:const V3_Z (Vec3. 0.0 0.0 1.0 nil))
#+END_SRC
****** Identity matrices
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (def ^:const IDENTITY32
    (Matrix32.
     1.0 0.0 0.0
     0.0 1.0 0.0 nil))

  (def ^:const IDENTITY44
    (Matrix44.
     1.0 0.0 0.0 0.0
     0.0 1.0 0.0 0.0
     0.0 0.0 1.0 0.0
     0.0 0.0 0.0 1.0 nil))
#+END_SRC
***** Protocol helpers
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  #+clj
  (defn map-entry [k ^double v]
    (reify
      clojure.lang.IMapEntry
      java.util.Map$Entry

      (key [_] k)
      (getKey [_] k)

      (val [_] v)
      (getValue [_] v)

      (hashCode [_]
        (bit-xor (clojure.lang.Util/hash k) (clojure.lang.Util/hash v)))
      (equals [_ x]
        (and (instance? java.util.Map$Entry x)
             (clojure.lang.Util/equals k (.getKey ^java.util.Map$Entry x))
             (clojure.lang.Util/equals v (.getValue ^java.util.Map$Entry x))))))
#+END_SRC
***** Swizzling
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  ,#+clj  (defn- key-error [k] (throw (IllegalArgumentException. (str "illegal lookup key: " k))))
  ,#+cljs (defn- key-error [k] (throw (js/Error. (str "illegal lookup key: " k))))

  (defn swizzle2
    [^Vec2 this k default]
    (if (number? k)
      (condp = k
        0 (.-x this)
        1 (.-y this)
        (or default (key-error k)))
      (condp = k
        :x (.-x this)
        :y (.-y this)
        (let [n (name k) c (count n)]
          (condp = c
            1 (or default (key-error k))
            2 (->> n
                   (map #(condp = % \x (.-x this) \y (.-y this) (or default (key-error k))))
                   ((fn [[x y]] (Vec2. x y (.-_meta this)))))
            3 (->> n
                   (map #(condp = % \x (.-x this) \y (.-y this) (or default (key-error k))))
                   ((fn [[x y z]] (Vec3. x y z (.-_meta this)))))
            (or default (key-error k)))))))

  (defn swizzle3
    [^Vec3 this k default]
    (if (number? k)
      (condp = k
        0 (.-x this)
        1 (.-y this)
        2 (.-z this)
        (or default (key-error k)))
      (condp = k
        :x (.-x this)
        :y (.-y this)
        :z (.-z this)
        (let [n (name k) c (count n)]
          (condp = c
            1 (or default (key-error k))
            2 (->> n
                   (map #(condp = % \x (.-x this) \y (.-y this) \z (.-z this) (or default (key-error k))))
                   ((fn [[x y]] (Vec2. x y (.-_meta this)))))
            3 (->> n
                   (map #(condp = % \x (.-x this) \y (.-y this) \z (.-z this) (or default (key-error k))))
                   ((fn [[x y z]] (Vec3. x y z (.-_meta this)))))
            (or default (key-error k)))))))
#+END_SRC
***** Constructors
      To simplify vector type construction, factory functions
      are provided which coerce arguments into vectors with these
      rules:

      | Input                 | Behavior                                           | Examples call        | Example result  |
      |-----------------------+----------------------------------------------------+----------------------+-----------------|
      | Clojure vector or seq | select first =n= elements or fill missing with 0.0 | =(vec2 [1 2 3 4])=   | =[1.0 2.0]=     |
      |                       |                                                    | =(vec3 '(1 2)=       | =[1.0 2.0 0.0]= |
      | Map                   | select values of =:x :y :z= or fill with 0.0       | =(vec2 {:x 1 :y 2})= | =[1.0 2.0]=     |
      |                       |                                                    | =(vec3 {:x 1 :y 2})= | =[1.0 2.0 0.0]= |
      | Single number         | set all vector components                          | =(vec3 1)=           | =[1.0 1.0 1.0]= |

#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  ,#+clj
  (defn type-error
    [t x] (throw (IllegalArgumentException. (str "can't create " t " from " x))))
  ,#+cljs
  (defn type-error
    [t x] (throw (js/Error. (str "can't create " t " from " x))))

  (defn vec2
    ([] (Vec2. 0.0 0.0 nil))
    ([x] (cond
          (instance? Vec2 x) x
          (sequential? x) (Vec2. (nth x 0 0.0) (nth x 1 0.0) (meta x))
          (number? x) (Vec2. x x nil)
          (map? x) (Vec2. (get x :x 0.0) (get x :y 0.0) (meta x))
          :default (type-error "vec2" x)))
    ([x y] (Vec2. x y nil)))

  (defn vec3
    ([] (Vec3. 0.0 0.0 0.0 nil))
    ([x] (cond
          (instance? Vec3 x) x
          (sequential? x) (Vec3. (nth x 0 0.0) (nth x 1 0.0) (nth x 2 0.0) (meta x))
          (number? x) (Vec3. x x x nil)
          (map? x) (Vec3. (get x :x 0.0) (get x :y 0.0) (get x :z 0.0) (meta x))
          :default (type-error "vec3" x)))
    ([x y] (Vec3. x y 0.0 nil))
    ([x y z] (Vec3. x y z nil)))

  (defn vec2? [x] (instance? Vec2 x))
  (defn vec3? [x] (instance? Vec3 x))
#+END_SRC
***** Random vectors
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defn randvec2
    ([] (normalize (vec2 (m/randnorm) (m/randnorm))))
    ([n] (normalize (vec2 (m/randnorm) (m/randnorm)) n)))

  (defn randvec3
    ([] (normalize (vec3 (m/randnorm) (m/randnorm) (m/randnorm))))
    ([n] (normalize (vec3 (m/randnorm) (m/randnorm) (m/randnorm)) n)))
#+END_SRC
**** Shared functions
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defn closest-point*
    [lines q]
    (reduce (fn [a b]
              (if (< (dist-squared q a) (dist-squared q b)) a b))
            (map #(closest-point % q) lines)))

  (defn from-barycentric*
    [points weights]
    (reduce add (map scale points weights)))

  (defn centroid*
    [coll]
    (when (seq coll)
      (scale (reduce add coll) (/ 1.0 (count coll)))))

  (defn bounding-rect*
    ([coll]
       (let [c (count coll)]
         (cond
          (> c 1) (let [p (reduce minv coll)
                        q (reduce maxv coll)
                        [w h] (sub q p)]
                    (thi.ng.geom.types.Rect. p w h))
          (= c 1) (thi.ng.geom.types.Rect. (first coll) 0.0 0.0)
          :default nil)))
    ([p w h] (thi.ng.geom.types.Rect. p w h)))

  (defn bounding-box*
    ([coll]
       (let [cnt (count coll)]
         (cond
          (> cnt 1) (let [p (reduce minv coll)
                          q (reduce maxv coll)]
                      (thi.ng.geom.types.AABB. p q))
          (= cnt 1) (thi.ng.geom.types.AABB. (first coll) [0.0 0.0 0.0])
          :default nil)))
    ([p q] (thi.ng.geom.types.AABB. p (sub q p))))

  (defn max-dist*
    [c points]
    (->> points
         (map #(mag-squared (sub c %)))
         (reduce max)
         (Math/sqrt)))

  (defn bounding-circle*
    [c r-or-points]
    (thi.ng.geom.types.Circle.
     (vec2 c)
     (if (coll? r-or-points)
       (max-dist* c r-or-points)
       r-or-points)))

  (defn bounding-sphere*
    [c r-or-points]
    (thi.ng.geom.types.Sphere.
     (vec3 c)
     (if (coll? r-or-points)
       (max-dist* c r-or-points)
       r-or-points)))

  (defn axis-bounds*
    [axis coll]
    (let [xs (map #(nth % axis) coll)]
      [(reduce min xs) (reduce max xs)]))

  (defn axis-range*
    [axis coll]
    (let [xs (map #(nth % axis) coll)]
      (- (reduce max xs) (reduce min xs))))

  (defn total-length*
    [points]
    (->> points
         (d/successive-nth 2)
         (map #(dist (% 0) (% 1)))
         (reductions + 0)
         (vec)))

  (defn sample-uniform*
    [udist include-last? points]
    (let [idx (total-length* points)
          total (peek idx)
          delta (/ udist total)
          samples (loop [t 0.0 i 1 acc []]
                    (if (< t 1.0)
                      (let [ct (* t total)
                            i (loop [i i] (if (>= ct (idx i)) (recur (inc i)) i))
                            p (nth points (dec i))
                            q (nth points i)
                            pi (idx (dec i))
                            frac (/ (- ct pi) (- (idx i) pi))]
                        (recur (+ t delta) i (conj acc (mix p q frac))))
                      acc))]
      (if include-last?
        (conj samples (last points))
        samples)))

  (defn point-at*
    ([t points] (point-at* t points nil))
    ([t points idx]
       (when (m/in-range? 0.0 1.0 t)
         (let [n (count points)
               t (double t)]
           (cond
            (= 0 n) nil
            (= 1 n) (first points)
            (= 1.0 t) (last points)
            :default (let [idx (or idx (total-length* points))
                           total (peek idx)
                           ct (* t total)
                           i (loop [i 1] (if (>= ct (idx i)) (recur (inc i)) i))
                           p (nth points (dec i))
                           q (nth points i)
                           pi (idx (dec i))
                           frac (/ (- ct pi) (- (idx i) pi))]
                       (mix p q frac)))))))

  (defn edges*
    [ctor points]
    (->> points (d/successive-nth 2) (map ctor) (vec)))

  (defn tessellate*
    [c points]
    (->> [(first points)]
         (concat points)
         (d/successive-nth 2)
         (map #(vector (% 0) c (% 1)))))

  (defn normal3*
    ([a b c] (normalize (cross (sub c a) (sub b a))))
    ([[a b c]] (normalize (cross (sub c a) (sub b a)))))
#+END_SRC
**** Matrix functions
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defn frustum
    "Sets up a viewing frustum, shaped like a truncated pyramid with the
    camera where the tip of the pyramid would be.
    This emulates the OpenGL function glFrustum()."
    [l t r b n f]
    (let [dx (- r l)
          dy (- t b)
          dz (- f n)]
      (Matrix44.
       (/ (* 2.0 n) dx) 0.0 (/ (+ r l) dx) 0.0
       0.0 (/ (* 2.0 n) dy) (/ (+ t b) dy) 0.0
       0.0 0.0 (* -1 (/ (+ f n) dz)) (/ (* (* -2.0 f) n) dz)
       0.0 0.0 -1.0 0.0
       nil)))

  (defn frustum-bounds
    [fov aspect near]
    (let [rad (* 0.5 (m/radians fov))
          top (* near (Math/tan rad))
          right (* top aspect)]
      {:left (- right)
       :right right
       :top top
       :bottom (- top)}))

  (defn ortho
    "Returns an orthographic projection matrix, in which objects are the same size no
    matter how far away or nearby they are.
    This emulates the OpenGL function glOrtho()."
    [l t r b n f]
    (let[dx (- r l)
         dy (- t b)
         dz (- f n)]
      (Matrix44.
       (/ 2.0 dx) 0.0 0.0 (- (/ (+ r l) dx))
       0.0 (/ 2.0 dy) 0.0 (- (/ (+ t b) dy))
       0.0 0.0 (/ -2.0 dz) (- (/ (+ f n) dz))
       0.0 0.0 0.0 1.0
       nil)))

  (defn perspective
    "Returns a perspective transform matrix, which makes far away objects appear
    smaller than nearby objects. The `aspect` argument should be the width
    divided by the height of your viewport and `fov` is the vertical angle
    of the field of view in degrees.
    This emulates the OpenGL function gluPerspective()."
    [fov aspect near far]
    (let [rad (* 0.5 (m/radians fov))
          cot (/ (Math/cos rad) (Math/sin rad))
          deltaz (- far near)
          a (/ cot aspect)
          b (- (/ (+ far near) deltaz))
          c (/ (* -2.0 near far) deltaz)]
      (Matrix44.
       a 0.0 0.0 0.0
       0.0 cot 0.0 0.0
       0.0 0.0 b c
       0.0 0.0 -1.0 0.0
       nil)))

  (defn perspective-frustum
    [fov aspect near far]
    (let [{:keys [left right top bottom]} (frustum-bounds fov aspect near)]
      (frustum left top right bottom near far)))

  (defn look-at
    "Returns a matrix that puts the camera at the eye position looking
    toward the target point with the given up direction.
    This emulates the OpenGL function `gluLookAt()`."
    [eye target upvec]
    (let [[fx fy fz :as f] (normalize (sub eye target))
          [sx sy sz :as s] (normalize (cross upvec f))
          [tx ty tz :as t] (normalize (cross f s))]
      (Matrix44.
       sx sy sz (- (dot s eye))
       tx ty tz (- (dot t eye))
       fx fy fz (- (dot f eye))
       0.0 0.0 0.0 1.0
       nil)))
#+END_SRC
** Geometric entities
#+INCLUDE: "bezier.org" :minlevel 4

#+INCLUDE: "circle.org" :minlevel 4

#+INCLUDE: "line.org" :minlevel 4

#+INCLUDE: "path.org" :minlevel 4

#+INCLUDE: "rect.org" :minlevel 4

#+INCLUDE: "polygon.org" :minlevel 4

#+INCLUDE: "triangle.org" :minlevel 4

#+INCLUDE: "plane.org" :minlevel 4

#+INCLUDE: "aabb.org" :minlevel 4

#+INCLUDE: "sphere.org" :minlevel 4

#+INCLUDE: "mesh.org" :minlevel 4

** Geometric operations
#+INCLUDE: "delaunay.org" :minlevel 4
** Geometry IO
#+INCLUDE: "meshio.org" :minlevel 4
