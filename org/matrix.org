* Namespace: thi.ng.math.matrix
** Helper macros
*** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/math/macros.cljx
  (ns thi.ng.math.macros)
#+END_SRC
*** Matrix item calculation
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/math/macros.cljx
(defmacro mat-item
  ([a1 a2 b1 b2 c1 c2]
    `(+ (+ (* ~a1 ~a2) (* ~b1 ~b2)) (* ~c1 ~c2)))
  ([a1 a2 b1 b2 c1 c2 d]
    `(+ (+ (+ (* ~a1 ~a2) (* ~b1 ~b2)) (* ~c1 ~c2)) ~d))
  ([a1 a2 b1 b2 c1 c2 d1 d2]
    `(+ (+ (+ (* ~a1 ~a2) (* ~b1 ~b2)) (* ~c1 ~c2)) (* ~d1 ~d2))))
#+END_SRC

** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/math/matrix.cljx
(ns thi.ng.math.matrix
  (:require
    [thi.ng.math.core :as m]
    [thi.ng.geom.core :as g])
  #+clj  (:use thi.ng.math.macros)
  #+cljs (:use-macros thi.ng.math.macros))
#+END_SRC
** Protcols
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/math/matrix.cljx
  (defprotocol PMatrix
    (multiply [this m])
    (set-position [this p])
    (set-scale [this s])
    (set-rotation [this r])
    (transpose [this])
    (determinant [this]))
#+END_SRC
** Forward declarations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/math/matrix.cljx
  (declare IDENTITY4x4)
#+END_SRC
** Type implementations
*** 4x4 Matrix
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/math/matrix.cljx
  (deftype Matrix44
      [^double m00 ^double m01 ^double m02 ^double m03
       ^double m10 ^double m11 ^double m12 ^double m13
       ^double m20 ^double m21 ^double m22 ^double m23
       ^double m30 ^double m31 ^double m32 ^double m33
       _meta]

    PMatrix
    (multiply [this m]
      (let [^Matrix44 m m]
        (Matrix44.
         (mat-item m00 (.-m00 m) m01 (.-m10 m) m02 (.-m20 m) m03 (.-m30 m))
         (mat-item m00 (.-m01 m) m01 (.-m11 m) m02 (.-m21 m) m03 (.-m31 m))
         (mat-item m00 (.-m02 m) m01 (.-m12 m) m02 (.-m22 m) m03 (.-m32 m))
         (mat-item m00 (.-m03 m) m01 (.-m13 m) m02 (.-m23 m) m03 (.-m33 m))

         (mat-item m10 (.-m00 m) m11 (.-m10 m) m12 (.-m20 m) m13 (.-m30 m))
         (mat-item m10 (.-m01 m) m11 (.-m11 m) m12 (.-m21 m) m13 (.-m31 m))
         (mat-item m10 (.-m02 m) m11 (.-m12 m) m12 (.-m22 m) m13 (.-m32 m))
         (mat-item m10 (.-m03 m) m11 (.-m13 m) m12 (.-m23 m) m13 (.-m33 m))

         (mat-item m20 (.-m00 m) m21 (.-m10 m) m22 (.-m20 m) m23 (.-m30 m))
         (mat-item m20 (.-m01 m) m21 (.-m11 m) m22 (.-m21 m) m23 (.-m31 m))
         (mat-item m20 (.-m02 m) m21 (.-m12 m) m22 (.-m22 m) m23 (.-m32 m))
         (mat-item m20 (.-m03 m) m21 (.-m13 m) m22 (.-m23 m) m23 (.-m33 m))

         (mat-item m20 (.-m00 m) m21 (.-m10 m) m22 (.-m20 m) m23 (.-m30 m))
         (mat-item m20 (.-m01 m) m21 (.-m11 m) m22 (.-m21 m) m23 (.-m31 m))
         (mat-item m20 (.-m02 m) m21 (.-m12 m) m22 (.-m22 m) m23 (.-m32 m))
         (mat-item m20 (.-m03 m) m21 (.-m13 m) m22 (.-m23 m) m23 (.-m33 m))
         _meta)))

    (set-position [this [x y z]]
      (Matrix44.
       m00 m01 m02 x
       m10 m11 m12 y
       m20 m21 m22 z
       m30 m31 m32 m33 _meta))

    (set-scale [this s]
      (let [[x y z] (if (number? s) [s s s] s)]
        (Matrix44.
         x m01 m02 m03
         m10 y m12 m12
         m20 m21 z m23
         m30 m31 m32 m33 _meta)))

    (set-rotation [this [rx ry rz]] ;; TODO
      (Matrix44.
       m00 m01 m02 m03
       m10 m11 m12 m12
       m20 m21 m22 m23
       m30 m31 m32 m33 _meta))

    (transpose [this]
      (Matrix44.
       m00 m10 m20 m30
       m01 m11 m21 m31
       m02 m12 m22 m32
       m03 m13 m23 m33 _meta))

    (determinant [this]
      (+ (+ (- (- (* m30 m21 m12 m03) (* m20 m31 m12 m03)) (* m30 m11 m22 m03)) (* m10 m31 m22 m03))
         (+ (- (- (* m20 m11 m32 m03) (* m10 m21 m32 m03)) (* m30 m21 m02 m13)) (* m20 m31 m02 m13))
         (+ (- (- (* m30 m01 m22 m13) (* m00 m31 m22 m13)) (* m20 m01 m32 m13)) (* m00 m21 m32 m13))
         (+ (- (- (* m30 m11 m02 m23) (* m10 m31 m02 m23)) (* m30 m01 m12 m23)) (* m00 m31 m12 m23))
         (+ (- (- (* m10 m01 m32 m23) (* m00 m11 m32 m23)) (* m20 m11 m02 m33)) (* m10 m21 m02 m33))
         (+ (- (- (* m20 m01 m12 m33) (* m00 m21 m12 m33)) (* m10 m01 m22 m33)) (* m00 m11 m22 m33))))

    g/PInvertible
    (invert [this]
      (let [n00 (- (* m00 m11) (* m01 m10))
            n01 (- (* m00 m12) (* m02 m10))
            n02 (- (* m00 m13) (* m03 m10))
            n03 (- (* m01 m12) (* m02 m11))
            n04 (- (* m01 m13) (* m03 m11))
            n05 (- (* m02 m13) (* m03 m12))
            n06 (- (* m20 m31) (* m21 m30))
            n07 (- (* m20 m32) (* m22 m30))
            n08 (- (* m20 m33) (* m32 m30))
            n09 (- (* m21 m32) (* m22 m31))
            n10 (- (* m21 m33) (* m23 m31))
            n11 (- (* m22 m33) (* m23 m32))
            d (+ (- (+ (+ (- (* n00 n11) (* n01 n10)) (* n02 n09)) (* n03 n08)) (* n04 n07)) (* n05 n06))]
        (when-not (zero? d)
          (let [invd (/ 1.0 d)]
            (Matrix44.
             (* invd (+ (- (* m11 n11) (* m12 n10)) (* m13 n09))) ;0
             (* invd (+ (- (* m02 n10) (* m03 n09)) (* (- m01) n11))) ;1
             (* invd (+ (- (* m31 n05) (* m32 n04)) (* m33 n03))) ;2
             (* invd (+ (- (* m22 n04) (* m23 n03)) (* (- m21) n05))) ;3
             (* invd (+ (- (* m12 n08) (* m13 n07)) (* (- m10) n11))) ;4
             (* invd (+ (- (* m00 n11) (* m02 n08)) (* m03 n07))) ;5
             (* invd (+ (- (* m32 n02) (* m33 n01)) (* (- m30) n05))) ;6
             (* invd (+ (- (* m20 n05) (* m22 n02)) (* m23 n01))) ;7
             (* invd (+ (- (* m10 n10) (* m11 n08)) (* m13 n06))) ;8
             (* invd (+ (- (* m01 n08) (* m03 n06)) (* (- m00) n10))) ;9
             (* invd (+ (- (* m30 n04) (* m31 n02)) (* m33 n00))) ;10
             (* invd (+ (- (* m21 n02) (* m23 n00)) (* (- m20) n04))) ;11
             (* invd (+ (- (* m11 n07) (* m12 n06)) (* (- m10) n09))) ;12
             (* invd (+ (- (* m00 n09) (* m01 n07)) (* m02 n06))) ;13
             (* invd (+ (- (* m31 n01) (* m32 n00)) (* (- m30) n03))) ;14
             (* invd (+ (- (* m20 n03) (* m21 n01)) (* m22 n00))) ;15
             _meta)))))

    g/PTransformable
    (scale [this s]
      (multiply this (set-scale IDENTITY4x4 s)))
    (scale-n [this s]
      (multiply this (set-scale IDENTITY4x4 s)))
    (translate [this t]
      (multiply this (set-position IDENTITY4x4 t)))
    (rotate-x [this theta]
      (let [s (Math/sin theta) c (Math/cos theta)]
        (multiply
         this
         (Matrix44.
          1 0 0 0
          0 c (- s) 0
          0 s c 0
          0 0 0 1 nil))))
    (rotate-y [this theta]
      (let [s (Math/sin theta) c (Math/cos theta)]
        (multiply
         this
         (Matrix44.
          c 0 s 0
          0 1 0 0
          (- s) 0 c 0
          0 0 0 1 nil))))
    (rotate-z [this theta]
      (let [s (Math/sin theta) c (Math/cos theta)]
        (multiply
         this
         (Matrix44.
          c (- s) 0 0
          s c 0 0
          0 0 1 0
          0 0 0 1 nil))))
    (rotate-around-axis [this [x y z] theta]
      (let [s (Math/sin theta) c (Math/cos theta)
            sx (* s x) sy (* s y) sz (* s z)
            t (- 1.0 c) tx (* t x) ty (* t y)]
        (multiply
         this
         (Matrix44.
          (+ (* tx x) c) (+ (* tx y) sz) (- (* tx z) sy) 0.0
          (- (* tx y) sz) (+ (* ty y) c) (+ (* ty z) sx) 0.0
          (+ (* tx z) sy) (- (* ty z) sx) (+ (* t z z) c) 0.0
          0.0 0.0 0.0 1.0 nil))))
    )


  (defn multiply-vec3
    "Transforms the vec3 parameter by the given matrix."
    [[m00 m01 m02 m03 m10 m11 m12 m13 m20 m21 m22 m23 m30 m31 m32 m33] [x y z]]
    [(mat-item x m00 y m01 z m02 m03)
     (mat-item x m10 y m11 z m12 m13)
     (mat-item x m20 y m21 z m22 m23)])

  (defn multiply-vec4
    "Transforms the vec4 parameter by the given matrix."
    [[m00 m01 m02 m03 m10 m11 m12 m13 m20 m21 m22 m23 m30 m31 m32 m33] [x y z w]]
    [(mat-item x m00 y m01 z m02 w m03)
     (mat-item x m10 y m11 z m12 w m13)
     (mat-item x m20 y m21 z m22 w m23)
     (mat-item x m30 y m31 z m32 w m33)])

  (defn multiply-normal
    "Transforms the normal parameter by the given matrix.
    The fourth element of the normal is *always* assumed to be zero.
    This means only scale/rotation (no translation/position) is taken into account."
    [m [x y z]]
    [(mat-item x (m 0) y (m 1) z (m 2))
     (mat-item x (m 4) y (m 5) z (m 6))
     (mat-item x (m 8) y (m 9) z (m 10))])

#+END_SRC
** Identity matrices
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/math/matrix.cljx
  (def ^:const IDENTITY4x4
    (Matrix44.
     1.0 0.0 0.0 0.0
     0.0 1.0 0.0 0.0
     0.0 0.0 1.0 0.0
     0.0 0.0 0.0 1.0 nil))
#+END_SRC
** Type specific functions
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/math/matrix.cljx
  (defn frustum
    "Sets up a viewing frustum, which is shaped like a truncated pyramid with the
    camera where the tip of the pyramid would be.
    This emulates the OpenGL function glFrustum()."
    [l t r b n f]
    (let [dx (- r l)
          dy (- t b)
          dz (- f n)]
      (Matrix44.
       (/ (* 2.0 n) dx) 0.0 (/ (+ r l) dx) 0.0
       0.0 (/ (* 2.0 n) dy) (/ (+ t b) dy) 0.0
       0.0 0.0 (* -1 (/ (+ f n) dz)) (/ (* (* -2.0 f) n) dz)
       0.0 0.0 -1.0 0.0
       nil)))

  (defn frustum-bounds
    [fov aspect near]
    (let [rad (* 0.5 (m/radians fov))
          top (* near (Math/tan rad))
          right (* top aspect)]
      {:left (- right)
       :right right
       :top top
       :bottom (- top)}))

  (defn ortho
    "Returns an orthographic projection, in which objects are the same size no
    matter how far away or nearby they are.
    This emulates the OpenGL function glOrtho()."
    [l t r b n f]
    (let[dx (- r l)
         dy (- t b)
         dz (- f n)]
      (Matrix44.
       (/ 2.0 dx) 0.0 0.0 (- (/ (+ r l) dx))
       0.0 (/ 2.0 dy) 0.0 (- (/ (+ t b) dy))
       0.0 0.0 (/ -2.0 dz) (- (/ (+ f n) dz))
       0.0 0.0 0.0 1.0
       nil)))

  (defn perspective
    "Returns a perspective transform matrix, which makes far away objects appear
    smaller than nearby objects. The `aspect` argument should be the width
    divided by the height of your viewport and `fov` is the vertical angle
    of the field of view in degrees.
    This emulates the OpenGL function gluPerspective()."
    [fov aspect near far]
    (let [rad (* 0.5 (m/radians fov))
          cot (/ (Math/cos rad) (Math/sin rad))
          deltaz (- far near)
          a (/ cot aspect)
          b (- (/ (+ far near) deltaz))
          c (/ (* -2.0 near far) deltaz)]
      (Matrix44.
       a 0.0 0.0 0.0
       0.0 cot 0.0 0.0
       0.0 0.0 b c
       0.0 0.0 -1.0 0.0
       nil)))

  (defn perspective-frustum
    [fov aspect near far]
    (let [{:keys [left right top bottom]} (frustum-bounds fov aspect near)]
      (frustum left top right bottom near far)))

  (defn look-at
    "Returns a matrix that puts the camera at the eye position looking
    toward the target point with the given up direction.
    This emulates the OpenGL function `gluLookAt()`."
    [eye target upvec]
    (let [[fx fy fz :as f] (g/normalize (g/sub eye target))
          [sx sy sz :as s] (g/normalize (g/cross upvec f))
          [tx ty tz :as t] (g/normalize (g/cross f s))]
      (Matrix44.
       sx sy sz (- (g/dot s eye))
       tx ty tz (- (g/dot t eye))
       fx fy fz (- (g/dot f eye))
       0.0 0.0 0.0 1.0
       nil)))
#+END_SRC
