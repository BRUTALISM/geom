* thi.ng.geom.bezier
** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/bezier.cljx
  (ns thi.ng.geom.bezier
    (:require
     [thi.ng.data.core :as d]
     [thi.ng.math.core :as m]
     [thi.ng.geom.core :as g]))
#+END_SRC
** The Bernstein polynomial
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/bezier.cljx
(defn bernstein
  [t]
  (let [it (- 1.0 t) it2 (* it it) t2 (* t t)]
    [(* it it2) (* 3 (* t it2)) (* 3 (* it t2)) (* t t2)]))
#+END_SRC
** Interpolation & curve samplings
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/bezier.cljx
  (defn interpolate
    [[a b c d] t]
    (let [[ta tb tc td] (bernstein t)]
      (->> (g/scale a ta)
           (g/madd b tb)
           (g/madd c tc)
           (g/madd d td))))

  (defn sample-segment
    [seg res]
    (map #(interpolate seg %) (m/norm-range res)))

  (defn sample-with-res
    [res include-last? points]
    (let [ls (->> points
                  (d/successive-nth 4)
                  (take-nth 3)
                  (mapcat #(sample-segment % res)))]
      (if include-last?
        (concat ls [(last points)])
        ls)))
#+END_SRC
** Automatic curve generation
     The following two functions allow us to compute a bezier curve
     which passes through all given points and automatically computes
     the required control points.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/bezier.cljx
  (defn- find-cpoints*
    [ctor]
    (fn [tight points]
      (let [np (count points)
            invt (/ 1.0 tight)
            points (vec points)
            c1 (g/scale (g/sub (get points 2) (first points)) tight)
            [bi coeff] (reduce
                        (fn [[bi coeff] i]
                          (let [b (/ -1.0 (+ invt (peek bi)))
                                c (peek coeff)
                                p (get points (dec i))
                                q (get points (inc i))]
                            [(conj bi b)
                             (conj coeff (g/scale (g/sub q p c) (- b)))]))
                        [[0 (- tight)] [(ctor) c1]]
                        (range 2 (dec np)))]
        (reduce
         (fn [delta i]
           (assoc delta i (g/madd (delta (inc i)) (bi i) (coeff i))))
         (vec (repeatedly np ctor))
         (range (- np 2) 0 -1)))))

  (defn auto-spline*
    [find-cpoints]
    (fn [tight points]
      (concat
       (->> points
            (find-cpoints tight)
            (d/successive-nth 2)
            (interleave (d/successive-nth 2 points))
            (partition 2)
            (mapcat (fn [[[p q] [dp dq]]] [p (g/add p dp) (g/sub q dq)])))
       [(last points)])))
#+END_SRC
** Concrete implementations for 2D/3D...
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/bezier.cljx
(def auto-spline2 (auto-spline* (find-cpoints* g/vec2)))
(def auto-spline3 (auto-spline* (find-cpoints* g/vec3)))
#+END_SRC
