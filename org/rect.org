* thi.ng.geom.rect
** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  (ns thi.ng.geom.rect
    (:require
     [thi.ng.data.core :as d]
     [thi.ng.math.core :as m :refer [*eps*]]
     [thi.ng.geom.core :as g :refer [vec2 vec3]]
     [thi.ng.geom.aabb :as aabb]
     [thi.ng.geom.mesh :as mesh]
     [thi.ng.geom.types :as types])
    #+clj
    (:import
     [thi.ng.geom.types Circle Line2 Polygon Rect]))
#+END_SRC
** Constructor
*** TODO replace sequential? w/ coll?
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  (defn rect
    ([] (thi.ng.geom.types.Rect. (vec2) 1.0 1.0))
    ([w] (thi.ng.geom.types.Rect. (vec2) w w))
    ([p q]
       (if (sequential? p)
         (if (sequential? q)
           (let [p (vec2 p) q (vec2 q)
                 [p q] [(g/minv p q) (g/maxv p q)]
                 [w h] (g/sub q p)]
             (thi.ng.geom.types.Rect. p w h))
           (thi.ng.geom.types.Rect. (vec2 p) q q))
         (thi.ng.geom.types.Rect. (vec2) p q)))
    ([x y w]
       (if (number? x)
         (thi.ng.geom.types.Rect. (vec2 x y) w w)
         (thi.ng.geom.types.Rect. (vec2 x) y w)))
    ([x y w h] (thi.ng.geom.types.Rect. (vec2 x y) w h)))
#+END_SRC
** Type specific functions
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  (defn union
    [{:keys[p w h]} {q :p qw :w qh :h}]
    (let [[x1 y1] (g/minv p q)
          x2 (max (+ (p 0) w) (+ (q 0) qw))
          y2 (max (+ (p 1) h) (+ (q 1) qh))
          w (- x2 x1)
          h (- y2 y1)]
      (thi.ng.geom.types.Rect. [x1 y1] w h)))

  (defn map-uv
    [{:keys[p w h]} [qx qy]]
    [(/ (- qx (p 0)) w) (/ (- qy (p 1)) h)])

  (defn unmap-uv
    [{:keys[p w h]} [qx qy]]
    [(m/fma qx w (p 0)) (m/fma qy h (p 1))])

  (defn left [r] ((:p r) 0))
  (defn right [r] (+ ((:p r) 0) (:w r)))
  (defn top [r] ((:p r) 1))
  (defn bottom [r] (+ ((:p r) 1) (:h r)))
  (defn bottom-right [r] (g/add (:p r) [(:w r) (:h r)]))

  (defn rects-intersect?
    [{[px py] :p w :w h :h} {[qx qy] :p w2 :w h2 :h}]
    (not (or (> px (+ qx w2)) (> qx (+ px w)) (> py (+ qy h2)) (> qy (+ py h)))))

  (defn intersect-circle
    [{w :w h :h :as r} {c :p radius :r}]
    (let [p (g/centroid r)
          [dx dy :as d] (g/abs (g/sub c p))
          w (* w 0.5) h (* h 0.5)]
      (if (and (<= dx (+ w radius))
               (<= dy (+ h radius)))
        (if (or (<= dx w) (<= dy h))
          true
          (<= (g/mag-squared (g/sub d [w h])) (* radius radius)))
        false)))
#+END_SRC
** Protocol implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  (extend-type thi.ng.geom.types.Rect
#+END_SRC
*** PGraph
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  g/PGraph
  (vertices
   [{[x y :as p] :p w :w h :h}]
   (let [r (+ x w) b (+ y h)] [p (vec2 r y) (vec2 r b) (vec2 x b)]))
  (edges
   [{[x y :as p] :p w :w h :h}]
   (let [r (+ x w) b (+ y h)]
     [(thi.ng.geom.types.Line2. p (vec2 r y))
      (thi.ng.geom.types.Line2. (vec2 r y) (vec2 r b))
      (thi.ng.geom.types.Line2. (vec2 r b) (vec2 x b))
      (thi.ng.geom.types.Line2. (vec2 x b) p)]))
  (vertex-neighbors
   [this v] (d/neighbors (vec2 v) (g/vertices this)))
  (vertex-valence
   [this v] (if ((set (g/vertices this)) (vec2 v)) 2 0))
#+END_SRC
*** PShape
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  g/PShape
  (area
   [this] (* (:w this) (:h this)))
  (bounds[this] this)
  (center
   ([{w :w h :h}]
      (let [w2 (* w 0.5) h2 (* h 0.5)]
        (thi.ng.geom.types.Rect. (vec2 (- w2) (- h2)) w h)))
   ([{w :w h :h} o]
      (let [t [(* w 0.5) (* h 0.5)]]
        (thi.ng.geom.types.Rect. (g/sub o t) w h))))
  (centroid
   [{p :p :as this}] (g/mid p (g/add p (:w this) (:h this))))
  (width  [this] (:w this))
  (height [this] (:h this))
  (depth  [this] 0)
#+END_SRC
*** PShape2
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  g/PShape2
  (bounding-circle
   [this]
   (let [c (g/centroid this)]
     (g/bounding-circle* c (g/dist c (:p this)))))
  (circumference
   [this] (* 2 (+ (:w this) (:h this))))
#+END_SRC
*** PBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  g/PBoundary
  (classify-point
   [this q]
   (reduce min (map #(g/classify-point % q) (g/edges this))))
  (closest-point
   [this q]
   (g/closest-point* (g/edges this) q))
  (contains-point?
   [{[px py] :p w :w h :h} [x y]]
   (and (m/in-range? 0.0 w (- x px)) (m/in-range? 0.0 h (- y py))))
#+END_SRC
*** PSampleable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  g/PSampleable
  (point-at [this t] nil) ; TODO
  (random-point
   [this] (g/point-at this (m/random)))
  (random-point-inside
   [this] (g/add (:p this) (m/random (:w this)) (m/random (:h this))))
#+END_SRC
*** PPolygonizable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  g/PPolygonizable
  (as-polygon
   [this] (thi.ng.geom.types.Polygon. (g/vertices this) []))
#+END_SRC
*** PSubdivideable
    A rectangle can be subdivided into smaller ones, i.e. to create a
    list of uniform grid cells. The following options can be given as
    a 2nd argument map:

    | Key     | Description                                                    | Default |
    |---------+----------------------------------------------------------------+---------|
    | =:num=  | number of cols/rows the rect will be uniformly subdivided into |       2 |
    | =:cols= | number of times the rect will be subdivided along the X-axis   |       2 |
    | =:rows= | number of times the rect will be subdivided along the Y-axis   |       2 |

    When =:num= is given, the resulting rects will retain the aspect
    ratio of the original rect. If specified, =:cols= and =:rows= will
    take precedence over =:num=, but the latter will be used as
    default for missing args. Rects are returned as a lazyseq with
    top-left to bottom-right ordering and inner sorting along X.

#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  g/PSubdivideable
  (subdivide
   ([this] (g/subdivide this {}))
   ([this {:keys [num cols rows] :or {num 2}}]
      (let [dx (/ 1.0 (or cols num))
            dy (/ 1.0 (or rows num))
            rx (range 0.0 1.0 dx)
            ry (range 0.0 1.0 dy)
            w (* (:w this) dx)
            h (* (:h this) dy)]
        (for [y ry x rx
              :let [[px py] (unmap-uv this [x y])
                    px (m/roundto px *eps*)
                    py (m/roundto py *eps*)]]
          (thi.ng.geom.types.Rect. (vec2 px py) w h)))))
#+END_SRC
*** PTessellateable
    A rectangle can be tessellated into a number of triangles. When
    called without options map as 2nd argument, the rect will be split
    into 2 triangles, each in anti-clockwise orientation: =[tl br tr]=
    & =[tl bl br]=. When called *with* options, then these are used
    for a call to [[PSubdivideable][=subdivide=]] first and the function returns a lazyseq
    of triangles of the subdivided rects.
**** TODO return Triangle2 instances
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  g/PTessellateable
  (tessellate
   ([this]
      (let [[a b c d] (g/vertices this)] [[a b c] [a c d]]))
   ([this opts]
      (mapcat g/tessellate (g/subdivide this opts))))
#+END_SRC
*** PExtrudeable
    Extruding a rectangle along the Z-axis results in a 3D mesh
    implementation. The =extrude= function supports two options,
    given as parameter map:

    | Key      | Description                             | Default |
    |----------+-----------------------------------------+---------|
    | =:depth= | extrusion depth along positive Z        |     1.0 |
    | =:scale= | scale factor of rect at extrusion depth |     1.0 |

    The process results is bevelled forms for =:scale= values other
    than 1.0.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  g/PExtrudeable
  (extrude
   [this {depth :depth scale :scale :or {depth 1.0 scale 1.0}}]
   (if (= scale 1.0)
     (g/as-mesh
      (thi.ng.geom.types.AABB.
       (vec3 (:p this))
       (vec3 (:w this) (:h this) depth)))
     (let [[a b c d] (map vec3 (g/vertices this))
           [a2 b2 c2 d2] (-> this
                             (g/scale scale)
                             (g/center (g/centroid this))
                             (g/vertices)
                             (map vec3))]
       (mesh/mesh3
        [a b c] [a c d]       ;;back
        [a2 c2 b2] [a2 d2 c2] ;; front
        [a d2 d] [a d2 a2]    ;; left
        [b2 c2 c] [b2 c b]    ;; right
        [a a2 b2] [a b2 b]    ;; top
        [d c2 d2] [d c c2]    ;; bottom
        ))))
#+END_SRC
*** TODO PTransformable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx

#+END_SRC
*** End of implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  )
#+END_SRC
