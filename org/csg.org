* Namespace: thi.ng.geom.csg
** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/csg.cljx
  (ns thi.ng.geom.csg
    (:require
      [thi.ng.data.core :as d]
      [thi.ng.math.core :as m :refer [PI TWO_PI *eps*]]
      [thi.ng.geom.core :as g :refer [vec3]]
      [thi.ng.geom.mesh :as mesh]
      [thi.ng.geom.triangle :as t]))
#+END_SRC
** Forward declarations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/csg.cljx
  (declare csg-vertex csg-polygon)
#+END_SRC
** Helper functions
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/csg.cljx
  (defn interpolate-vertex
    "Linearly interpolates between the 2 vertices
    (computes both position & normal)."
    [a b t]
    (csg-vertex (g/mix (:p a) (:p b) t) (g/mix (:n a) (:n b) t)))

  (defn flip-vertex
    "Applies `invert3` to the `:n` (normal) value of a vertex."
    [x] (assoc x :n (g/invert (:n x))))

  (defn flip-plane
    "Flips the plane's orientation by inverting normal vector & `w` constant."
    [p]
    (assoc p :n (g/invert (:n p)) :w (- (:w p))))

  (defn flip-poly
    "Flips the polygon's orientation by reversing its vertex order and
    inverting all vertex normals and its plane normal."
    [poly]
    (assoc poly
      :vertices (vec (map flip-vertex (reverse (:vertices poly))))
      :plane (flip-plane (:plane poly))))

  (defn split-poly
    "Takes a plane and splits the given polygon with it. Returns a 4-element vector
    of classified sub-shapes: coplanar (front), coplanar (back), front & back."
    [{:keys [n w]} {:keys [vertices plane] :as poly} cp-front cp-back front back]
    (let [[ptype types]
          (reduce
           (fn [[ptype types] v]
             (let [t (- (g/dot n (:p v)) w)
                   pt (cond
                       (< t (- *eps*)) 2
                       (> t *eps*) 1
                       :default 0)]
               [(bit-or ptype pt) (conj types pt)]))
           [0 []] vertices)]
      (condp = ptype
        ;; co-planar
        0 (if (pos? (g/dot n (:n plane)))
            [(conj cp-front poly) cp-back front back]
            [cp-front (conj cp-back poly) front back])
        ;; front
        1 [cp-front cp-back (conj front poly) back]
        ;; back
        2 [cp-front cp-back front (conj back poly)]
        ;; both sides -> split
        3 (let [nv (count vertices)
                [f b]
                (reduce
                 (fn [[f b] i]
                   (let [j (rem (inc i) nv)
                         ti (types i) tj (types j)
                         vi (vertices i)
                         f (if (= ti 2) f (conj f vi))
                         b (if (= ti 1) b (conj b vi))]
                     (if (= (bit-or ti tj) 3)
                       (let [vj (vertices j)
                             t (/ (- w (g/dot n (:p vi))) (g/dot n (g/sub (:p vj) (:p vi))))
                             v (interpolate-vertex vi vj t)]
                         [(conj f v) (conj b v)])
                       [f b])))
                 [[] []] (range nv))]
            [cp-front cp-back
             (if (>= (count f) 3) (conj front (csg-polygon f (:shared poly))) f)
             (if (>= (count b) 3) (conj back (csg-polygon b (:shared poly))) b)]))))
#+END_SRC
** Public API
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/csg.cljx
  (defn clip-polygons
    "Uses a CSG node's plane to recursively clip the given seq of polygons.
    Returns a flat seq of polygons classified as in-front of the plane
    or the original seq if no clipping plane is available."
    [{:keys [plane front back] :as node} ps]
    (if (not plane)
      ps
      (let [[cp-front cp-back new-front new-back]
            (reduce
             (fn [[cp-front cp-back front back] poly]
               (split-poly plane poly cp-front cp-back front back))
             [[] [] [] []] ps)
            new-front (concat new-front cp-front)
            new-front (if front (clip-polygons front new-front) new-front)
            new-back (if back (clip-polygons back (concat new-back cp-back)) [])]
        (concat new-front new-back))))

  (defn all-polygons
    "Returns a lazy seq of all polygons of the given CSG node and its children."
    [{:keys [front back] :as node}]
    (concat
     (:polygons node)
     (if front (all-polygons front))
     (if back (all-polygons back))))

  (defn invert
    [{:keys [front back plane] :as node}]
    (assoc node
      :polygons (map flip-poly (:polygons node))
      :plane (if plane (flip-plane plane))
      :front (if back (invert back))
      :back (if front (invert front))))

  (defn clip
    "Clips the polygons of the first node with the ones from the second.
    Returns the updated node."
    [{:keys [front back] :as a} b]
    (assoc a
      :polygons (clip-polygons b (:polygons a))
      :front (if front (clip front b))
      :back (if back (clip back b))))

  (defn csg-vertex
    "Creates a map of a position and normal vector."
    [p n] {:p p :n n})

  (defn csg-plane
    "Creates a plane definition either from a seq of points or
    a normal vector & w-constant."
    ([[a b c]]
       (let [[a b c] (map #(if (map? %) (:p %) %) [a b c])
             n (g/normal3* a b c)]
         {:n n :w (g/dot n a)}))
    ([n w] {:n n :w w}))

  (defn csg-polygon
    "Creates a CSG polygon map from the given vertices and
    computes a plane definition using the first 3 vertices."
    ([vertices] (csg-polygon vertices nil))
    ([vertices shared]
       {:vertices (vec vertices)
        :shared shared
        :plane (csg-plane vertices)}))

  (defn csg-node
    "Creates or refines a new CSG tree node and recursively
    adds the given polygons to it."
    ([polygons] (csg-node nil polygons))
    ([{:keys [polygons plane front back] :as node} ps]
       (if (seq ps)
         (let [plane (or plane (:plane (first ps)))
               [cp-front cp-back new-front new-back]
               (reduce
                (fn [[cp-front cp-back front back] poly]
                  (split-poly plane poly cp-front cp-back front back))
                [[] [] [] []] ps)]
           (assoc node
             :plane plane
             :polygons (concat polygons cp-front cp-back)
             :front (if (seq new-front) (csg-node front new-front) front)
             :back (if (seq new-back) (csg-node back new-back) back)))
         node)))

  (defn union
    [a b]
    (let [a (csg-node a)
          b (csg-node b)
          a (clip a b)
          b (-> b (clip a) invert (clip a) invert)]
      (-> a (csg-node (all-polygons b)) all-polygons)))

  (defn subtract
    [a b]
    (let [b (csg-node b)
          a (-> a csg-node invert (clip b))
          b (-> b (clip a) invert (clip a) invert)]
      (-> a (csg-node (all-polygons b)) invert all-polygons)))

  (defn intersect
    [a b]
    (let [a (-> a csg-node invert)
          b (-> b csg-node (clip a) invert)
          a (clip a b)
          b (clip b a)]
      (-> a (csg-node (all-polygons b)) invert all-polygons)))
#+END_SRC
** Constructors
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/csg.cljx
  (defn mesh->csg
    "Converts a regular Mesh3 into a seq of CSG polygons.
    First calls `compute-face-normals` on mesh if not already present."
    [{:keys [faces fnormals] :as m}]
    (let [fnormals (if (seq fnormals)
                     fnormals
                     (:fnormals (g/compute-face-normals m)))]
      (map
       (fn [f]
         (let [n (fnormals f)]
           (csg-polygon (map #(csg-vertex % n) f) nil)))
       faces)))

  (defn csg->mesh
    [polygons]
    (apply
     mesh/mesh3
     (mapcat
      (fn [{:keys [vertices]}]
        (let [v0 (:p (first vertices))]
          (map
           (fn [[i j]] [v0 (:p i) (:p j)])
           (d/successive-nth 2 (drop 1 vertices)))))
      polygons)))

  (defn csg-aabb
    [{:keys [p size] :as b}]
    (let [[cx cy cz] (g/centroid b)
          [sx sy sz] (g/scale size 0.5)
          f (fn [c s i mask] (m/madd s (if (pos? (bit-and i mask)) 1 -1) c))]
      (map
       (fn [[verts n]]
         (csg-polygon
          (map
           (fn [i]
             (csg-vertex
              [(f cx sx i 1) (f cy sy i 2) (f cz sz i 4)] n))
           verts)))
       [[[0 4 6 2] [-1 0 0]]
        [[1 3 7 5] [1 0 0]]
        [[0 1 5 4] [0 -1 0]]
        [[2 6 7 3] [0 1 0]]
        [[0 2 3 1] [0 0 -1]]
        [[4 5 7 6] [0 0 1]]])))

  (defn csg-sphere
    [{:keys [p r]} slices stacks]
    (map
     (fn [verts]
       (csg-polygon
        (map
         (fn [[u v]]
           (let [theta (* TWO_PI u)
                 phi (* PI v)
                 st (Math/sin theta) ct (Math/cos theta)
                 sp (Math/sin phi) cp (Math/cos phi)
                 dir (vec3 (* ct sp) cp (* st sp))]
             (csg-vertex (g/madd dir r p) dir)))
         verts)))
     (for [i (range slices) j (range stacks)
           :let [u (/ i slices) v (/ j stacks)
                 u1 (/ (inc i) slices) v1 (/ (inc j) stacks)
                 verts [[u v]]
                 verts (if (pos? j) (conj verts [u1 v]) verts)
                 verts (if (< j (dec stacks)) (conj verts [u1 v1]) verts)]]
       (conj verts [u v1]))))

  (defn csg-cone
    ([s e radius res] (csg-cone s e radius radius res))
    ([s e r-south r-north res]
       (let [dir (g/sub e s)
             az (g/normalize dir)
             ax (-> (if (> (m/abs (az 1)) 0.5)
                      (vec3 1 0 0)
                      (vec3 0 1 0))
                    (g/cross az)
                    g/normalize)
             ay (-> ax (g/cross az) g/normalize)
             vs (csg-vertex s (g/invert az))
             ve (csg-vertex e az)
             f (fn [stack i blend r]
                 (let [theta (* m/TWO_PI i)
                       out (g/madd ax (Math/cos theta) (g/scale ay (Math/sin theta)))
                       norm (g/madd out (- 1.0 (m/abs blend)) (g/scale az blend))
                       pos (g/add s (g/scale dir stack) (g/scale out r))]
                   (csg-vertex pos norm)))
             res (double res)]
         (mapcat
          (fn [i]
            (let [t0 (/ i res) t1 (/ (inc i) res)]
              [(csg-polygon [vs (f 0 t0 -1 r-south) (f 0 t1 -1 r-south)])
               (csg-polygon [(f 0 t1 0 r-south) (f 0 t0 0 r-south) (f 1 t0 0 r-north) (f 1 t1 0 r-north)])
               (csg-polygon [ve (f 1 t1 1 r-north) (f 1 t0 1 r-north)])]))
          (range res)))))
#+END_SRC
