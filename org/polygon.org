* thi.ng.geom.polygon
** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  ^:clj  (ns thi.ng.geom.polygon
           (:require
            [thi.ng.data.core :as d]
            [thi.ng.math.core :as m :refer [PI HALF_PI *eps*]]
            [thi.ng.geom.core :as g]
            [thi.ng.geom.types :as types])
           (:import
            [thi.ng.geom.types Circle Line2 Rect Polygon]))
  ^:cljs (ns thi.ng.geom.polygon
           (:require
            [thi.ng.data.core :as d]
            [thi.ng.math.core :as m :refer [*eps*]]
            [thi.ng.geom.core :as g]
            [thi.ng.geom.types :as types]))
#+END_SRC
** Constructor
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  (defn polygon
    ([points] (thi.ng.geom.types.Polygon. (vec (map g/vec2 points)) []))
    ([p & more] (thi.ng.geom.types.Polygon. (vec (map g/vec2 (cons p more))) [])))
#+END_SRC
** Type specific functions
#+BEGIN_SRC clojure
  ;; :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  (defn clip-convex
    [poly bounds]
    (let [verts (if (map? poly) (:points poly) (vec poly))
          verts (conj verts (first verts))
          bc (g/centroid bounds)
          ec-pos (fn [e p q] (:p (g/intersect-line e (Line2. p q))))]
      (loop [cedges (g/edges bounds) points verts clipped []]
        (if-let [ce (first cedges)]
          (let [sign (g/classify-point ce bc)
                clipped (reduce
                         (fn [clipped [p q]]
                           (if (= sign (g/classify-point ce p))
                             (if (= sign (g/classify-point ce q))
                               (conj clipped q)
                               (conj clipped (ec-pos ce p q)))
                             (if (= sign (g/classify-point ce q))
                               (conj clipped (ec-pos ce p q) q)
                               clipped)))
                         [] (d/successive-nth 2 points))
                clipped (if (and (pos? (count clipped))
                                 (not (m/delta= (first clipped) (peek clipped))))
                          (conj clipped (first clipped))
                          clipped)]
            (recur (rest cedges) clipped points))
          (polygon (butlast points))))))

  (defn delta-contains
    [points p eps]
    (some #(m/delta= p % eps) points))

  (defn crossed-edge?
    [e a b]
    (let [{t :type ua :ua} (g/intersect-line e {:p a :q b})]
      (and (= :intersect t) (m/in-range? 0.01 0.99 ua))))

  (defn tesselate
    [poly]
    (let [m (apply mesh2 (triangulate (:points poly)))
          assoc-bounds #(assoc! % %2 (g/bounding-rect* %2))
          fbounds (reduce assoc-bounds (transient {}) (:faces m))
          [m] (reduce
               (fn [[m fbounds] e]
                 (let [eb (g/bounds e)
                       faces (filter
                              (fn [[a b c :as f]]
                                (and (r/rects-intersect? eb (get fbounds f))
                                     (or (crossed-edge? e a b)
                                         (crossed-edge? e b c)
                                         (crossed-edge? e c a))))
                              (:faces m))
                       [m nf] (slice-with m e faces)
                       fbounds (reduce assoc-bounds fbounds nf)]
                   [m fbounds]))
               [m fbounds] (g/edges poly))]
      (keep-faces m #(g/contains-point? poly (centroid2* %)))))

  (defn randompoly
    [n r]
    (let [points (:points (g/as-polygon (circle r) n))]
      (polygon (map #(g/scale2 % (m/random 0.5 1.5)) points))))

  (defn h-segment
    [verts [px py :as p] pred theta ps]
    (let [[q] (reduce (fn[state [qx qy :as q]]
                        (if (pred qy py)
                          (let [d (m/abs-diff theta (g/heading2 [(- qx px) (- qy py)]))]
                            (if (< d (state 1)) [q d] state))
                          state))
                      [nil HALF_PI] ps)]
      (if q (recur (conj verts q) q pred theta (all-after q ps)) verts)))

  (defn convex-hull
    [points]
    (let [[p & more :as ps] (sort-by first (if (map? points) (:points points) points))
          rps (reverse ps)]
      (polygon
       (butlast
        (reduce
         (fn[v [pred t ps]] (h-segment v (peek v) pred t (d/all-after (peek v) ps)))
         [p] [[<= (* 1.5 PI) more] [>= 0.0 more]
              [>= HALF_PI rps] [<= PI rps]])))))
#+END_SRC
** Protocol implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  (extend-type thi.ng.geom.types.Polygon
#+END_SRC
*** IGraph
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  g/IGraph
  (vertices
   [this] (:points this))
  (edges
   [{points :points}]
   (map (fn [[p q]] (thi.ng.geom.types.Line2. p q))
        (d/successive-nth 2 (concat points [(first points)]))))
#+END_SRC
*** IShape
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  g/IShape
  (area
   [{points :points}]
   (let [p (first points)
         [area] (reduce (fn [[a p] v] [(+ a (g/cross2 p v)) v])
                        [0.0 p] (concat (drop 1 points) [p]))]
     (* 0.5 area)))
  (bounds
   [this] (g/bounding-rect* (:points this)))
  (center
   ([this] (g/center this [0.0 0.0]))
   ([this o]
      (thi.ng.geom.types.Polygon. (vec (g/translate2 (g/sub2 o (g/centroid this)) (:points this))) [])))
  (centroid
   [{points :points :as this}]
   (let [p (first points)
         [c] (reduce
              (fn [[c p] v]
                (let [x (g/cross2 p v)]
                  [(g/add2 c (g/scale2 (g/add2 p v) x)) v]))
              [[0.0 0.0] p] (conj (subvec points 1 (count points)) p))]
     (g/scale2 c (/ 1.0 (* 6 (g/area this))))))
#+END_SRC
*** IBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  g/IBoundary
  (classify-point
   [this p] nil) ; TODO
  (closest-point
   [this p] (g/closest-point* g/dist2-squared (g/edges this) p))
  (contains-point?
   [{points :points} p]
   (if (some #{p} points) true
       (let [[x y] p]
         (first
          (reduce
           (fn [[in [px py]] [vx vy]]
             (if (and (or (and (< vy y) (>= py y)) (and (< py y) (>= vy y)))
                      (< (+ vx (* (/ (- y vy) (- py vy)) (- px vx))) x))
               [(not in) [vx vy]] [in [vx vy]]))
           [false (last points)] points)))))
#+END_SRC
*** ISampleable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  g/ISampleable
  (point-at [this t] nil) ; TODO
  (random-point-at
   [this] (g/point-at this (m/random)))
  (random-point-inside [this] nil) ; TODO
#+END_SRC
*** IShape2
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  g/IShape2
  (bounding-circle
   [this] (g/bounding-circle* (g/centroid this) (:points this)))
  (circumference
   [{points :points}]
   (d/apply-to-pairs + g/dist2 (concat points [(first points)])))
#+END_SRC
*** End of implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  )
#+END_SRC
