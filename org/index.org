#+TITLE: thi.ng geometry kit
#+OPTIONS: toc:4
#+OPTIONS: h:4
#+OPTIONS: html-postamble:auto html-preamble:t tex:t
#+CREATOR: <a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.0.7)
#+HTML_CONTAINER: div
#+HTML_DOCTYPE: <!DOCTYPE html5>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_HEAD_EXTRA:
#+HTML_INCLUDE_SCRIPTS:
#+HTML_INCLUDE_STYLE:
#+HTML_LINK_HOME:
#+HTML_LINK_UP:
#+HTML_MATHJAX:
#+INFOJS_OPT:

* Leiningen project setup
** Leiningen coordinates
#+BEGIN_SRC clojure
  [thi.ng/geom "0.1.0-SNAPSHOT"]
#+END_SRC
** Leiningen project file
#+BEGIN_SRC clojure :tangle babel/project.clj
  (defproject thi.ng/geom "0.1.0-SNAPSHOT"
    :description "thi.ng geometry kit"
    :url "http://code.thi.ng/geom"
    :license {:name "Eclipse Public License"
              :url "http://www.eclipse.org/legal/epl-v10.html"}
    :dependencies [[org.clojure/clojure "1.5.1"]]
    :jar-exclusions [#"\.cljx|\.DS_Store"]
    :source-paths ["src-clj"]

    :cljx {:builds [{:source-paths ["src-cljx"]
                     :output-path "src-clj"
                     :include-meta true
                     :rules cljx.rules/clj-rules}
                    {:source-paths ["src-cljx"]
                     :output-path "src-cljs"
                     :extension "cljs"
                     :include-meta true
                     :rules cljx.rules/cljs-rules}]}

    :cljsbuild {:builds
                [{:id "dev"
                  :source-paths ["src-cljs"]
                  :compiler
                  {:pretty-print true
                   :output-to "resources/public/js/geom.js"
                   :optimizations :simple}
                  :jar false}]}

    :profiles {:dev {:plugins [[com.keminglabs/cljx "0.2.2"]
                               [org.clojars.cemerick/lein-cljsbuild "0.3.2.1"]]
                     :hooks [cljx.hooks]}})
#+END_SRC
* Namespaces
** Namespace: thi.ng.data
*** thi.ng.data.core
**** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/data/core.cljx
  (ns thi.ng.data.core)
#+END_SRC
**** Indexing functions
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/data/core.cljx
  (defn index
    [i t]
    (if-let [tt (get i t)] [i tt] [(conj i t) t]))

  (defn index!
    [i t]
    (if-let [tt (get i t)] [i tt] [(conj! i t) t]))

  (defn index-kv
    [m k v]
    (if-let [[k vv] (find m k)]
      (assoc m k (conj vv v))
      (assoc m k #{v})))

  (defn index-kv!
    [m k v]
    (if-let [vv (get m k)]
      (assoc! m k (conj vv v))
      (assoc! m k #{v})))

  (defn value-set
    ([idx v] (into #{} (get idx v)))
    ([f idx v] (persistent! (reduce #(conj! %1 (f %2)) (transient #{}) (get idx v)))))
#+END_SRC
**** Sequence functions
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/data/core.cljx
  (defn bisect
    ([f coll]
       (let [[m n] (reduce
                    (fn [[m n] v] (if (f v) [(conj! m v) n] [m (conj! n v)]))
                    [(transient []) (transient [])] coll)]
         [(persistent! m) (persistent! n)]))
    ([f f2 coll]
       (let [[m n] (bisect f coll)]
         [(f2 m) (f2 n)])))

  (defn successive-nth
    "Returns a lazyseq of `n`-element vectors, each one containing
    a successive elements of the original collection.

        (successive-nth 3 [1 2 3 4])
        => ([1 2 3] [2 3 4] [3 4 5])"
    [n coll]
    (lazy-seq
     (let [s (take n coll)]
       (if (= n (count s))
         (cons (vec s) (successive-nth n (rest coll)))))))

  (defn successive-nth-indexed
    "Returns a lazyseq of nested 2-element vectors, each one containing
    a vector of `n` successive elements of the original collection and
    an sequence index.

        (successive-nth-indexed 2 [10 20 30 40])
        => ([[10 20] 0] [[20 30] 1] [[30 40] 2])"
    ([n coll] (successive-nth-indexed n 0 coll))
    ([n idx coll]
       (lazy-seq
        (let [s (take n coll)]
          (if (= n (count s))
            (cons [(vec s) idx]
                  (successive-nth-indexed n (inc idx) (rest coll))))))))

  (defn apply-to-keys
    "Applies `f` with `args` to all given `keys` in `type`."
    [type keys f & args]
    (reduce (fn[acc k] (assoc acc k (apply f (get type k) args))) type keys))

  (defn apply-to-pairs
    [f1 f2 coll]
    (when (> (count coll) 1)
      (reduce f1 (map (fn [[a b]] (f2 a b))
                      (successive-nth 2 coll)))))

  (defn wrap-seq
    [s head tail]
    (concat
     (if (sequential? head) (concat head s) (cons head s))
     (if (sequential? tail) tail [tail])))

  (defn all-after
    "Returns a new collection of all items after `item` in original `coll`.
    If `coll` is a vector, the new collection is created with `subvec`.
    Returns original coll if item isn't found."
    [item coll]
    (let [idx (inc (.indexOf coll item))]
      (if (pos? idx)
        (if (vector? coll) (subvec coll idx) (drop idx coll))
        coll)))

  (defn iterate-while
    [pred f x]
    (lazy-seq
     (when (pred x)
       (cons x (iterate-while pred f (f x))))))
#+END_SRC
** Namespace: thi.ng.math
   Many geometry operations are based on a shared set of more generic and
   lower level maths functions. This common functionality is defined
   in this namespace, which is then imported by others whenever needed.
*** thi.ng.math.core
**** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/math/core.cljx
  (ns thi.ng.math.core)
#+END_SRC
**** Constants
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/math/core.cljx
  (def ^:const PI Math/PI)
  (def ^:const TWO_PI (* PI 2))
  (def ^:const HALF_PI (/ PI 2))
  (def ^:const THIRD_PI (/ PI 3))
  (def ^:const QUARTER_PI (/ PI 4))
  (def ^:const SIXTH_PI (/ PI 6))
  (def ^:const THREE_HALVES_PI (* PI 1.5))

  (def ^:const MAX 1.7976931348623157E308)
  (def ^:const MIN 4.9E-324)

  (def ^:const SQRT2 (Math/sqrt 2))
  (def ^:const SQRT3 (Math/sqrt 3))
  (def ^:const PHI (/ (inc (Math/sqrt 5.0)) 2))

  (def ^:const THIRD (/ 1.0 3.0))

  (def ^:const LOG2 (Math/log 2.0))

  (def ^:const DEG (/ 180.0 PI))
  (def ^:const RAD (/ PI 180.0))
#+END_SRC
***** Dynamic \epsilon (epsilon) config
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/math/core.cljx
  (def ^:dynamic *eps* 1e-6)
#+END_SRC
***** Dynamic PRNG
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/math/core.cljx
  ^:clj  (def ^:dynamic *rnd* (java.util.Random.))
  ^:cljs (def ^:dynamic *rnd* Math/random)
#+END_SRC
**** Functions
***** Basics
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/math/core.cljx
  (defn ensure-even
    "Returns `x` if even or `x+1` if `x` is odd."
    [x] (if (even? x) x (inc x)))

  (defn ensure-odd
    "Returns `x` if odd or `x+1` if `x` is even."
    [x] (if (even? x) (inc x) x))

  (defn fma
    [a b c] (+ (* a b) c))

  (defn abs
    [x] (if (neg? x) (- x) x))

  (defn abs-diff
    [x y] (abs (- x y)))

  (defn delta=
    "Compares the absolute difference between a and b and returns true
         if less than delta."
    ([a b] (delta= a b *eps*))
    ([a b delta]
       (if (number? a)
         (if (number? b) (<= (abs (- b a)) delta) false)
         (every? true? (map #(delta= % %2 delta) a b)))))

  (defn signum
    ([x] (if (neg? x) -1 (if (zero? x) 0 1)))
    ([x delta]
       (if (delta= 0 x delta) 0
           (if (neg? x) -1 1))))
#+END_SRC
***** Intervals
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/math/core.cljx
(defn map-interval
  "Maps x from one interval into another. Intervals can be defined as vectors."
  ([x [minIn maxIn] [minOut maxOut]]
     (+ (* (- maxOut minOut) (/ (- x minIn) (- maxIn minIn))) minOut))
  ([x minIn maxIn minOut maxOut]
     (+ (* (- maxOut minOut) (/ (- x minIn) (- maxIn minIn))) minOut)))

(defn in-range?
  "Returns true if x >= min and x <= max."
  ([[min max] x]
     (and (>= x min) (<= x max)))
  ([min max x]
     (and (>= x min) (<= x max))))

(defn wrap-range
  ([x y] (let [x (rem x y)] (if (neg? x) (+ x y) x))))

(defn clamp
  [x min max] (if (< x min) min (if (> x max) max x)))

(defn clamp-normalized
  [x] (clamp x -1.0 1.0))
#+END_SRC
***** Interpolation
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/math/core.cljx
  (defn mix
    [a b t] (+ (* (- b a) t) a))

  (defn step
    [edge x] (if (< x edge) 0.0 1.0))

  (defn smoothstep
    [e0 e1 x]
    (let [t (clamp (/ (- x e0) (- e1 e0)) 0.0 1.0)]
      (* t (* t (- 3.0 (* 2.0 t))))))
#+END_SRC
***** Rounding
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/math/core.cljx
  ^:clj  (defn floor
           [x] (long (Math/floor x)))
  ^:cljs (defn floor
           [x] (Math/floor x))

  ^:clj  (defn ceil
           [x] (long (Math/ceil x)))
  ^:cljs (defn ceil
           [x] (Math/ceil x))

  (defn roundto
    [x prec] (* (floor (+ (/ x prec) 0.5)) prec))

  (defn ceil-pow2
    [x]
    (loop [pow2 1]
      (if (>= pow2 x) pow2 (recur (* pow2 2)))))

  ^:clj  (defn floor-pow2
           [x] (long (Math/pow 2 (long (/ (Math/log x) LOG2)))))

  ^:cljs (defn floor-pow2
           [x] (Math/pow 2 (int (/ (Math/log x) LOG2))))

  (defn trunc
    [x] (if (neg? x) (ceil x) (floor x)))

  (defn fract
    [x] (- x (Math/floor x)))

  (defn fdim
    [x y] (if (> x y) (- x y) 0))
#+END_SRC
***** Trigonometry
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/math/core.cljx
  (defn radians [x] (* x RAD))

  (defn degrees [x] (* x DEG))
#+END_SRC
***** Advanced
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/math/core.cljx
  (defn maxmag
    [x y]
    (let [ax (Math/abs x) ay (Math/abs y)]
      (cond
       (> ax ay) x
       (> ay ax) y
       :default x)))

  (defn minmag
    [x y]
    (let [ax (Math/abs x) ay (Math/abs y)]
      (cond
       (< ax ay) x
       (< ay ax) y
       :default x)))

  (defn ldexp
    [x k] (* x (Math/pow 2 (int k))))

  (defn remquo
    [x y]
    (let [k (/ x y)
          f (fract k)
          k (cond
             (= f 0.5) (if (even? (int k)) (int k) (ceil k))
             (< f 0.5) (floor k)
             :default (ceil k))]
      (- x (* k y))))

  (defn hypot
    [x y] (Math/sqrt (+ (* x x) (* y y))))

  (defn rootn
    [x y] (Math/pow x (/ 1.0 y)))

  (defn rsqrt
    [x] (/ 1.0 (Math/sqrt x)))

  (defn impulse
    [k t]
    (let [h (* k t)] (* h (Math/exp (- 1.0 h)))))
#+END_SRC
***** Statistics
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/math/core.cljx
  (defn percentile-index
    [n num]
    (dec
     (if (< n 100)
       (int (Math/round (fma (/ n 100.0) num 0.5)))
       num)))

  (defn percentile
    [n sorted]
    (->> sorted
         (count)
         (percentile-index n)
         (nth sorted))

  (defn quartile-index
    [n num] (percentile-index (* n 25) num))

  (defn quartile-range
    [n num]
    (let [a (quartile-index (dec n) num)
          b (quartile-index n num)]
      [a (if (= n 4) (inc b) b)]))

  (defn quartile
    "Takes a quartile index (1..4) and sorted seq of samples, returns set of items in quartile."
    [n sorted]
    (let [[a b] (quartile-range n (count sorted))]
      (->> sorted (drop a) (take (- b a)))))
#+END_SRC
****** References
******* http://en.wikipedia.org/wiki/Percentile
******* http://en.wikipedia.org/wiki/Quartile
***** Randomness
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/math/core.cljx
  ^:clj  (defn random
           ([] (.nextDouble *rnd*))
           ([max] (* (.nextDouble *rnd*) max))
           ([min max] (+ (* (.nextDouble *rnd*) (- max min)) min)))
  ^:cljs (defn random
           ([] (*rnd*))
           ([max] (* (*rnd*) max))
           ([min max] (+ (* (*rnd*) (- max min)) min)))

  ^:clj  (defn randnorm
           [] (dec (* (.nextDouble *rnd*) 2.0)))
  ^:cljs (defn randnorm
           [] (dec (* (*rnd*) 2.0)))
#+END_SRC
** Namespace: thi.ng.geom
   Providing an easy-to-use & easy-to-learn API for both common and
   advanced geometry operations is one of this project's main focal
   points. We attempt to realise this by defining all operations in
   the form of protocols which are then implemented by various core
   types.
*** thi.ng.geom.types
**** 2D types
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (ns thi.ng.geom.types)
#+END_SRC
***** Line
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Line2 [a b])
#+END_SRC
***** Triangle
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Triangle2 [a b c])
#+END_SRC
***** Ellipse
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Ellipse [o rx ry])
  (defrecord Circle [o r])
#+END_SRC
***** Rectangle
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Rect [p w h])
#+END_SRC
***** Polygon
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Polygon [points children])
#+END_SRC
***** Mesh
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Mesh2 [vertices normals fnormals vnormals edges faces attribs])
#+END_SRC
**** 3D types
***** Line
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Line3 [a b])
#+END_SRC
***** Plane
      A plane in cartesian 3D space can be defined as a point =p=
      lying on the plane and normal vector =n= standing perpendicular
      on the plane. The latter defines the plane's orientation in space.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Plane [p n])
#+END_SRC
***** Triangle
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Triangle3 [a b c])
#+END_SRC
***** AABB
      An Axis-aligned bounding box is defined as the cartesian volume
      between points =p= and =q=.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord AABB [p q])
#+END_SRC
***** Sphere
      Just like a circle in 2D, a 3D sphere is uniquely defined via
      its center point =o= and radius =r=.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Sphere [o r])
#+END_SRC
***** Mesh
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/types.cljx
  (defrecord Mesh3 [vertices normals fnormals vnormals edges faces attribs])
#+END_SRC
*** thi.ng.geom.core
    This namespace contains all basic vector operations and core
    protocols related to common higher level geometric operations.
**** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (ns thi.ng.geom.core
    (:require
     [thi.ng.math.core :as m]
     [thi.ng.geom.types :as types]))
#+END_SRC
**** Protocols
***** Spatial transform operations
      The position, size and orientation of spatial entities can
      usually be manipulated via the three basic operations: rotate,
      scale & translate. Other, more complex transformations can be
      achieved through combination and repetition of these.
****** IRotatable
       Rotation is always relative to the world origin. For 2D
       implementations, the rotation angle \theta (theta) is always
       interpreted clockwise and only the =rotate= method is
       implemented.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol IRotatable
    (rotate [this t])
    (rotate-x [this t])
    (rotate-y [this t])
    (rotate-z [this t])
    (rotate-axis [this a t]))
#+END_SRC
******* TODO Maybe rotate-x etc could be implemented to, but return a 3D entity instead?
****** IScalable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol IScalable
    (scale [this s])
    (scale-x [this x])
    (scale-y [this y])
    (scale-z [this z]))
#+END_SRC
****** ITranslatable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol ITranslatable
    (translate [this t])
    (translate-x [this x])
    (translate-y [this y])
    (translate-z [this z]))
#+END_SRC
***** Shape operations
****** IShape
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol IShape
    (bounds [this])
    (center [this] [this o])
    (centroid [this])
    (classify-point [this p]))
#+END_SRC
****** IShape2
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol IShape2
    (area [this])
    (bounding-circle [this])
    (circumference [this])
    (edges [this] [this res]))
#+END_SRC
****** IShape3
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol IShape3
    (bounding-sphere [this])
    (volume [this]))
#+END_SRC
****** IBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol IBoundary
    (closest-point [this p])
    (contains-point? [this p])
    (point-at [this t])
    (random-point-inside [this])
    (random-boundary-point [this])
    (sample-uniform [this dist]))
#+END_SRC
****** IPolygonizable
       Anything which can be turned into a 2D polygon will implement this
       protocol consisting of just this one function: =as-polygon=.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol IPolygonizable
    (as-polygon [this] [this res]
      "Transforms current entity into a Polygon instance"))
#+END_SRC
****** IMeshable
       Anything which can be turned into a 2D or 3D mesh will implement this
       protocol consisting of just this one function: =as-mesh=.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol IMeshable
    (as-mesh [this opts]
      "Transforms the current enitity into a Mesh instance"))
 #+END_SRC
****** IIntersectable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defprotocol IIntersectable
    (intersect-line [this l])
    (intersect-ray [this r]))
#+END_SRC
******* TODO What about shape/shape intersections
**** Vector operations
***** Constructors
      The library supports 2D, 3D & 4D vectors and represents them as
      standard Clojure vector types. To simplify vector construction
      in some cases, factory functions are provided which coerce
      arguments into vectors with these rules:

      | Input         | Behavior                       | Examples call              | Example result  |
      |---------------+--------------------------------+----------------------------+-----------------|
      | Vector or Seq | select first =n= elements      | =(vec2 [1.0 2.0 3.0 4.0])= | =[1.0 2.0]=     |
      |               |                                | =(vec4 '(1.0 2.0)=         | =[1 2 0.0 1.0]= |
      | Map           | select values of =:x :y :z :w= | =(vec2 {:x 1.0 :y 2.0})=   | =[1.0 2.0]=     |
      |               |                                | =(vec3 {:x 1.0 :y 2.0})=   | =[1.0 2.0 0.0]= |
      | Single number | set all vector components      | =(vec3 1.0)=               | =[1.0 1.0 1.0]= |

#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  ^:clj  (defn type-error
           [t x] (throw (IllegalArgumentException. (str "can't create " t " from " x))))
  ^:cljs (defn type-error
           [t x] (throw (Error. (str "can't create " t " from " x))))

  (defn vec2
    ([] [0.0 0.0])
    ([x] (cond
          (sequential? x) (if (= 2 (count x))
                            (if (vector? x) x (vec x))
                            [(nth x 0 0.0) (nth x 1 0.0)])
          (number? x) [x x]
          (map? x) [(get x :x 0.0) (get x :y 0.0)]
          :default (type-error "vec2" x)))
    ([x y] [x y]))

  (defn vec3
    ([] [0.0 0.0 0.0])
    ([x] (cond
          (sequential? x) (if (= 3 (count x))
                            (if (vector? x) x (vec x))
                            [(nth x 0 0.0) (nth x 1 0.0) (nth x 2 0.0)])
          (number? x) [x x x]
          (map? x) [(get x :x 0.0) (get x :y 0.0) (get x :z 0.0)]
          :default (type-error "vec3" x)))
    ([x y] [x y 0.0])
    ([x y z] [x y z]))

  (defn vec4
    ([] [0.0 0.0 0.0 1.0])
    ([x] (cond
          (sequential? x)
          (if (= 4 (count x))
            (if (vector? x) x (vec x))
            [(nth x 0 0.0) (nth x 1 0.0) (nth x 2 0.0) (nth x 3 1.0)])
          (number? x) [x x x 1.0]
          (map? x) [(get x :x 0.0) (get x :y 0.0) (get x :z 0.0) (get x :w 1.0)]
          :default (type-error "vec4" x)))
    ([x y] [x y 0.0 1.0])
    ([x y z] [x y z 1.0])
    ([x y z w] [x y z w]))

  (defn vec2? [x] (and (sequential? x) (>= (count x) 2)))
  (defn vec3? [x] (and (sequential? x) (>= (count x) 3)))
  (defn vec4? [x] (and (sequential? x) (>= (count x) 4)))
#+END_SRC
***** Vector algebra
****** Operation builders
       Basic vector algebra operations like addition, subtraction
       (both a translation), scaling and others are implemented using
       shared higher order functions to generate their
       implementations. Each operation expects an existing vector as
       first argument, but accepts a flexible number of other
       arguments with the following behaviors. The table only shows
       the 2D case, but the behavior extends for 3D & 4D as well (with
       additional args).

       | 2nd arg       | 3rd arg       | remaining args | Behavior                           | Example call                             | Result    |
       |---------------+---------------+----------------+------------------------------------+------------------------------------------+-----------|
       | V / M / S     | n/a           | n/a            | argument cast using =vec2=         | =(add2 [1 2] [10 20])=                   | =[11 22]= |
       |               |               |                |                                    | =(add2 [1 2] '(10 20 30))=               | =[11 22]= |
       |               |               |                |                                    | =(add2 [1 2] {:x 10})=                   | =[11 2]=  |
       | N             | n/a           | n/a            | argument cast using =vec2=         | =(add2 [1 2] 10)=                        | =[11 12]= |
       | N             | N             | n/a            | arguments interpreted as XY coords | =(add2 [1 2] 10 20)=                     | =[11 22]= |
       | V / M / S     | V / M / S     | n/a            | each argument cast using =vec2=    | =(add2 [1 2] '(10 20) {:x 30 :y 40})=    | =[41 62]= |
       | V / M / S / N | V / M / S / N | V / M / S / N  | each argument cast using =vec2=    | =(add2 [1 2] 10 '(20 30) {:x 40 :y 50})= | =[71 92]= |

       *Table legend:* *(N)*umber, *(M)*ap, *(S)*eq, *(V)*ector

#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defn- vecop2
    [f]
    (fn
      ([v w]
         (let [w (vec2 w)]
           [(f (nth v 0) (w 0)) (f (nth v 1) (w 1))]))
      ([v x y]
         (if (number? x)
           [(f (nth v 0) x) (f (nth v 1) y)]
           (let [x (vec2 x) y (vec2 y)]
             [(f (f (nth v 0) (x 0)) (y 0))
              (f (f (nth v 1) (x 1)) (y 1))])))
      ([a b c & more]
         (vec2 (apply map f (map vec2 (concat [a b c] more)))))))

  (defn- vecop3
    [f]
    (fn
      ([v w]
         (let [w (vec3 w)]
           [(f (nth v 0) (w 0)) (f (nth v 1) (w 1)) (f (nth v 2) (w 2))]))
      ([v x y z]
         (if (number? x)
           [(f (nth v 0) x) (f (nth v 1) y) (f (nth v 2) z)]
           (let [x (vec3 x) y (vec3 y) z (vec3 z)]
             [(f (f (f (nth v 0) (x 0)) (y 0)) (z 0))
              (f (f (f (nth v 1) (x 1)) (y 1)) (z 1))
              (f (f (f (nth v 2) (x 2)) (y 2)) (z 2))])))
      ([a b c d & more]
         (vec3 (apply map f (map vec3 (concat [a b c d] more)))))))

  (defn- vecop4
    [f]
    (fn
      ([v w]
         (let [w (vec4 w)]
           [(f (nth v 0) (w 0)) (f (nth v 1) (w 1)) (f (nth v 2) (w 2)) (f (nth v 3) (w 3))]))
      ([v x y z w]
         (if (number? x)
           [(f (nth v 0) x) (f (nth v 1) y) (f (nth v 2) z) (f (nth v 3) w)]
           (let [x (vec4 x) y (vec4 y) z (vec4 z) w (vec4 w)]
             [(f (f (f (f (nth v 0) (x 0)) (y 0)) (z 0)) (w 0))
              (f (f (f (f (nth v 1) (x 1)) (y 1)) (z 1)) (w 1))
              (f (f (f (f (nth v 2) (x 2)) (y 2)) (z 2)) (w 2))
              (f (f (f (f (nth v 3) (x 3)) (y 3)) (z 3)) (w 3))])))
      ([a b c d e & more]
         (vec4 (apply map f (map vec4 (concat [a b c d e] more)))))))
#+END_SRC
****** Implementation
       With these function generators in place, we can implement
       various algebra operators like this:
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (def add2   (vecop2 +))
  (def sub2   (vecop2 -))
  (def scale2 (vecop2 *))

  (def add3   (vecop3 +))
  (def sub3   (vecop3 -))
  (def scale3 (vecop3 *))

  (def add4   (vecop4 +))
  (def sub4   (vecop4 -))
  (def scale4 (vecop4 *))

  (defn fma2 [a b c] (add2 (scale2 a b) c))
  (defn fma3 [a b c] (add3 (scale3 a b) c))
  (defn fma4 [a b c] (add4 (scale4 a b) c))
#+END_SRC
****** Absolute vectors & inversion
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defn abs2 [[x y]] [(m/abs x) (m/abs y)])
  (defn abs3 [[x y z]] [(m/abs x) (m/abs y) (m/abs z)])
  (defn abs4 [[x y z w]] [(m/abs x) (m/abs y) (m/abs z) (m/abs w)])

  (defn invert2 [[x y]] [(- x) (- y)])
  (defn invert3 [[x y z]] [(- x) (- y) (- z)])
  (defn invert4 [[x y z w]] [(- x) (- y) (- z) (- w)])
#+END_SRC
****** Magnitude & distance calculations
      All of the following operations can operate both on arguments
      given as vector or individual vector coordinates.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defn mag2-squared
    ([[x y]] (+ (* x x) (* y y)))
    ([x y] (+ (* x x) (* y y))))

  (defn mag3-squared
    ([[x y z]] (+ (+ (* x x) (* y y)) (* z z)))
    ([x y z] (+ (+ (* x x) (* y y)) (* z z))))

  (defn mag4-squared
    ([[x y z w]] (+ (+ (+ (* x x) (* y y)) (* z z)) (* w w)))
    ([x y z w] (+ (+ (+ (* x x) (* y y)) (* z z)) (* w w))))

  (defn mag2
    ([v] (Math/sqrt (mag2-squared v)))
    ([x y] (Math/sqrt (mag2-squared x y))))

  (defn mag3
    ([v] (Math/sqrt (mag3-squared v)))
    ([x y z] (Math/sqrt (mag3-squared x y z))))

  (defn mag4
    ([v] (Math/sqrt (mag4-squared v)))
    ([x y z w] (Math/sqrt (mag3-squared x y z w))))

  (defn dist2
    ([p q] (mag2 (sub2 p q)))
    ([px py qx qy] (mag2 (- px qx) (- py qy))))

  (defn dist3
    ([p q] (mag3 (sub3 p q)))
    ([px py pz qx qy qz] (mag3 (- px qx) (- py qy) (- pz qz))))

  (defn dist4
    ([p q] (mag4 (sub4 p q)))
    ([px py pz pw qx qy qz qw] (mag4 (- px qx) (- py qy) (- pz qz) (- pw qw))))

  (defn dist2-squared
    ([p q] (mag2-squared (sub2 p q)))
    ([px py qx qy] (mag2-squared (- px qx) (- py qy))))

  (defn dist3-squared
    ([p q] (mag3-squared (sub3 p q)))
    ([px py pz qx qy qz] (mag3-squared (- px qx) (- py qy) (- pz qz))))

  (defn dist4-squared
    ([p q] (mag4-squared (sub4 p q)))
    ([px py pz pw qx qy qz qw] (mag4-squared (- px qx) (- py qy) (- pz qz) (- pw qw))))
#+END_SRC
****** Normalization & limitation
       All =normalize= functions take an optional argument to normalize
       a vector to a given length, rather than the default length of
       1.0. The =limit= functions constrain a vector to a given maximum
       length. The =min= / =max= functions constrain a vector on a
       component basis and are implemented using the HOF
       [[Operation builders][function builders]] defined earlier.

#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defn normalize2
    ([[x y :as p]]
       (let [m (mag2 p)]
         (if (pos? m) [(/ x m) (/ y m)] p)))
    ([[x y :as p] n]
       (let [m (mag2 p)]
         (if (pos? m) (let [m (/ n m)] [(* x m) (* y m)]) p))))

  (defn normalize3
    ([[x y z :as p]]
       (let [m (mag3 p)]
         (if (pos? m) [(/ x m) (/ y m) (/ z m)] p)))
    ([[x y z :as p] n]
       (let [m (mag3 p)]
         (if (pos? m) (let [m (/ n m)] [(* x m) (* y m) (* z m)]) p))))

  (defn normalize4
    ([[x y z w :as p]]
       (let [m (mag4 p)]
         (if (pos? m) [(/ x m) (/ y m) (/ z m) (/ w m)] p)))
    ([[x y z w :as p] n]
       (let [m (mag4 p)]
         (if (pos? m) (let [m (/ n m)] [(* x m) (* y m) (* z m) (* w m)]) p))))

  (defn limit2
    [v len]
    (if (> (mag2-squared v) (* len len)) (normalize2 v len) v))

  (defn limit3
    [v len]
    (if (> (mag3-squared v) (* len len)) (normalize3 v len) v))

  (defn limit4
    [v len]
    (if (> (mag4-squared v) (* len len)) (normalize4 v len) v))

  (def min2 (vecop2 min))
  (def max2 (vecop2 max))

  (def min3 (vecop3 min))
  (def max3 (vecop3 max))

  (def min4 (vecop4 min))
  (def max4 (vecop4 max))
#+END_SRC
****** Cross product & dot product
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defn cross2
    [[px py] [qx qy]] (- (* px qy) (* py qx)))

  (defn cross3
    [[px py pz] [qx qy qz]]
    [(- (* py qz) (* qy pz)) (- (* pz qx) (* qz px)) (- (* px qy) (* qx py))])

  (defn dot2
    ([[px py] [qx qy]] (+ (* px qx) (* py qy)))
    ([px py qx qy] (+ (* px qx) (* py qy))))

  (defn dot3
    ([[px py pz] [qx qy qz]] (+ (+ (* px qx) (* py qy)) (* pz qz)))
    ([px py pz qx qy qz] (+ (+ (* px qx) (* py qy)) (* pz qz))))

  (defn dot4
    ([[px py pz pw] [qx qy qz qw]] (+ (+ (+ (* px qx) (* py qy)) (* pz qz)) (* pw qw)))
    ([px py pz pw qx qy qz qw] (+ (+ (+ (* px qx) (* py qy)) (* pz qz)) (* pw qw))))
#+END_SRC

****** Interpolation
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defn mid2
    [[px py] [qx qy]] [(* 0.5 (+ px qx)) (* 0.5 (+ py qy))])

  (defn mid3
    [[px py pz] [qx qy qz]]
    [(* 0.5 (+ px qx)) (* 0.5 (+ py qy)) (* 0.5 (+ pz qz))])

  (defn mid4
    [[px py pz pw] [qx qy qz qw]]
    [(* 0.5 (+ px qx)) (* 0.5 (+ py qy)) (* 0.5 (+ pz qz)) (* 0.5 (+ pw qw))])

  (defn mix2
    ([[px py] [qx qy] t] [(m/mix px qx t) (m/mix py qy t)])
    ([px py qx qy t] [(m/mix px qx t) (m/mix py qy t)]))

  (defn mix3
    ([[px py pz] [qx qy qz] t]
       [(m/mix px qx t) (m/mix py qy t) (m/mix pz qz t)])
    ([px py pz qx qy qz t]
       [(m/mix px qx t) (m/mix py qy t) (m/mix pz qz t)]))

  (defn mix4
    ([[px py pz pw] [qx qy qz qw] t]
       [(m/mix px qx t) (m/mix py qy t) (m/mix pz qz t) (m/mix pw qw t)])
    ([px py pz pw qx qy qz qw t]
       [(m/mix px qx t) (m/mix py qy t) (m/mix pz qz t) (m/mix pw qw t)]))
#+END_SRC
****** Random vectors
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defn randvec2
    ([] (normalize2 [(m/randnorm) (m/randnorm)]))
    ([n] (normalize2 [(m/randnorm) (m/randnorm)] n)))

  (defn randvec3
    ([] (normalize3 [(m/randnorm) (m/randnorm) (m/randnorm)]))
    ([n] (normalize3 [(m/randnorm) (m/randnorm) (m/randnorm)] n)))

  (defn randvec4
    ([] (normalize4 [(m/randnorm) (m/randnorm) (m/randnorm) (m/randnorm)]))
    ([n] (normalize4 [(m/randnorm) (m/randnorm) (m/randnorm) (m/randnorm)] n)))
#+END_SRC
****** Angles, heading, reflection
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defn perpendicular2
    [[x y]] [(- y) x])

  (defn heading2
    [[x y]]
    (let [t (Math/atan2 y x)]
      (if (neg? t) (+ m/TWO_PI t) t)))

  (defn slope2
    [[x y]] (/ y x))

  (defn angle-between2
    [p q]
    (let [t (- (heading2 q) (heading2 p))]
      (if (neg? t) (+ m/TWO_PI t) t)))

  (defn reflect2
    [[x y :as v] [rx ry :as r]]
    (let [d (* (dot2 v r) 2.0)]
      [(- (* rx d) x) (- (* ry d) y)]))

  (defn reflect3
    [[x y z :as v] [rx ry rz :as r]]
    (let [d (* (dot3 v r) 2.0)]
      [(- (* rx d) x) (- (* ry d) y) (- (* rz d) z)]))
#+END_SRC
****** Polar & spherical coordinates
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core.cljx
  (defn polar2
    [v] [(mag2 v) (heading2 v)])

  (defn cartesian2
    [[r t]] [(* r (Math/cos t)) (* r (Math/sin t))])

  (defn cartesian3
    [[x y z]]
    (let [a (* x (Math/cos z))]
      [(* a (Math/cos y)) (* x (Math/sin z)) (* a (Math/sin y))]))

  (defn spherical3
    [[x y z]]
    (let [xx (if (m/delta= 0.0 (m/abs x))
               (if (< x 0.0) (- m/*eps*) m/*eps*) x)
          m (mag3 xx y z)
          yy (+ (Math/atan (/ z xx)) (if (< xx 0.0) m/PI 0))
          zz (Math/asin (/ y m))]
      [m yy zz]))
#+END_SRC
*** thi.ng.geom.bezier
**** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/bezier.cljx
  (ns thi.ng.geom.bezier
    (:require
     [thi.ng.math.core :as m]
     [thi.ng.geom.core :as g]))
#+END_SRC
**** The Bernstein polynomial
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/bezier.cljx
(defn bernstein
  [t]
  (let [it (- 1.0 t) it2 (* it it) t2 (* t t)]
    [(* it it2) (* 3 (* t it2)) (* 3 (* it t2)) (* t t2)]))
#+END_SRC
**** Interpolation & curve samplings
     Applied to calculate a single point on a bezier patch, sample a patch
     at a fixed resolution and sample a continous curve from a seq of
     control points... =interpolate*= and =as-linestrip*= are
     implemented as HOF to support both 2D/3D cases. Further below
     we'll provide pre-configured implementations for each.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/bezier.cljx
  (defn interpolate*
    [afn sfn]
    (fn [[a b c d] t]
      (let [[ta tb tc td] (bernstein t)]
        (-> a
            (sfn ta)
            (afn (sfn b tb))
            (afn (sfn c tc))
            (afn (sfn d td)  )))))

  (defn sample-segment
    [interpolate seg res]
    (for [t (range 0.0 1.0 (/ 1.0 res))]
      (interpolate seg   t)))

  (defn as-linestrip*
    [interpolate]
    (fn [res include-last? points]
      (let [ls (->> points
                    (d/successive-nth 4)
                    (take-nth 3)
                    (mapcat #(sample-segment interpolate % res)))]
        (if include-last?
          (concat ls [(last points)])
          ls))))
#+END_SRC
**** Automatic curve generation
     The following two functions allow us to compute a bezier curve
     which passes through all given points and automatically computes
     the required control points.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/bezier.cljx
(defn find-cpoints*
  [make-vec sub scale fma]
  (fn [tight points]
    (let [np (count points)
          invt (/ 1.0 tight)
          points (vec points)
          c1 (scale (sub (get points 2) (first points)) tight)
          [bi coeff] (reduce
                      (fn [[bi coeff] i]
                        (let [b (/ -1.0 (+ invt (peek bi)))
                              c (peek coeff)
                              p (get points (dec i))
                              q (get points (inc i))]
                          [(conj bi b)
                           (conj coeff (scale (sub q p c) (- b)))]))
                      [[0 (- tight)] [(make-vec) c1]]
                      (range 2 (dec np)))]
      (reduce
       (fn [delta i]
         (assoc delta i (fma (delta (inc i)) (bi i) (coeff i))))
       (vec (repeatedly np make-vec))
       (range (- np 2) 0 -1)))))

(defn auto-spline*
  [find-cpoints add sub]
  (fn [tight points]
    (concat
     (->> points
          (find-cpoints tight)
          (d/successive-nth 2)
          (interleave (d/successive-nth 2 points))
          (partition 2)
          (mapcat (fn [[[p q] [dp dq]]] [p (add p dp) (sub q dq)])))
     [(last points)])))
#+END_SRC
**** Concrete implementations for 2D/3D...
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/bezier.cljx
(def interpolate2 (interpolate* g/add2 g/scale2))
(def interpolate3 (interpolate* g/add3 g/scale3))

(def as-linestrip2 (as-linestrip* interpolate2))
(def as-linestrip3 (as-linestrip* interpolate3))

(def find-cpoints2 (find-cpoints* g/vec2 g/sub2 g/scale2 g/fma2))
(def find-cpoints3 (find-cpoints* g/vec3 g/sub3 g/scale3 g/fma3))

(def auto-spline2 (auto-spline* find-cpoints2 g/add2 g/sub2))
(def auto-spline3 (auto-spline* find-cpoints3 g/add3 g/sub3))
#+END_SRC
*** thi.ng.geom.circle
**** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/circle.cljx
  (ns thi.ng.geom.circle
    (:require
     [thi.ng.math.core :as m]
     [thi.ng.geom.core :as g]
     [thi.ng.geom.types :as types]))
#+END_SRC
**** Protocol implementations
*** thi.ng.geom.line
**** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  (ns thi.ng.geom.line
    (:require
     [thi.ng.math.core :as m]
     [thi.ng.geom.core :as g]
     [thi.ng.geom.types :as types]))
#+END_SRC
**** Protocol implementations
*** thi.ng.geom.rect
**** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  (ns thi.ng.geom.rect
    (:require
     [thi.ng.math.core :as m]
     [thi.ng.geom.core :as g]
     [thi.ng.geom.types :as types]))
#+END_SRC
**** Protocol implementations
*** thi.ng.geom.polygon
**** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/polygon.cljx
  (ns thi.ng.geom.polygon
    (:require
     [thi.ng.math.core :as m]
     [thi.ng.geom.core :as g]
     [thi.ng.geom.types :as types]))
#+END_SRC
**** Protocol implementations
*** thi.ng.geom.triangle
**** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  (ns thi.ng.geom.triangle
    (:require
     [thi.ng.math.core :as m]
     [thi.ng.geom.core :as g]
     [thi.ng.geom.types :as types]))
#+END_SRC
**** Protocol implementations
*** thi.ng.geom.macros
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/macros.cljx
  (ns thi.ng.geom.macros)

  (defmacro op2
    [f cast]
    `(fn
       ([v# w#] (let [w# (~cast w#)] [(~f (nth v# 0) (w# 0)) (~f (nth v# 1) (w# 1))]))
       ([v# x# y#] [(~f (nth v# 0) x#) (~f (nth v# 1) y#)])
       ([a# b# c# & more#] (~cast (apply map ~f a# b# c# more#)))))
#+END_SRC

*** thi.ng.geom.app
**** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/app.cljx
  (ns thi.ng.geom.app
    (:require
     [thi.ng.math.core :as m]
     [thi.ng.geom.core :as g]
     [thi.ng.geom.types :as types]))

  (defn ^:export -main
    [] (.log js/console (clj->js (types/map->Circle {:o [0 0] :r 100}))))
#+END_SRC
