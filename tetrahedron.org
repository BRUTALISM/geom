#+SEQ_TODO:       TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:           Write(w) Update(u) Fix(f) Check(c) noexport(n)
#+EXPORT_EXCLUDE_TAGS: noexport

* thi.ng.geom.tetrahedron
** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/tetrahedron.cljx :mkdirp yes :padline no
  (ns thi.ng.geom.tetrahedron
    (:require
     [thi.ng.common.data.core :as d]
     [thi.ng.common.error :as err]
     [thi.ng.common.math.core :as m :refer [PI HALF_PI THIRD SQRT3 *eps*]]
     [thi.ng.geom.core :as g :refer [vec3]]
     [thi.ng.geom.triangle :as t]
     [thi.ng.geom.mesh :as mesh]
     [thi.ng.geom.types :as types])
    ,#+clj
    (:import
     [thi.ng.geom.types Line3 Triangle3]))
#+END_SRC
** Typespecific functions
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/tetrahedron.cljx
  (defn- subdot
    "Computes sum((a-b)*c), where a, b, c are 3D vectors."
    [a b c]
    (let [d (g/* (g/- a b) c)] (+ (+ (d 0) (d 1)) (d 2))))
  
  (defn- compute-mask
    "Computes bit mask for given seq of 4 affine coords."
    [affine]
    (loop [m 0, i [1 2 4 8], a affine]
      (if i
        (recur (if (pos? (first a)) (bit-or m (first i)) m) (next i) (next a))
        m)))
  
  (defn- face-a
    "Takes a transformation fn and the 4 delta vectors between tetra1/tetra2.
    Returns 2-elem vec of [bitmask affine-coords]."
    [f deltas]
    (let [affine (mapv f deltas)] [(compute-mask affine) affine]))
  
  (defn- face-b1?
    "Takes the 4 delta vectors between tetra2/tetra1 and a normal.
    Returns true if all dot products are positive."
    [deltas n] (every? #(pos? (g/dot % n)) deltas))
  
  (defn- face-b2?
    "Like face-b1?, but optimized for last face of tetrahedron."
    [verts refv n] (every? #(pos? (subdot % refv n)) verts))
  
  (defn- edge-a
    "Takes 2 bitmasks and edge flags, returns true if there's a
    separating plane between the faces shared by that edge."
    [ma mb ea eb]
    (let [xa (bit-and ma (bit-xor ma mb))
          xb (bit-and mb (bit-xor xa mb))
          edge (fn [a b i j]
                 (let [cp (- (* (ea i) (eb j)) (* (ea j) (eb i)))]
                   (or (and (pos? cp) (pos? (bit-or xa a)) (pos? (bit-or xb b)))
                       (and (neg? cp) (pos? (bit-or xa b)) (pos? (bit-or xb a))))))]
      (not
       (or
        (not= 15 (bit-or ma mb))
        (edge 1 2 1 0)
        (edge 1 4 2 0)
        (edge 1 8 3 0)
        (edge 2 4 2 1)
        (edge 2 8 3 1)
        (edge 4 8 3 2)))))
  
  (defn- get-edge
    "Lazy edge evaluation. Takes a vector of edges, vector of edge
    points and an edge id. Looks up edge for given id and if not yet
    present constructs it. Returns 2-elem vector of [edges edge]."
    [edges epoints id]
    (let [e (edges id)]
      (if e
        [edges e]
        (let [ep (epoints id), e (g/- (ep 0) (ep 1))]
          [(assoc edges id e) e]))))
  
  (defn- check-faces-a
    "Takes the 4 delta vectors between the two tetras, edge definitions
    of the 1st tetra, vertices of the 2nd, a reference point of the 1st
    and a seq of specs, each encoding a specific check (either calls to
    face-a* or edge-a). Returns 2-elem vector of bitmasks and affine
    coords."
    [deltas epoints verts p specs]
    (loop [masks [], affine [], edges [nil nil nil nil nil], s specs]
      (if s
        (let [[f a b] (first s)]
          (if (or (= :f f) (= :f* f))
            (let [[edges ea] (get-edge edges epoints a)
                  [edges eb] (get-edge edges epoints b)
                  n (g/cross ea eb)
                  [m a] (if (= :f f)
                          (face-a #(g/dot % n) deltas)
                          (face-a #(subdot % p n) verts))]
              (if (= 15 m)
                false
                (recur (conj masks m) (conj affine a) edges (next s))))
            (if (edge-a (masks a) (masks b) (affine a) (affine b))
              false
              (recur masks affine edges (next s)))))
        masks)))
  
  (defn- check-faces-b
    "Much like check-faces-a, but for 2nd tetra and specs encoding calls to face-b1/2?.
    Returns true if tetras do intersect."
    [deltas epoints verts p specs]
    (loop [edges [nil nil nil nil nil], s specs]
      (if s
        (let [[f a b] (first s)
              [edges ea] (get-edge edges epoints a)
              [edges eb] (get-edge edges epoints b)]
          (if (if (= :f f)
                (face-b1? deltas (g/cross ea eb))
                (face-b2? verts p (g/cross ea eb)))
            false
            (recur edges (next s))))
        true)))
  
  (defn orient-tetra
    "Takes a seq of 4 3D points, returns them as vector in the order so
    that the last point is on the opposite side of the plane defined by
    the first three points."
    [[a b c d :as t]]
    (let [dp (-> d (g/- a) (g/normalize) (g/dot (g/normal3* a b c)))]
      (if (neg? dp) (vec t) [a c b d])))
  
  (defn intersect-tetrahedra?
    "Takes 2 seqs of 4 3D points, each defining a tetrahedron. Returns
    true if they intersect. Orientation of points is irrelevant (unlike
    in the original algorithm this implementation is based on)."
    [p q]
    (let [[pa pb pc pd :as p] (orient-tetra p)
          [qa qb qc qd :as q] (orient-tetra q)
          masks (check-faces-a
                 (map #(g/- % pa) q)
                 [[pb pa] [pc pa] [pd pa] [pc pb] [pd pb]]
                 q pb [[:f 0 1] [:f 2 0] [:e 0 1] [:f 1 2]
                       [:e 0 2] [:e 1 2] [:f* 4 3] [:e 0 3]
                       [:e 1 3] [:e 2 3]])]
      (cond
       (false? masks) false
       (not= 15 (apply bit-or masks)) true
       :else
       (check-faces-b
        (map #(g/- % qa) p)
        [[qb qa] [qc qa] [qd qa] [qc qb] [qd qb]]
        p qa [[:f 0 1] [:f 2 0] [:f 1 2] [:f* 4 3]]))))
#+END_SRC
** Constructors
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/tetrahedron.cljx
  (defn tetrahedron
    ([points]
       (let [[a b c d] (orient-tetra (map g/vec3 points))]
         (thi.ng.geom.types.Tetrahedron. a b c d)))
    ([a b c d] (tetrahedron [a b c d])))  
#+END_SRC
** Protocol implementations
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/tetrahedron.cljx
  (extend-type thi.ng.geom.types.Tetrahedron
#+END_SRC
**** PGraph
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/tetrahedron.cljx
  g/PGraph
  (vertices
   [_] [(:a _) (:b _) (:c _) (:d _)])
  (edges
   [{a :a b :b c :c d :d}]
   (map #(thi.ng.geom.types.Line3. % %2) [a b c a b c] [b c a d d d]))
  (vertex-neighbors
   [{a :a b :b c :c d :d} v]
   (condp = (vec3 v)
     a [c b d]
     b [a c d]
     c [b a d]
     d [a b c]
     nil))
  (vertex-valence
   [_ v] (if (#{(:a _) (:b _) (:c _) (:d _)} (vec3 v)) 3 0))
#+END_SRC
**** PArea
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/tetrahedron.cljx
  g/PArea
  (area
   [{a :a b :b c :c d :d}]
   (->> [[a b c] [a b d] [b c d] [c a d]]
        (map (comp m/abs t/area3))
        (reduce +)))
#+END_SRC
**** PBounds
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/tetrahedron.cljx
  g/PBounds
  (bounds [_] (g/bounding-box* (g/vertices _)))
  (width [_] (g/axis-range* 0 (g/vertices _)))
  (height [_] (g/axis-range* 1 (g/vertices _)))
  (depth [_] (g/axis-range* 2 (g/vertices _)))
#+END_SRC
**** PCenter
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/tetrahedron.cljx
  g/PCenter
  (center
   ([_]
      (let [ct (g/centroid _)]
        (thi.ng.geom.types.Tetrahedron.
         (g/- (:a _) ct) (g/- (:b _) ct) (g/- (:c _) ct) (g/- (:d _) ct))))
   ([_ o]
      (let [ct (g/- o (g/centroid _))]
        (thi.ng.geom.types.Tetrahedron.
         (g/+ (:a _) ct) (g/+ (:b _) ct) (g/+ (:c _) ct) (g/+ (:d _) ct)))))
  (centroid [_] (g/centroid* (g/vertices _)))
#+END_SRC
**** PBoundingSphere
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/tetrahedron.cljx
  g/PBoundingSphere
  (bounding-sphere
   [_] (g/bounding-sphere* (g/centroid _) (g/vertices _)))
#+END_SRC
**** TODO PVolume
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/tetrahedron.cljx
  g/PVolume
  (volume [_] nil)
#+END_SRC
**** TODO PBoundary
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/tetrahedron.cljx
  g/PClassify
  (classify-point [_ p] nil) ; TODO
  g/PProximity
  (closest-point [_ p] nil) ; TODO
  g/PBoundary
  (contains-point? [_ p] nil) ; TODO
#+END_SRC
**** TODO PSample
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/tetrahedron.cljx
  g/PSample
  (point-at [_ t] nil) ; TODO
  (random-point
   [_] (g/point-at _ (m/random)))
  (random-point-inside
   [t]
   (let [b1 (m/random)
         b2 (m/random (- 1.0 b1))
         b3 (- 1.0 (+ b1 b2))]
     (g/from-barycentric*
      [(:a t) (:b t) (:c t)] (shuffle [b1 b2 b3]))))
#+END_SRC
**** TODO PIntersect
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/tetrahedron.cljx
  g/PIntersect
  (intersect-shape
   [_ s]
   (cond
    (instance? thi.ng.geom.types.Tetrahedron s)
    (intersect-tetrahedra? (g/vertices _) (g/vertices s))
    (and (sequential? s) (= 4 (count s)))
    (intersect-tetrahedra? (g/vertices _) s)
    :default (err/type-error! "Tetrahedron" s)))
  (intersect-line
   [_ l] nil)
  (intersect-ray
   [_ {p :p dir :dir}] nil)
#+END_SRC
**** PInvert
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/tetrahedron.cljx
  g/PInvert
  (invert
   [_] (thi.ng.geom.types.Tetrahedron. (:b _) (:a _) (:c _) (:d _)))
#+END_SRC
**** TODO PSlice
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/tetrahedron.cljx
  g/PSlice
  (slice-with
   ([_ e] nil)
   ([_ e classifier] nil))
#+END_SRC
**** PTessellate
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/tetrahedron.cljx
  g/PTessellate
  (tessellate
   [{a :a b :b c :c d :d}]
   (map
    (fn [[a b c]] (thi.ng.geom.types.Triangle3. a b c))
    [[a b c] [a d b] [b d c] [c d a]]))
#+END_SRC
**** PTransform
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/tetrahedron.cljx
  g/PScale
  (scale
   ([_ s]
      (thi.ng.geom.types.Tetrahedron.
       (g/* (:a _) s) (g/* (:b _) s) (g/* (:c _) s) (g/* (:d _) s)))
   ([_ a b]
      (thi.ng.geom.types.Tetrahedron.
       (g/* (:a _) a b) (g/* (:b _) a b) (g/* (:c _) a b) (g/* (:d _) a b))))
  (scale-size
   [{a :a b :b c :c d :d :as _} s]
   (let [cc (g/centroid _)]
     (thi.ng.geom.types.Tetrahedron.
      (-> a (g/- cc) (g/madd s cc)) (-> b (g/- cc) (g/madd s cc))
      (-> c (g/- cc) (g/madd s cc)) (-> d (g/- cc) (g/madd s cc)))))
#+END_SRC
**** End of implementations                                        :noexport:
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/tetrahedron.cljx
  )
#+END_SRC

