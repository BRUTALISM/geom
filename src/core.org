#+SETUPFILE: setup.org

* Namespace: thi.ng.geom.core
Providing an easy-to-use & easy-to-learn API for both common and
advanced geometry operations is one of this project's main focal
points. We attempt to realise this by defining all operations in
the form of protocols which are then implemented by various core
types.

This namespace contains all basic vector operations and core
protocols related to common higher level geometric operations.

#+INCLUDE: "types.org" :minlevel 3

** Namespace declaration                                           :noexport:
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx :mkdirp yes :padline no
  (ns thi.ng.geom.core
    (:refer-clojure :exclude [+ - * / min max])
    (:require
     [thi.ng.common.data.core :as d]
     [thi.ng.common.error :as err]
     [thi.ng.common.math.core :as m :refer [*eps* PI TWO_PI]]
     [thi.ng.geom.types :as types]
     ,#+clj [thi.ng.macromath.core :as mm]
     ,#+clj [thi.ng.geom.macros.core :as gmc])
    ,#+cljs
    (:require-macros
     [thi.ng.macromath.core :as mm]
     [thi.ng.geom.macros.core :as gmc])
    ,#+clj
    (:import
     [thi.ng.geom.types Circle Rect AABB Sphere]))
#+END_SRC

** Protocols
*** Math operations
**** PMathOps
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PMathOps
    (+ [_] [_ a] [_ a b] [_ a b c])
    (- [_] [_ a] [_ a b] [_ a b c])
    (* [_] [_ a] [_ a b] [_ a b c])
    (div [_] [_ a] [_ a b] [_ a b c])
    (madd [_ a b])
    (addm [_ a b])
    (abs [_]))
#+END_SRC
**** PConjugate
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PConjugate
    (conjugate [_]))
#+END_SRC
**** PCrossProduct
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PCrossProduct
    (cross [_ a]))
#+END_SRC
**** PDeterminant
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PDeterminant
    (determinant [_]))
#+END_SRC
**** PDistance
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PDistance
    (dist [_ a])
    (dist-squared [_ a]))
#+END_SRC
**** PDotProduct
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PDotProduct
    (dot [_ a]))
#+END_SRC
**** PHeading
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PHeading
    (heading [_])
    (heading-xy [_])
    (heading-xz [_])
    (heading-yz [_])
    (angle-between [_ a])
    (normal [_] [_ a])
    (slope-xy [_])
    (slope-xz [_])
    (slope-yz [_]))
#+END_SRC
**** PInterpolate
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PInterpolate
    (mix [_ x] [_ x t]))
#+END_SRC
**** PInvert
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PInvert
    (invert [_]))
#+END_SRC
**** PSetOps
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PSetOps
    (union [_ x])
    (intersection [_ y])
    (difference [_ x]))
#+END_SRC
**** PLimit
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PLimit
    (limit [_ x]))
#+END_SRC
**** PMagnitude
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PMagnitude
    (mag [_])
    (mag-squared [_]))
#+END_SRC
**** PMatrixConvert
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PMatrixConvert
    (as-matrix [_]))
#+END_SRC
**** PMinMax
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PMinMax
    (min [_ x] [_ a b])
    (max [_ y] [_ a b]))
#+END_SRC
**** PNormalize
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PNormalize
    (normalize [_] [_ len])
    (normalized? [_]))
#+END_SRC
**** PTranspose
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PTranspose
    (transpose [_]))
#+END_SRC
*** Spatial transform operations

The position, size and orientation of spatial entities can
usually be manipulated via the three basic operations: rotate,
scale & translate. Other, more complex transformations can be
achieved through combination and repetition of these.

**** PPolar
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PPolar
    (as-polar [_])
    (as-cartesian [_]))
#+END_SRC
**** PReflect
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PReflect
    (reflect [_ r]))
#+END_SRC
**** PRotate & PRotate3D
  Rotation is always relative to the world origin. For 2D
  implementations, the rotation angle \theta (theta) is always
  interpreted clockwise and only the =rotate= method is
  implemented.
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PRotate
    (rotate [_ t]))

  (defprotocol PRotate3D
    (rotate-x [_ t])
    (rotate-y [_ t])
    (rotate-z [_ t])
    (rotate-around-axis [_ a t]))
#+END_SRC
**** PScale
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PScale
    (scale [_ s] [_ a b] [_ a b c])
    (scale-size [_ s]))
#+END_SRC
**** PShear
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PShear
    (shear [_ s] [_ sx sy] [_ sx sy sz]))
#+END_SRC
**** PTransform
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PTransform
    (transform [_ matrix]))
#+END_SRC
**** PTranslate
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PTranslate
    (translate [_ t] [_ x y] [_ x y z]))
#+END_SRC
**** PVectorTransform
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PVectorTransform
    (transform-vector [_ v]))
#+END_SRC
*** Graph operations

Most geometric shape constructs can be understood as an undirected
graph of vertices, connected by edges. This protocol provides read
access to entities in this context.

**** PGraph
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PGraph
    (connected-components [_])
    (cyclic? [_])
    (edges [_] [_ n])
    (vertices [_] [_ n])
    (vertex-valence [_ v])
    (vertex-neighbors [_ v])
    (remove-vertex [_ v])
    (replace-vertex [_ a b])
    (merge-vertices [_ a b]))
#+END_SRC
**** PDirectedGraph
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PDirectedGraph
    (in-vertices [_ v])
    (out-vertices [_ v]))
#+END_SRC
**** PGraphConvert
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PGraphConvert
    (as-graph [_] [_ opts]))
#+END_SRC
*** Shape based & structural operations
**** PAlign
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PAlign
    (align-with [_ x opts]
      "Returns updated entity aligned with `x` in the specified manner"))
#+END_SRC
**** PArea
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PArea
    (area [_]
      "Returns an entity's total surface area"))
#+END_SRC
**** PBoundary
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PBoundary
    (contains-entity? [_ s])
    (contains-point? [_ p]))
#+END_SRC
**** PBoundingCircle
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PBoundingCircle
    (bounding-circle [_]))
#+END_SRC
**** PBoundingSphere
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PBoundingSphere
    (bounding-sphere [_]))
#+END_SRC
**** PBounds
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PBounds
    (bounds [_]
      "Returns bounding rect for 2d entities or box for 3d")
    (depth [_]
      "Returns entity's extent along Z (zero for 2d)")
    (height [_]
      "Returns entity's extent along Y axis")
    (width [_]
      "Returns entity's extent along X axis"))
#+END_SRC
**** PCenter
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PCenter
    (center [_] [_ p]
      "Returns updated entity centered around world origin or given point")
    (centroid [_]
      "Returns centroid of entity"))
#+END_SRC
**** PCircumference
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PCircumference
    (circumference [_]
      "Returns an entity's circumference"))
#+END_SRC
**** PClassify
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PClassify
    (classify-point [_ p]))
#+END_SRC
**** TODO PClip
***** TODO remove protocol, method is already part of PSetOps
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PClip
    (clip-with [_ s]))
#+END_SRC
**** TODO PConvexHull
***** TODO rename into PConvex, add convex? method
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PConvexHull
    (convex-hull [_]))
#+END_SRC
**** PExtrude
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PExtrude
    (extrude [_ opts])
    (extrude-shell [_ opts]))
#+END_SRC
**** PFlip
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PFlip
    (flip [_]))
#+END_SRC
**** PIntersect
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PIntersect
    (intersect-line [_ l] [_ p q])
    (intersect-ray [_ r] [_ p dir])
    (intersect-shape [_ s]))
#+END_SRC
**** PMeshConvert

Anything which can be turned into a 2D or 3D mesh will implement _
protocol consisting of just _ one function: =as-mesh=.

#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PMeshConvert
    (as-mesh [_] [_ opts]
      "Transforms the current enitity into a Mesh instance"))
 #+END_SRC
**** PPolygonConvert
       Anything which can be turned into a polygon will implement _
       protocol consisting of just _ one function: =as-polygon=.
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PPolygonConvert
    (as-polygon [_] [_ res]
      "Transforms current entity into a Polygon instance"))
#+END_SRC
**** PProximity
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PProximity
    (closest-point [_ p]))
#+END_SRC
**** PSample
***** TODO move random-point-inside into PBoundary
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PSample
    (point-at [_ t] [_ u v])
    (random-point [_])
    (random-point-inside [_])
    (sample-uniform [_ dist include-last?])
    (sample-with-resolution [_ res]))
#+END_SRC
**** PSlice
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PSlice
    (slice-with [_ e] [_ e classifier] [_ e classifier parts]))
#+END_SRC
**** PSubdivide
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PSubdivide
    (subdivide [_] [_ opts])
    (subdivide-edge [_ a b splits])
    (subdivide-face [_ f p displace splits]))
#+END_SRC
**** PTessellate
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PTessellate
    (tessellate [_] [_ opts]))
#+END_SRC
**** PVolume
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PVolume
    (volume [_] "Returns an entity's inner volume.")
    (signed-volume [_]))
#+END_SRC
*** Type specific operations
**** TODO PSpatialTree
***** TODO refactor to use conj & disj?
***** TODO extract more general tree protocol?
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
(defprotocol PSpatialTree
  (add-point [_ p])
  (child-index-for-point [_ p])
  (child-for-point [_ p])
  (delete-point [_ p])
  (get-children [_])
  (get-point [_])
  (set-child [_ i c])
  (set-children [_ c])
  (set-point [_ p])
  (make-child-for-point [_ p add-point?])
  (split-node [_]))
#+END_SRC
**** PCurve
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PCurve
    (arc-length [_])
    (auto-spline [_]))
#+END_SRC
**** PMesh
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PMesh
    (add-face [_ f])
    (compute-face-normals [_])
    (compute-vertex-normals [_])
    (faces [_])
    (into-mesh [_ m])
    (remove-face [_ f])
    (vertex-faces [_ v]))
#+END_SRC
** Vector implementations

For performance reasons we decided to define custom data types for
vectors & matrices. Since they implement the necessary protocols and
interfaces, these types can be used much like standard Clojure
vectors/seqs, but also provide implementations for the above geometry
protocols and custom key lookups to enable swizzling.

Furthermore, since we aim for full ClojureScript compatibility,
the following implementations are quite lengthy.

*** Declarations

Some functions used by the following vector types will be
defined further on, but need to be declared already.

#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (declare vec2 swizzle2 swizzle2-assoc)
  (declare vec3 swizzle3 swizzle3-assoc)
  (declare M32 M44)
  (declare vec2-op-1 vec2-op-2 vec2-op-2* vec2-op-3)
  (declare vec3-op-1 vec3-op-2 vec3-op-3)
#+END_SRC
*** Protocol helpers
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  ,#+clj
  (defn map-entry
    [k ^double v]
    (reify
      clojure.lang.IMapEntry
      java.util.Map$Entry
      (key [_] k)
      (getKey [_] k)
      (val [_] v)
      (getValue [_] v)
      (hashCode [_]
        (hash-combine
         (clojure.lang.Util/hash k)
         (clojure.lang.Util/hash v)))
      (equals [_ x]
        (and (instance? java.util.Map$Entry x)
             (clojure.lang.Util/equals
              k (.getKey ^java.util.Map$Entry x))
             (clojure.lang.Util/equals
              v (.getValue ^java.util.Map$Entry x))))))
#+END_SRC
*** 2D
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (deftype Vec2
    ,#+clj [^double x ^double y _meta]
    ,#+cljs [x y _meta]
#+END_SRC
**** Clojure protocols
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  ,#+clj clojure.lang.IObj
  ,#+clj (meta
         [_]_meta)
  ,#+clj (withMeta
         [_ m*] (Vec2. x y m*))
  
  ,#+clj clojure.lang.ILookup
  ,#+clj (valAt
         [_ k] (swizzle2 _ k nil))
  ,#+clj (valAt
         [_ k nf] (swizzle2 _ k nf))
  
  ,#+clj java.util.concurrent.Callable
  ,#+clj (call
         [_] (.invoke ^clojure.lang.IFn _))
  ,#+clj java.lang.Runnable
  ,#+clj (run
         [_] (.invoke ^clojure.lang.IFn _))
  
  ,#+clj clojure.lang.IFn
  ,#+clj (invoke
         [_ k] (swizzle2 _ k nil))
  ,#+clj (invoke
         [_ k nf] (swizzle2 _ k nf))
  ,#+clj (applyTo
         [_ args]
         (condp = (count args)
           1 (swizzle2 _ (first args) nil)
           2 (swizzle2 _ (first args) (second args))
           (err/arity-error! (count args))))
  
  ,#+clj clojure.lang.IMapEntry
  ,#+clj java.util.Map$Entry
  ,#+clj (key
         [_] x)
  ,#+clj (getKey
         [_] x)
  ,#+clj (val
         [_] y)
  ,#+clj (getValue
         [_] y)
  
  ,#+clj clojure.lang.Associative
  ,#+clj clojure.lang.IPersistentVector
  ,#+clj (count
         [_] 2)
  ,#+clj (length
         [_] 2)
  ,#+clj (containsKey
         [_ k] (not (nil? (#{0 1 :x :y} k))))
  ,#+clj (entryAt
         [_ k] (map-entry k (case (int k) 0 x, 1 y, (err/key-error! k))))
  ,#+clj (assoc
            [_ k v] (swizzle2-assoc _ k v))
  ,#+clj (assocN
         [_ k v] (case (int k) 0 (Vec2. v y _meta), 1 (Vec2. x v _meta), (err/key-error! k)))
  
  ,#+clj java.util.Collection
  ,#+clj (isEmpty
         [_] false)
  ,#+clj (iterator
         [_] (.iterator ^java.util.Collection (list x y)))
  ,#+clj (toArray
         [_] (double-array 2 [x y]))
  ,#+clj (size [_] 2)
  
  ,#+clj clojure.lang.IPersistentCollection
  ,#+clj clojure.lang.Indexed
  ,#+clj clojure.lang.Sequential
  ,#+clj clojure.lang.ISeq
  ,#+clj clojure.lang.Seqable
  ,#+clj (first
         [_] x)
  ,#+clj (next
         [_] (cons y nil))
  ,#+clj (more
         [_] (cons y nil))
  ,#+clj (cons
         [_ z] (with-meta (vec3 x y z) _meta))
  ,#+clj (peek
         [_] y)
  ,#+clj (pop
         [_] [x])
  ,#+clj (rseq
         [_] (Vec2. y x _meta))
  ,#+clj (seq
         [_] _)
  ,#+clj (nth
         [_ n] (case (int n) 0 x, 1 y, (err/key-error! n)))
  ,#+clj (nth
         [_ n nf] (case (int n) 0 x, 1 y, nf))
  ,#+clj (equiv
         [_ o]
         (if (instance? Vec2 o)
           (and (clojure.lang.Numbers/equiv x (.-x ^Vec2 o))
                (clojure.lang.Numbers/equiv y (.-y ^Vec2 o)))
           (and (instance? java.util.Collection o)
                (= 2 (count o))
                (clojure.lang.Util/equiv x (nth o 0))
                (clojure.lang.Util/equiv y (nth o 1)))))
  ,#+clj (equals
         [_ o]
         (if (instance? Vec2 o)
           (and (clojure.lang.Util/equals x (.-x ^Vec2 o))
                (clojure.lang.Util/equals y (.-y ^Vec2 o)))
           (and (instance? java.util.Collection o)
                (= 2 (count o))
                (clojure.lang.Util/equals x (nth o 0))
                (clojure.lang.Util/equals y (nth o 1)))))
  
  ;; http://docs.oracle.com/javase/7/docs/api/java/util/List.html#hashCode()
  ,#+clj (hashCode
         [_]
         (-> 31
             (unchecked-add-int (hash x))
             (unchecked-multiply-int 31)
             (unchecked-add-int (hash y))))
  
  ;; http://clojure.org/data_structures#hash
  ,#+clj clojure.lang.IHashEq
  ,#+clj (hasheq
         [_]
         (-> 31
             (unchecked-add-int (hash x))
             (unchecked-multiply-int 31)
             (unchecked-add-int (hash y))
             (mix-collection-hash 2)))
  
  Object
  (toString
   [_] (str "[" x " " y "]"))
#+END_SRC
**** ClojureScript protocols
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  ,#+cljs IMeta
  ,#+cljs (-meta
          [_] _meta)
  ,#+cljs IWithMeta
  ,#+cljs (-with-meta
          [_ m*] (Vec2. x y m*))
  
  ,#+cljs ICloneable
  ,#+cljs (-clone
          [_] (Vec2. x y _meta))
  
  ,#+cljs ILookup
  ,#+cljs (-lookup
          [_ k] (swizzle2 _ k nil))
  ,#+cljs (-lookup
          [_ k nf] (swizzle2 _ k nf))
  
  ,#+cljs IFn
  ,#+cljs (-invoke
          [_ k] (swizzle2 _ k nil))
  ,#+cljs (-invoke
          [_ k nf] (swizzle2 _ k nf))
  
  ,#+cljs ICounted
  ,#+cljs (-count
          [_] 2)
  
  ,#+cljs IAssociative
  ,#+cljs (-contains-key?
          [_ k] (not (nil? (#{0 1 :x :y} k))))
  ,#+cljs (-assoc
          [_ k v] (swizzle2-assoc _ k v))
  
  ,#+cljs IVector
  ,#+cljs (-assoc-n
          [_ k v] (case k 0 (Vec2. v y _meta), 1 (Vec2. x v _meta), (err/key-error! k)))
  
  ,#+cljs ISequential
  ,#+cljs ISeq
  ,#+cljs (-first
          [_] x)
  ,#+cljs (-rest
          [_] (cons y nil))
  
  ,#+cljs INext
  ,#+cljs (-next
          [_] (cons y nil))
  
  ,#+cljs ISeqable
  ,#+cljs (-seq
          [_] _)
  
  ,#+cljs IReversible
  ,#+cljs (-rseq
          [_] (Vec2. y x _meta))
  
  ,#+cljs IIndexed
  ,#+cljs (-nth
          [_ n] (case n 0 x, 1 y, (err/key-error! n)))
  ,#+cljs (-nth
          [_ n nf] (case n 0 x, 1 y, nf))
  
  ,#+cljs ICollection
  ,#+cljs (-conj
          [_ z] (with-meta (vec3 x y z) _meta))
  
  ,#+cljs IStack
  ,#+cljs (-peek
          [_] y)
  ,#+cljs (-pop
          [_] [x])
  
  ,#+cljs IComparable
  ,#+cljs (-compare
          [_ o]
          (if (instance? Vec2 o)
            (let [c (compare x (.-x ^Vec2 o))]
              (if (== 0 c) (compare y (.-y ^Vec2 o)) c))
            (let [c (count o)]
              (if (= 2 c) (compare o _) (- 2 c)))))
  
  ,#+cljs IHash
  ,#+cljs (-hash
          [_] (hash-combine (hash x) (hash y)))
  
  ,#+cljs IEquiv
  ,#+cljs (-equiv
          [_ o]
          (if (instance? Vec2 o)
            (and (== x (.-x ^Vec2 o)) (== y (.-y ^Vec2 o)))
            (and (sequential? o) (= 2 (count o))
                 (= x (nth o 0)) (= y (nth o 1)))))
#+END_SRC
**** Transformations
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PScale
  (scale
   [_ a] (vec2-op-1 clojure.core/* _ a 1.0 _meta))
  (scale
   [_ a b] (vec2-op-2 clojure.core/* _ a b 1.0 1.0 _meta))
  (scale
   [_ a b c] (vec2-op-3 clojure.core/* _ a b c 1.0 _meta))
  
  PTranslate
  (translate
   [_ a] (vec2-op-1 clojure.core/+ _ a 0.0 _meta))
  (translate
   [_ a b] (vec2-op-2 clojure.core/+ _ a b 0.0 0.0 _meta))
  (translate
   [_ a b c] (vec2-op-3 clojure.core/+ _ a b c 0.0 _meta))
  
  PRotate
  (rotate
   [_ theta]
   (let [s (Math/sin theta) c (Math/cos theta)]
     (Vec2. (mm/msub x c y s) (mm/madd x s y c) _meta)))
  PRotate3D
  (rotate-x
   [_ theta] (rotate-x (vec3 _) theta))
  (rotate-y
   [_ theta] (rotate-y (vec3 _) theta))
  (rotate-z
   [_ theta] (vec3 (rotate _ theta)))
  (rotate-around-axis
   [_ axis theta] (rotate-around-axis (vec3 _) axis theta))
  
  PTransform
  (transform
   [_ m] (transform-vector m _))
#+END_SRC
**** PMathOps
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PMathOps
  (abs [_] (Vec2. (m/abs x) (m/abs y) _meta))
  (+ [_] _)
  (+ [_ a] (vec2-op-1 clojure.core/+ _ a 0.0 _meta))
  (+ [_ a b] (vec2-op-2 clojure.core/+ _ a b 0.0 0.0 _meta))
  (+ [_ a b c] (vec2-op-3 clojure.core/+ _ a b c 0.0 _meta))
  
  (- [_] (Vec2. (clojure.core/- x) (clojure.core/- y) _meta))
  (- [_ a] (vec2-op-1 clojure.core/- _ a 0.0 _meta))
  (- [_ a b] (vec2-op-2 clojure.core/- _ a b 0.0 0.0 _meta))
  (- [_ a b c] (vec2-op-3 clojure.core/- _ a b c 0.0 _meta))
  
  (* [_] _)
  (* [_ a] (vec2-op-1 clojure.core/* _ a 1.0 _meta))
  (* [_ a b] (vec2-op-2 clojure.core/* _ a b 1.0 1.0 _meta))
  (* [_ a b c] (vec2-op-3 clojure.core/* _ a b c 1.0 _meta))
  
  (div [_] (Vec2. (clojure.core// x) (clojure.core// y) _meta))
  (div [_ a] (vec2-op-1 clojure.core// _ a 0.0 _meta))
  (div [_ a b] (vec2-op-2 clojure.core// _ a b 0.0 0.0 _meta))
  (div [_ a b c] (vec2-op-3 clojure.core// _ a b c 0.0 _meta))
  
  (madd [_ a b] (vec2-op-2* clojure.core/* clojure.core/+ _ a b 1.0 0.0 _meta))
  (addm [_ a b] (vec2-op-2* clojure.core/+ clojure.core/* _ a b 0.0 1.0 _meta))
#+END_SRC
**** PDotProduct
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PDotProduct
  (dot
   [_ [ax ay]] (mm/madd x ax y ay))
#+END_SRC
**** PCrossProduct
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PCrossProduct
  (cross
   [_ [ax ay]] (mm/msub x ay y ax))
#+END_SRC
**** PLimit
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PLimit
  (limit
   [_ len]
   (if (> (mag-squared _) (mm/mul len len))
     (normalize _ len) _))
#+END_SRC
**** PMinMax
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PMinMax
  (min
   [_ [ax ay]]
   (Vec2.
    (clojure.core/min x ax)
    (clojure.core/min y ay) _meta))
  (min
   [_ [ax ay] [bx by]]
   (Vec2.
    (clojure.core/min (clojure.core/min x ax) bx)
    (clojure.core/min (clojure.core/min y ay) by) _meta))
  (max
   [_ [ax ay]]
   (Vec2.
    (clojure.core/max x ax)
    (clojure.core/max y ay) _meta))
  (max
   [_ [ax ay] [bx by]]
   (Vec2.
    (clojure.core/max (clojure.core/max x ax) bx)
    (clojure.core/max (clojure.core/max y ay) by) _meta))
#+END_SRC
**** PMagnitude
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PMagnitude
  (mag
   [_]
   (Math/sqrt (mm/madd x x y y)))
  (mag-squared
   [_] (mm/madd x x y y))
#+END_SRC
**** PNormalize
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PNormalize
  (normalize
   [_]
   (let [l (Math/sqrt (mm/madd x x y y))]
     (if (pos? l)
       (Vec2. (mm/div x l) (mm/div y l) _meta)
       _)))
  (normalize
   [_ len]
   (let [l (Math/sqrt (mm/madd x x y y))]
     (if (pos? l)
       (let [l (mm/div len l)]
         (Vec2. (mm/mul x l) (mm/mul y l) _meta))
       _)))
  (normalized?
   [_] (m/delta= 1.0 (mag-squared _)))
#+END_SRC
**** PDistance
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PDistance
  (dist
   [_ a]
   (let [[dx dy] (if (instance? Vec2 a)
                   [(mm/sub x (.-x ^Vec2 a)) (mm/sub y (.-y ^Vec2 a))]
                   [(mm/sub x (nth a 0)) (mm/sub y (nth a 1))])]
     (Math/sqrt (mm/madd dx dx dy dy))))
  (dist-squared
   [_ a]
   (let [[dx dy] (if (instance? Vec2 a)
                   [(mm/sub x (.-x ^Vec2 a)) (mm/sub y (.-y ^Vec2 a))]
                   [(mm/sub x (nth a 0)) (mm/sub y (nth a 1))])]
     (mm/madd dx dx dy dy)))
#+END_SRC
**** PReflect
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PReflect
  (reflect
   [_ [rx ry :as r]]
    (let [d (mm/mul (dot _ r) 2.0)]
      (Vec2.
       (mm/msub rx d x)
       (mm/msub ry d y) _meta)))
#+END_SRC
**** PInvert
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PInvert
  (invert
   [_] (Vec2. (clojure.core/- x) (clojure.core/- y) _meta))
#+END_SRC
**** PInterpolate
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PInterpolate
  (mix
   [_ [ax ay]]
   (Vec2. (mm/submadd ax x 0.5 x) (mm/submadd ay y 0.5 y) _meta))
  (mix
   [_ [ax ay] t]
   (Vec2. (mm/submadd ax x t x) (mm/submadd ay y t y) _meta))
#+END_SRC
**** PHeading
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PHeading
  (heading
   [_]
   (let [t (Math/atan2 y x)]
     (if (neg? t) (mm/add t TWO_PI) t)))
  (heading-xy [_] (heading _))
  (angle-between
   [_ a]
   (let [t (mm/sub (heading-xy a) (heading-xy _))]
     (if (neg? t) (mm/add t TWO_PI) t)))
  (slope-xy [_] (mm/div y x))
  (normal [_] (Vec2. (clojure.core/- y) x _meta))
#+END_SRC
**** PPolar
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PPolar
  (as-polar
   [_] (Vec2. (mag _) (heading-xy _) _meta))
  (as-cartesian
   [_] (Vec2. (mm/mul x (Math/cos y)) (mm/mul x (Math/sin y)) _meta))
#+END_SRC
**** End of implementations
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  )
#+END_SRC
**** Override print methods
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  #+clj (require 'clojure.pprint)
  #+clj (prefer-method clojure.pprint/simple-dispatch clojure.lang.IPersistentVector clojure.lang.ISeq)
  #+clj (defmethod print-method Vec2 [o ^java.io.Writer w] (.write w (.toString o)))
#+END_SRC
*** 3D
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (deftype Vec3
    #+clj [^double x ^double y ^double z _meta]
    #+cljs [x y z _meta]
#+END_SRC
**** Clojure protocols
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  ,#+clj clojure.lang.IObj
  ,#+clj (meta
         [_] _meta)
  ,#+clj (withMeta
         [_ m*] (Vec3. x y z m*))
  
  ,#+clj clojure.lang.ILookup
  ,#+clj (valAt
         [_ k] (swizzle3 _ k nil))
  ,#+clj (valAt
         [_ k nf] (swizzle3 _ k nf))
  
  ,#+clj java.util.concurrent.Callable
  ,#+clj (call
         [_] (.invoke ^clojure.lang.IFn _))
  ,#+clj java.lang.Runnable
  ,#+clj (run
         [_] (.invoke ^clojure.lang.IFn _))
  
  ,#+clj clojure.lang.IFn
  ,#+clj (invoke
         [_ k] (swizzle3 _ k nil))
  ,#+clj (invoke
         [_ k nf] (swizzle3 _ k nf))
  ,#+clj (applyTo
         [_ args]
         (condp = (count args)
           1 (swizzle3 _ (first args) nil)
           2 (swizzle3 _ (first args) (second args))
           (err/arity-error! (count args))))
  
  ,#+clj clojure.lang.Associative
  ,#+clj clojure.lang.IPersistentVector
  ,#+clj (count
         [_] 3)
  ,#+clj (length
         [_] 3)
  ,#+clj (containsKey
         [_ k] (not (nil? (#{0 1 2 :x :y :z} k))))
  ,#+clj (entryAt
         [_ k] (map-entry k (case (int k) 0 x, 1 y, 2 z, (err/key-error! k))))
  ,#+clj (assoc
            [_ k v] (swizzle3-assoc _ k v))
  ,#+clj (assocN
         [_ k v]
         (case (int k)
           0 (Vec3. v y z _meta)
           1 (Vec3. x v z _meta)
           2 (Vec3. x y v _meta)
           (err/key-error! k)))
  
  ,#+clj java.util.Collection
  ,#+clj (isEmpty
         [_] false)
  ,#+clj (iterator
         [_] (.iterator ^java.util.Collection (list x y z)))
  ,#+clj (toArray
         [_] (double-array 3 [x y z]))
  ,#+clj (size
         [_] 3)
  
  ,#+clj clojure.lang.IPersistentCollection
  ,#+clj clojure.lang.Indexed
  ,#+clj clojure.lang.Sequential
  ,#+clj clojure.lang.ISeq
  ,#+clj clojure.lang.Seqable
  ,#+clj (first
         [_] x)
  ,#+clj (next
         [_] (cons y (cons z nil)))
  ,#+clj (more
         [_] (cons y (cons z nil)))
  ,#+clj (cons
         [_ w] (with-meta [x y z w] _meta))
  ,#+clj (peek
         [_] z)
  ,#+clj (pop
         [_] (Vec2. x y _meta))
  ,#+clj (rseq
         [_] (Vec3. z y x _meta))
  ,#+clj (seq
         [_] _)
  ,#+clj (nth
         [_ n] (condp = n 0 x 1 y 2 z (err/key-error! n)))
  ,#+clj (nth
         [_ n nf] (condp = n 0 x 1 y 2 z nf))
  ,#+clj (equiv
         [_ o]
         (if (instance? Vec3 o)
           (and (clojure.lang.Numbers/equiv x (.-x ^Vec3 o))
                (clojure.lang.Numbers/equiv y (.-y ^Vec3 o))
                (clojure.lang.Numbers/equiv z (.-z ^Vec3 o)))
           (and (instance? java.util.Collection o)
                (= 3 (count o))
                (clojure.lang.Util/equiv x (nth o 0))
                (clojure.lang.Util/equiv y (nth o 1))
                (clojure.lang.Util/equiv z (nth o 2)))))
  ,#+clj (equals
         [_ o]
         (if (instance? Vec3 o)
           (and (clojure.lang.Util/equals x (.-x ^Vec3 o))
                (clojure.lang.Util/equals y (.-y ^Vec3 o))
                (clojure.lang.Util/equals z (.-z ^Vec3 o)))
           (and (instance? java.util.Collection o)
                (= 3 (count o))
                (clojure.lang.Util/equals x (nth o 0))
                (clojure.lang.Util/equals y (nth o 1))
                (clojure.lang.Util/equals z (nth o 2)))))
  
  ,#+clj Comparable
  ,#+clj (compareTo
         [_ o]
         (if (instance? Vec3 o)
           (let [c (compare x (.-x ^Vec3 o))]
             (if (== 0 c)
               (let [c (compare y (.-y ^Vec3 o))]
                 (if (== 0 c)
                   (compare z (.-z ^Vec3 o))
                   c))
               c))
           (let [c (count o)]
             (if (== 3 c) (compare o _) (- 3 c)))))
  ,#+clj (hashCode
         [_]
         (-> 31
             (unchecked-add-int (hash x))
             (unchecked-multiply-int 31)
             (unchecked-add-int (hash y))
             (unchecked-multiply-int 31)
             (unchecked-add-int (hash z))))
  
  ,#+clj clojure.lang.IHashEq
  ,#+clj (hasheq
           [_]
           (-> 31
               (unchecked-add-int (hash x))
               (unchecked-multiply-int 31)
               (unchecked-add-int (hash y))
               (unchecked-multiply-int 31)
               (unchecked-add-int (hash z))
               (mix-collection-hash 3)))
  
  Object
  (toString
    [_] (str "[" x " " y " " z "]"))
#+END_SRC
**** ClojureScript protocols
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  ,#+cljs IMeta
  ,#+cljs (-meta
          [_] _meta)
  ,#+cljs IWithMeta
  ,#+cljs (-with-meta
          [_ m*] (Vec3. x y z m*))
  
  ,#+cljs ICloneable
  ,#+cljs (-clone
          [_] (Vec3. x y z _meta))
  
  ,#+cljs ILookup
  ,#+cljs (-lookup
          [_ k] (swizzle3 _ k nil))
  ,#+cljs (-lookup
          [_ k nf] (swizzle3 _ k nf))
  
  ,#+cljs IFn
  ,#+cljs (-invoke
          [_ k] (swizzle3 _ k nil))
  ,#+cljs (-invoke
          [_ k nf] (swizzle3 _ k nf))
  
  ,#+cljs ICounted
  ,#+cljs (-count
          [_] 3)
  
  ,#+cljs IAssociative
  ,#+cljs (-contains-key?
          [_ k] (not (nil? (#{0 1 2 :x :y :z} k))))
  ,#+cljs (-assoc
          [_ k v] (swizzle3-assoc _ k v))
  
  ,#+cljs IVector
  ,#+cljs (-assoc-n
          [_ k v]
          (case k
            0 (Vec3. v y z _meta)
            1 (Vec3. x v z _meta)
            2 (Vec3. x y v _meta)
            (err/key-error! k)))
  
  ,#+cljs ISequential
  ,#+cljs ISeq
  ,#+cljs (-first
          [_] x)
  ,#+cljs (-rest
          [_] (cons y (cons z nil)))
  
  ,#+cljs INext
  ,#+cljs (-next
          [_] (cons y (cons z nil)))
  
  ,#+cljs ISeqable
  ,#+cljs (-seq
          [_] _)
  
  ,#+cljs IReversible
  ,#+cljs (-rseq
          [_] (Vec3. z y x _meta))
  
  ,#+cljs IIndexed
  ,#+cljs (-nth
          [_ n] (case n 0 x, 1 y, 2 z, (err/key-error! n)))
  ,#+cljs (-nth
          [_ n nf] (case n 0 x, 1 y, 2 z, nf))
  
  ,#+cljs ICollection
  ,#+cljs (-conj
          [_ w] (with-meta [x y z w] _meta))
  
  ,#+cljs IStack
  ,#+cljs (-peek
          [_] z)
  ,#+cljs (-pop
          [_] (Vec2. x y _meta))
  
  ,#+cljs IComparable
  ,#+cljs (-compare
          [_ o]
          (if (instance? Vec3 o)
            (let [c (compare x (.-x ^Vec3 o))]
              (if (== 0 c)
                (let [c (compare y (.-y ^Vec3 o))]
                  (if (== 0 c)
                    (compare z (.-z ^Vec3 o))
                    c))
                c))
            (let [c (count o)]
              (if (= 3 c) (compare o _) (- 3 c)))))
  
  ,#+cljs IHash
  ,#+cljs (-hash
          [_] (-> (hash x)
                  (hash-combine (hash y))
                  (hash-combine (hash z))))
  
  ,#+cljs IEquiv
  ,#+cljs (-equiv
          [_ o]
          (if (instance? Vec3 o)
            (and (== x (.-x ^Vec3 o)) (== y (.-y ^Vec3 o)) (== z (.-z ^Vec3 o)))
            (and (sequential? o) (= 3 (count o))
                 (= x (nth o 0)) (= y (nth o 1)) (= z (nth o 2)))))
#+END_SRC
**** Transformations
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PScale
  (scale
   [_ a] (vec3-op-1 clojure.core/* _ a 1.0 _meta))
  (scale
   [_ a b] (vec3-op-2 clojure.core/* clojure.core/* _ a b 1.0 1.0 _meta))
  (scale
   [_ a b c] (vec3-op-3 clojure.core/* _ a b c 1.0 _meta))
  
  PTranslate
  (translate
   [_ a] (vec3-op-1 clojure.core/+ _ a 0.0 _meta))
  (translate
   [_ a b] (vec3-op-2 clojure.core/+ clojure.core/+ _ a b 0.0 0.0 _meta))
  (translate
   [_ a b c] (vec3-op-3 clojure.core/+ _ a b c 0.0 _meta))
  
  PRotate
  (rotate [_ theta] (rotate-z _ theta))
  
  PRotate3D
  (rotate-x
   [_ theta]
   (let [s (Math/sin theta) c (Math/cos theta)]
     (Vec3. x (mm/msub y c z s) (mm/madd y s z c) _meta)))
  (rotate-y
   [_ theta]
   (let [s (Math/sin theta) c (Math/cos theta)]
     (Vec3. (mm/madd x c z s) y (mm/msub z c x s) _meta)))
  (rotate-z
   [_ theta]
   (let [s (Math/sin theta) c (Math/cos theta)]
     (Vec3. (mm/msub x c y s) (mm/madd x s y c) z _meta)))
  (rotate-around-axis
   [_ [ax ay az] theta]
   (let [ux (mm/mul ax x), uy (mm/mul ax y), uz (mm/mul ax z)
         vx (mm/mul ay x), vy (mm/mul ay y), vz (mm/mul ay z)
         wx (mm/mul az x), wy (mm/mul az y), wz (mm/mul az z)
         ax2 (mm/mul ax ax), ay2 (mm/mul ay ay), az2 (mm/mul az az)
         s (Math/sin theta), c (Math/cos theta)
         uvw (mm/add (mm/add ux vy) wz)]
     (Vec3.
      (mm/madd uvw ax
               (mm/msub (mm/add ay2 az2) x (mm/add vy wz) ax) c
               (mm/subm vz wy s))
  
      (mm/madd uvw ay
               (mm/msub (mm/add ax2 az2) y (mm/add ux wz) ay) c
               (mm/subm wx uz s))
  
      (mm/madd uvw az
               (mm/msub (mm/add ax2 ay2) z (mm/add ux vy) az) c
               (mm/subm uy vx s))
      _meta)))
  
  PTransform
  (transform
   [_ m] (transform-vector m _))
#+END_SRC
**** PMathOps
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PMathOps
  (abs [_] (Vec3. (m/abs x) (m/abs y) (m/abs z) _meta))
  (+ [_] _)
  (+ [_ a] (vec3-op-1 clojure.core/+ _ a 0.0 _meta))
  (+ [_ a b] (vec3-op-2 clojure.core/+ clojure.core/+ _ a b 0.0 0.0 _meta))
  (+ [_ a b c] (vec3-op-3 clojure.core/+ _ a b c 0.0 _meta))
  
  (- [_] (Vec3. (clojure.core/- x) (clojure.core/- y) (clojure.core/- z) _meta))
  (- [_ a] (vec3-op-1 clojure.core/- _ a 0.0 _meta))
  (- [_ a b] (vec3-op-2 clojure.core/- clojure.core/- _ a b 0.0 0.0 _meta))
  (- [_ a b c] (vec3-op-3 clojure.core/- _ a b c 0.0 _meta))
  
  (* [_] _)
  (* [_ a] (vec3-op-1 clojure.core/* _ a 1.0 _meta))
  (* [_ a b] (vec3-op-2 clojure.core/* clojure.core/* _ a b 1.0 1.0 _meta))
  (* [_ a b c] (vec3-op-3 clojure.core/* _ a b c 1.0 _meta))
  
  (div [_] (Vec3. (clojure.core// x) (clojure.core// y) (clojure.core// z) _meta))
  (div [_ a] (vec3-op-1 clojure.core// _ a 0.0 _meta))
  (div [_ a b] (vec3-op-2 clojure.core// clojure.core// _ a b 0.0 0.0 _meta))
  (div [_ a b c] (vec3-op-3 clojure.core// _ a b c 0.0 _meta))
  
  (madd
   [_ a b] (vec3-op-2 clojure.core/* clojure.core/+ _ a b 1.0 0.0 _meta))
  (addm
   [_ a b] (vec3-op-2 clojure.core/+ clojure.core/* _ a b 0.0 1.0 _meta))
  
  PDotProduct
  (dot
   [_ [ax ay az]]
   (mm/madd x ax y ay z az))
  
  PCrossProduct
  (cross
   [_ [ax ay az]]
   (Vec3.
    (mm/msub y az ay z)
    (mm/msub z ax az x)
    (mm/msub x ay ax y) _meta))
  
  PLimit
  (limit
   [_ len]
   (if (> (mag-squared _) (mm/mul len len))
     (normalize _ len)
     _))
  
  PMinMax
  (min
   [_ [ax ay az]]
   (Vec3.
    (clojure.core/min x ax)
    (clojure.core/min y ay)
    (clojure.core/min z az) _meta))
  (min
   [_ [ax ay az] [bx by bz]]
   (Vec3.
    (clojure.core/min (clojure.core/min x ax) bx)
    (clojure.core/min (clojure.core/min y ay) by)
    (clojure.core/min (clojure.core/min z az) bz) _meta))
  (max
   [_ [ax ay az]]
   (Vec3.
    (clojure.core/max x ax)
    (clojure.core/max y ay)
    (clojure.core/max z az) _meta))
  (max
   [_ [ax ay az] [bx by bz]]
   (Vec3.
    (clojure.core/max (clojure.core/max x ax) bx)
    (clojure.core/max (clojure.core/max y ay) by)
    (clojure.core/max (clojure.core/max z az) bz) _meta))
#+END_SRC
**** PMagnitude
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PMagnitude
  (mag
   [_]
   (Math/sqrt (mm/madd x x y y z z)))
  (mag-squared
   [_] (mm/madd x x y y z z))
#+END_SRC
**** PNormalize
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PNormalize
  (normalize
   [_]
   (let [l (Math/sqrt (mm/madd x x y y z z))]
     (if (pos? l)
       (Vec3. (mm/div x l) (mm/div y l) (mm/div z l) _meta)
       _)))
  (normalize
   [_ len]
   (let [l (Math/sqrt (mm/madd x x y y z z))]
     (if (pos? l)
       (let [l (mm/div len l)]
         (Vec3. (mm/mul x l) (mm/mul y l) (mm/mul z l) _meta)) _)))
  (normalized?
   [_] (m/delta= 1.0 (mag-squared _)))
#+END_SRC
**** PDistance
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PDistance
  (dist
   [_ a] (Math/sqrt (dist-squared _ a)))
  (dist-squared
   [_ a]
   (let [[dx dy dz] (if (instance? Vec3 a)
                      [(mm/sub x (.-x ^Vec3 a))
                       (mm/sub y (.-y ^Vec3 a))
                       (mm/sub z (.-z ^Vec3 a))]
                      [(mm/sub x (nth a 0))
                       (mm/sub y (nth a 1))
                       (mm/sub z (nth a 2 0.0))])]
     (mm/madd dx dx dy dy dz dz)))
#+END_SRC
**** PReflect
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PReflect
  (reflect
   [_ [rx ry rz :as r]]
    (let [d (mm/mul (dot _ r) 2.0)]
      (Vec3.
       (mm/msub rx d x)
       (mm/msub ry d y)
       (mm/msub rz d z) _meta)))
#+END_SRC
**** PInvert
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PInvert
  (invert
   [_] (Vec3. (clojure.core/- x) (clojure.core/- y) (clojure.core/- z) _meta))
#+END_SRC
**** PInterpolate
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PInterpolate
  (mix
   [_ [ax ay az]]
   (Vec3.
    (mm/submadd ax x 0.5 x)
    (mm/submadd ay y 0.5 y)
    (mm/submadd az z 0.5 z) _meta))
  (mix
   [_ [ax ay az] t]
   (Vec3.
    (mm/submadd ax x t x)
    (mm/submadd ay y t y)
    (mm/submadd az z t z) _meta))
#+END_SRC
**** PHeading
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PHeading
  (heading [_] (heading-xy _))
  (heading-xy
   [_]
   (let [t (Math/atan2 y x)]
     (if (neg? t) (mm/add t TWO_PI) t)))
  (heading-xz
   [_]
   (let [t (Math/atan2 z x)]
     (if (neg? t) (mm/add t TWO_PI) t)))
  (heading-yz
   [_]
   (let [t (Math/atan2 z y)]
     (if (neg? t) (mm/add t TWO_PI) t)))
  (angle-between
   [_ a]
   (let [t (mm/sub (heading-xy a) (heading-xy _))]
     (if (neg? t) (mm/add t TWO_PI) t)))
  (slope-xy [_] (mm/div y x))
  (slope-xz [_] (mm/div x x))
  (slope-yz [_] (mm/div z y))
#+END_SRC
**** PPolar
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  ;; http://mathworld.wolfram.com/SphericalCoordinates.html
  PPolar
  (as-polar
   [_]
    (let [r (mag _)
          theta (Math/atan2 y x)
          phi (Math/acos (mm/div z r))]
      (Vec3. r theta phi _meta)))
  (as-cartesian [_]
    (let [rsphi (mm/mul x (Math/sin z))]
      (Vec3.
       (mm/mul (Math/cos y) rsphi)
       (mm/mul (Math/sin y) rsphi)
       (mm/mul x (Math/cos z)) _meta)))
#+END_SRC
**** End of implementations
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
    )
#+END_SRC
**** Override print methods
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  #+clj (defmethod print-method Vec3 [o ^java.io.Writer w] (.write w (.toString o)))
#+END_SRC
*** Vector operations
**** 2D
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defn- vec2-op-seq
    [op ^Vec2 acc xs]
    (loop [ax (.-x acc), ay (.-y acc), xs xs]
      (if xs
        (let [v ^Vec2 (first xs)]
          (recur (op ax (.-x v)) (op ay (.-y v)) (next xs)))
        (Vec2. ax ay (.-_meta acc)))))
  
  (defn- vec2-op-1
    [op ^Vec2 _ a d m]
    (if (instance? Vec2 a)
      (Vec2.
       (op (.-x _) (.-x ^Vec2 a))
       (op (.-y _) (.-y ^Vec2 a)) m)
      (if (number? a)
        (Vec2. (op (.-x _) a) (op (.-y _) a) m)
        (if (instance? Vec2 (first a))
          (vec2-op-seq op _ a)
          (Vec2.
           (op (.-x _) (nth a 0 d))
           (op (.-y _) (nth a 1 d)) m)))))
  
  (defn- vec2-op-2
    [op ^Vec2 _ a b d1 d2 m]
    (if (instance? Vec2 a)
      (if (instance? Vec2 b)
        (Vec2. ;; v v
         (op (op (.-x _) (.-x ^Vec2 a)) (.-x ^Vec2 b))
         (op (op (.-y _) (.-y ^Vec2 a)) (.-y ^Vec2 b)) m)
        (if (number? b)
          (Vec2. ;; v n
           (op (op (.-x _) (.-x ^Vec2 a)) b)
           (op (op (.-y _) (.-y ^Vec2 a)) b) m)
          (Vec2. ;; v ?
           (op (op (.-x _) (.-x ^Vec2 a)) (nth b 0 d2))
           (op (op (.-y _) (.-y ^Vec2 a)) (nth b 1 d2)) m)))
      (let [an? (number? a) bn? (number? b)]
        (if (and an? bn?)
          (Vec2. ;; n n
           (op (.-x _) a)
           (op (.-y _) b) m)
          (let [[ax ay] (if an? [a a] a)
                [bx by] (if bn? [b b] b)]
            (Vec2. ;; ? ?
             (op (op (.-x _) (or ax d1)) (or bx d2))
             (op (op (.-y _) (or ay d1)) (or by d2)) m))))))
  
  (defn- vec2-op-2*
    "Similar to vec2-op-2 but takes 2 fn args and handles case with
    a & b being both numbers differently."
    [op op2 ^Vec2 _ a b d1 d2 m]
    (if (instance? Vec2 a)
      (if (instance? Vec2 b)
        (Vec2. ;; v v
         (op2 (op (.-x _) (.-x ^Vec2 a)) (.-x ^Vec2 b))
         (op2 (op (.-y _) (.-y ^Vec2 a)) (.-y ^Vec2 b)) m)
        (if (number? b)
          (Vec2. ;; v n
           (op2 (op (.-x _) (.-x ^Vec2 a)) b)
           (op2 (op (.-y _) (.-y ^Vec2 a)) b) m)
          (Vec2. ;; v ?
           (op2 (op (.-x _) (.-x ^Vec2 a)) (nth b 0 d2))
           (op2 (op (.-y _) (.-y ^Vec2 a)) (nth b 1 d2)) m)))
      (let [an? (number? a) bn? (number? b)]
        (if (and an? bn?)
          (Vec2. ;; n n
           (op2 (op (.-x _) a) b)    ;; difference to vec2-op-2
           (op2 (op (.-y _) a) b) m)
          (let [[ax ay] (if an? [a a] a)
                [bx by] (if bn? [b b] b)]
            (Vec2. ;; ? ?
             (op2 (op (.-x _) (or ax d1)) (or bx d2))
             (op2 (op (.-y _) (or ay d1)) (or by d2)) m))))))
  
  (defn- vec2-op-3
    [op ^Vec2 _ a b c d m]
    (if (instance? Vec2 a)
      (if (instance? Vec2 b)
        (if (instance? Vec2 c)
          (Vec2. ;; v v v
           (op (op (op (.-x _) (.-x ^Vec2 a)) (.-x ^Vec2 b)) (.-x ^Vec2 c))
           (op (op (op (.-y _) (.-y ^Vec2 a)) (.-y ^Vec2 b)) (.-y ^Vec2 c)) m)
          (if (number? c)
            (Vec2. ;; v v n
             (op (op (op (.-x _) (.-x ^Vec2 a)) (.-x ^Vec2 b)) c)
             (op (op (op (.-y _) (.-y ^Vec2 a)) (.-y ^Vec2 b)) c) m)
            (Vec2. ;; v v ?
             (op (op (op (.-x _) (.-x ^Vec2 a)) (.-x ^Vec2 b)) (nth c 0 d))
             (op (op (op (.-y _) (.-y ^Vec2 a)) (.-y ^Vec2 b)) (nth c 1 d)) m)))
        (let [[bx by] (if (number? b) [b b] b)
              [cx cy] (if (number? c) [c c] c)]
          (Vec2. ;; v ? ?
           (op (op (op (.-x _) (.-x ^Vec2 a)) (or bx d)) (or cx d))
           (op (op (op (.-y _) (.-y ^Vec2 a)) (or by d)) (or cy d)) m)))
      (let [[ax ay] (if (number? a) [a a] a)
            [bx by] (if (number? b) [b b] b)
            [cx cy] (if (number? c) [c c] c)]
        (Vec2. ;; ? ? ?
         (op (op (op (.-x _) (or ax d)) (or bx d)) (or cx d))
         (op (op (op (.-y _) (or ay d)) (or by d)) (or cy d)) m))))
#+END_SRC
**** 3D
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defn- vec3-op-seq
    [op ^Vec3 acc xs]
    (loop [ax (.-x acc), ay (.-y acc), az (.-z acc), xs xs]
      (if xs
        (let [v ^Vec3 (first xs)]
          (recur (op ax (.-x v)) (op ay (.-y v)) (op az (.-z v)) (next xs)))
        (Vec3. ax ay az (.-_meta acc)))))
  
  (defn- vec3-op-1
    [op ^Vec3 _ a d m]
    (if (instance? Vec3 a)
      (Vec3.
       (op (.-x _) (.-x ^Vec3 a))
       (op (.-y _) (.-y ^Vec3 a))
       (op (.-z _) (.-z ^Vec3 a)) m)
      (if (number? a)
        (Vec3. (op (.-x _) a) (op (.-y _) a) (op (.-z _) a) m)
        (if (instance? Vec3 (first a))
          (vec3-op-seq op _ a)
          (Vec3.
           (op (.-x _) (nth a 0 d))
           (op (.-y _) (nth a 1 d))
           (op (.-z _) (nth a 2 d)) m)))))
  
  (defn- vec3-op-2
    [op op2 ^Vec3 _ a b d1 d2 m]
    (if (instance? Vec3 a)
      (if (instance? Vec3 b)
        (Vec3. ;; v v
         (op2 (op (.-x _) (.-x ^Vec3 a)) (.-x ^Vec3 b))
         (op2 (op (.-y _) (.-y ^Vec3 a)) (.-y ^Vec3 b))
         (op2 (op (.-z _) (.-z ^Vec3 a)) (.-z ^Vec3 b)) m)
        (if (number? b)
          (Vec3. ;; v n
           (op2 (op (.-x _) (.-x ^Vec3 a)) b)
           (op2 (op (.-y _) (.-y ^Vec3 a)) b)
           (op2 (op (.-z _) (.-z ^Vec3 a)) b) m)
          (Vec3. ;; v ?
           (op2 (op (.-x _) (.-x ^Vec3 a)) (nth b 0 d2))
           (op2 (op (.-y _) (.-y ^Vec3 a)) (nth b 1 d2))
           (op2 (op (.-z _) (.-z ^Vec3 a)) (nth b 2 d2)) m)))
      (let [[ax ay az] (if (number? a) [a a a] a)
            [bx by bz] (if (number? b) [b b b] b)]
        (Vec3. ;; ? ? ?
         (op2 (op (.-x _) (or ax d1)) (or bx d2))
         (op2 (op (.-y _) (or ay d1)) (or by d2))
         (op2 (op (.-z _) (or az d1)) (or bz d2)) m))))
  
  (defn- vec3-op-3
    [op ^Vec3 _ a b c d m]
    (if (instance? Vec3 a)
      (if (instance? Vec3 b)
        (if (instance? Vec3 c)
          (Vec3. ;; v v v
           (op (op (op (.-x _) (.-x ^Vec3 a)) (.-x ^Vec3 b)) (.-x ^Vec3 c))
           (op (op (op (.-y _) (.-y ^Vec3 a)) (.-y ^Vec3 b)) (.-y ^Vec3 c))
           (op (op (op (.-z _) (.-z ^Vec3 a)) (.-z ^Vec3 b)) (.-z ^Vec3 c)) m)
          (if (number? c)
            (Vec3. ;; v v n
             (op (op (op (.-x _) (.-x ^Vec3 a)) (.-x ^Vec3 b)) c)
             (op (op (op (.-y _) (.-y ^Vec3 a)) (.-y ^Vec3 b)) c)
             (op (op (op (.-z _) (.-z ^Vec3 a)) (.-z ^Vec3 b)) c) m)
            (Vec3. ;; v v ?
             (op (op (op (.-x _) (.-x ^Vec3 a)) (.-x ^Vec3 b)) (nth c 0 d))
             (op (op (op (.-y _) (.-y ^Vec3 a)) (.-y ^Vec3 b)) (nth c 1 d))
             (op (op (op (.-z _) (.-z ^Vec3 a)) (.-z ^Vec3 b)) (nth c 2 d)) m)))
        (let [[bx by bz] (if (number? b) [b b b] b)
              [cx cy cz] (if (number? c) [c c c] c)]
          (Vec3. ;; v ? ?
           (op (op (op (.-x _) (.-x ^Vec3 a)) (or bx d)) (or cx d))
           (op (op (op (.-y _) (.-y ^Vec3 a)) (or by d)) (or cy d))
           (op (op (op (.-z _) (.-z ^Vec3 a)) (or bz d)) (or cz d)) m)))
      (let [an? (number? a) bn? (number? b) cn? (number? c)]
        (if (and an? bn? cn?)
          (Vec3. ;; n n n
           (op (.-x _) a)
           (op (.-y _) b)
           (op (.-z _) c) m)
          (let [[ax ay az] (if (number? a) [a a a] a)
                [bx by bz] (if (number? b) [b b b] b)
                [cx cy cz] (if (number? c) [c c c] c)]
            (Vec3. ;; ? ? ?
             (op (op (op (.-x _) (or ax d)) (or bx d)) (or cx d))
             (op (op (op (.-y _) (or ay d)) (or by d)) (or cy d))
             (op (op (op (.-z _) (or az d)) (or bz d)) (or cz d)) m))))))
#+END_SRC
*** Constants
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (def ^:const V2 (Vec2. 0.0 0.0 nil))
  (def ^:const V3 (Vec3. 0.0 0.0 0.0 nil))

  (def ^:const V2X (Vec2. 1.0 0.0 nil))
  (def ^:const V2Y (Vec2. 0.0 1.0 nil))

  (def ^:const V3X (Vec3. 1.0 0.0 0.0 nil))
  (def ^:const V3Y (Vec3. 0.0 1.0 0.0 nil))
  (def ^:const V3Z (Vec3. 0.0 0.0 1.0 nil))
#+END_SRC
*** Constructors
      To simplify vector type construction, factory functions
      are provided which coerce arguments into vectors with these
      rules:

      | Input                 | Behavior                                           | Examples call        | Example result  |
      |-----------------------+----------------------------------------------------+----------------------+-----------------|
      | Clojure vector or seq | select first =n= elements or fill missing with 0.0 | =(vec2 [1 2 3 4])=   | =[1.0 2.0]=     |
      |                       |                                                    | =(vec3 '(1 2)=       | =[1.0 2.0 0.0]= |
      | Map                   | select values of =:x :y :z= or fill with 0.0       | =(vec2 {:x 1 :y 2})= | =[1.0 2.0]=     |
      |                       |                                                    | =(vec3 {:x 1 :y 2})= | =[1.0 2.0 0.0]= |
      | Single number         | set all vector components                          | =(vec3 1)=           | =[1.0 1.0 1.0]= |

#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defn vec2
    ([] V2)
    ([x] (cond
          (instance? Vec2 x) x
          (sequential? x) (Vec2. (nth x 0 0.0) (nth x 1 0.0) (meta x))
          (number? x) (Vec2. x x nil)
          (map? x) (Vec2. (get x :x 0.0) (get x :y 0.0) (meta x))
          :default (err/type-error! "Vec2" x)))
    ([x y] (Vec2. x y nil)))
  
  (defn vec3
    ([] V3)
    ([x] (cond
          (instance? Vec3 x) x
          (sequential? x) (Vec3. (nth x 0 0.0) (nth x 1 0.0) (nth x 2 0.0) (meta x))
          (number? x) (Vec3. x x x nil)
          (map? x) (Vec3. (get x :x 0.0) (get x :y 0.0) (get x :z 0.0) (meta x))
          :default (err/type-error! "Vec3" x)))
    ([x y] (Vec3. x y 0.0 nil))
    ([x y z] (Vec3. x y z nil)))
  
  (defn vec2? [x] (instance? Vec2 x))
  (defn vec3? [x] (instance? Vec3 x))
#+END_SRC
*** Random vectors
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defn randvec2
    ([] (normalize (vec2 (m/randnorm) (m/randnorm))))
    ([n] (normalize (vec2 (m/randnorm) (m/randnorm)) n)))

  (defn randvec3
    ([] (normalize (vec3 (m/randnorm) (m/randnorm) (m/randnorm))))
    ([n] (normalize (vec3 (m/randnorm) (m/randnorm) (m/randnorm)) n)))
#+END_SRC
*** Swizzling
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defn- swizzle2
    [^Vec2 _ k default]
    (if (number? k)
      (case (int k)
        0 (.-x _)
        1 (.-y _)
        (or default (err/key-error! k)))
      (case k
        :x (.-x _)
        :y (.-y _)
        (let [n (name k) c (count n)]
          (case c
            2 (->> n
                   (map #(case % \x (.-x _) \y (.-y _) (or default (err/key-error! k))))
                   ((fn [[x y]] (Vec2. x y (.-_meta _)))))
            3 (->> n
                   (map #(case % \x (.-x _) \y (.-y _) (or default (err/key-error! k))))
                   ((fn [[x y z]] (Vec3. x y z (.-_meta _)))))
            (or default (err/key-error! k)))))))
  
  (defn- swizzle2-assoc
    [^Vec2 _ k v]
    (case k
      0 (Vec2. v (.-y _) (.-_meta _))
      1 (Vec2. (.-x _) v (.-_meta _))
      :x (Vec2. v (.-y _) (.-_meta _))
      :y (Vec2. (.-x _) v (.-_meta _))
      :xy (Vec2. (v 0) (v 1) (.-_meta _))
      :yx (Vec2. (v 1) (v 0) (.-_meta _))
      (err/key-error! k)))
  
  (defn- swizzle3
    [^Vec3 _ k default]
    (if (number? k)
      (case (int k)
        0 (.-x _)
        1 (.-y _)
        2 (.-z _)
        (or default (err/key-error! k)))
      (case k
        :x (.-x _)
        :y (.-y _)
        :z (.-z _)
        (let [n (name k) c (count n)]
          (case c
            2 (->> n
                   (map #(case % \x (.-x _) \y (.-y _) \z (.-z _) (or default (err/key-error! k))))
                   ((fn [[x y]] (Vec2. x y (.-_meta _)))))
            3 (->> n
                   (map #(case % \x (.-x _) \y (.-y _) \z (.-z _) (or default (err/key-error! k))))
                   ((fn [[x y z]] (Vec3. x y z (.-_meta _)))))
            (or default (err/key-error! k)))))))
  
  (defn- swizzle3-assoc
    [^Vec3 _ k v]
    (case k
      :x (Vec3. v (.-y _) (.-z _) (.-_meta _))
      :y (Vec3. (.-x _) v (.-z _) (.-_meta _))
      :z (Vec3. (.-x _) (.-y _) v (.-_meta _))
      0 (Vec3. v (.-y _) (.-z _) (.-_meta _))
      1 (Vec3. (.-x _) v (.-z _) (.-_meta _))
      2 (Vec3. (.-x _) (.-y _) v (.-_meta _))
      :xy (Vec3. (v 0) (v 1) (.-z _) (.-_meta _)) ;; (assoc [x y z] :xy [a b]) => [a b z]
      :yx (Vec3. (v 1) (v 0) (.-z _) (.-_meta _)) ;; (assoc [x y z] :yx [a b]) => [b a z]
      :xz (Vec3. (v 0) (.-y _) (v 1) (.-_meta _)) ;; (assoc [x y z] :xz [a b]) => [a y b]
      :zx (Vec3. (v 1) (.-y _) (v 0) (.-_meta _)) ;; (assoc [x y z] :zx [a b]) => [b y a]
      :yz (Vec3. (.-x _) (v 0) (v 1) (.-_meta _)) ;; (assoc [x y z] :yz [a b]) => [x a b]
      :zy (Vec3. (.-x _) (v 1) (v 0) (.-_meta _)) ;; (assoc [x y z] :zy [a b]) => [x b a]
      (err/key-error! k)))
#+END_SRC
** Matrix implementations
*** 3x2 Matrix (Affine 2D transform)
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defrecord Matrix32
    #+clj  [^double m00 ^double m01 ^double m02
            ^double m10 ^double m11 ^double m12]
    #+cljs [m00 m01 m02 m10 m11 m12]
#+END_SRC
**** PMathOps
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PMathOps
  (*
   [_ m]
   (let [m ^Matrix32 m]
     (with-meta
       (Matrix32.
        (mm/madd m00 (.-m00 m) m01 (.-m10 m))
        (mm/madd m00 (.-m01 m) m01 (.-m11 m))
        (mm/madd m00 (.-m02 m) m01 (.-m12 m) m02)
        (mm/madd m10 (.-m00 m) m11 (.-m10 m))
        (mm/madd m10 (.-m01 m) m11 (.-m11 m))
        (mm/madd m10 (.-m02 m) m11 (.-m12 m) m12))
       (meta _))))
#+END_SRC
**** PDeterminant
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PDeterminant
  (determinant
   [_] (mm/msub m00 m11 m01 m10))
#+END_SRC
**** PInvert
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PInvert
  (invert
   [_]
   (let [d (determinant _)]
     (when-not (zero? d)
       (Matrix32.
        (mm/div m11 d) (clojure.core/- (mm/div m01 d)) (mm/div (mm/msub m01 m12 m11 m02) d)
        (clojure.core/- (mm/div m10 d)) (mm/div m00 d) (mm/div (mm/msub m10 m02 m00 m12) d)))))
#+END_SRC
**** PRotate, PScale, PTranslate, PTransform
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PRotate
  (rotate
   [_ theta]
   (let [s (Math/sin theta), c (Math/cos theta)]
     (* _ (Matrix32. c (clojure.core/- s) 0.0, s c 0.0))))
  
  PScale
  (scale
   [_ s]
   (* _ (Matrix32.
         (if (number? s) s (s 0)) 0.0 0.0
         0.0 (if (number? s) s (s 1)) 0.0)))
  (scale
   [_ sx sy]
   (if (number? sx)
     (if (number? sy)
       (* _ (Matrix32. sx 0.0 0.0, 0.0 sy 0.0))
       (* _ (Matrix32. (mm/mul sx (sy 0)) 0.0 0.0, 0.0 (mm/mul sx (sy 1)) 0.0)))
     (if (number? sy)
       (* _ (Matrix32. (mm/mul sy (sx 0)) 0.0 0.0, 0.0 (mm/mul sy (sx 1)) 0.0))
       (* _ (Matrix32. (mm/mul (sx 0) (sy 0)) 0.0 0.0, 0.0 (mm/mul (sx 1) (sy 1)) 0.0)))))
  
  PShear
  (shear
   [_ s]
   (* _ (Matrix32.
         1.0 (if (number? s) s (s 0)) 0.0,
         (if (number? s) s (s 1)) 1.0 0.0)))
  (shear
   [_ sx sy]
   (* _ (Matrix32. 1.0 sx 0.0, sy 1.0 0.0)))
  
  PTranslate
  (translate
   [_ t]
   (* _ (Matrix32.
         1.0 0.0 (if (number? t) t (t 0))
         0.0 1.0 (if (number? t) t (t 1)))))
  (translate
   [_ tx ty]
   (if (number? tx)
     (if (number? ty)
       (* _ (Matrix32. 1.0 0.0 tx, 0.0 1.0 ty))
       (* _ (Matrix32. 1.0 0.0 (mm/mul tx (ty 0)), 0.0 1.0 (mm/mul tx (ty 1)))))
     (if (number? ty)
       (* _ (Matrix32. 1.0 0.0 (mm/mul ty (tx 0)), 0.0 1.0 (mm/mul ty (tx 1))))
       (* _ (Matrix32. 1.0 0.0 (mm/mul (tx 0) (ty 0)), 0.0 1.0 (mm/mul (tx 1) (ty 1)))))))
  
  PTransform
  (transform
   [_ matrix] (* _ matrix))
#+END_SRC
**** PVectorTransform
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PVectorTransform
  (transform-vector
   [_ [x y :as v]]
   (Vec2.
    (mm/madd x m00 y m01 m02)
    (mm/madd x m10 y m11 m12)
    (meta v)))
#+END_SRC
**** End of implementations
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  )
#+END_SRC
*** 4x4 Matrix
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defrecord Matrix44
    #+clj  [^double m00 ^double m01 ^double m02 ^double m03
            ^double m10 ^double m11 ^double m12 ^double m13
            ^double m20 ^double m21 ^double m22 ^double m23
            ^double m30 ^double m31 ^double m32 ^double m33]
    #+cljs [m00 m01 m02 m03
            m10 m11 m12 m13
            m20 m21 m22 m23
            m30 m31 m32 m33]
#+END_SRC
**** PMathOps
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PMathOps
  (*
   [_ m]
   (let [^Matrix44 m m]
     (with-meta
       (Matrix44.
        (mm/madd m00 (.-m00 m) m01 (.-m10 m) m02 (.-m20 m) m03 (.-m30 m))
        (mm/madd m00 (.-m01 m) m01 (.-m11 m) m02 (.-m21 m) m03 (.-m31 m))
        (mm/madd m00 (.-m02 m) m01 (.-m12 m) m02 (.-m22 m) m03 (.-m32 m))
        (mm/madd m00 (.-m03 m) m01 (.-m13 m) m02 (.-m23 m) m03 (.-m33 m))
  
        (mm/madd m10 (.-m00 m) m11 (.-m10 m) m12 (.-m20 m) m13 (.-m30 m))
        (mm/madd m10 (.-m01 m) m11 (.-m11 m) m12 (.-m21 m) m13 (.-m31 m))
        (mm/madd m10 (.-m02 m) m11 (.-m12 m) m12 (.-m22 m) m13 (.-m32 m))
        (mm/madd m10 (.-m03 m) m11 (.-m13 m) m12 (.-m23 m) m13 (.-m33 m))
  
        (mm/madd m20 (.-m00 m) m21 (.-m10 m) m22 (.-m20 m) m23 (.-m30 m))
        (mm/madd m20 (.-m01 m) m21 (.-m11 m) m22 (.-m21 m) m23 (.-m31 m))
        (mm/madd m20 (.-m02 m) m21 (.-m12 m) m22 (.-m22 m) m23 (.-m32 m))
        (mm/madd m20 (.-m03 m) m21 (.-m13 m) m22 (.-m23 m) m23 (.-m33 m))
  
        (mm/madd m30 (.-m00 m) m31 (.-m10 m) m32 (.-m20 m) m33 (.-m30 m))
        (mm/madd m30 (.-m01 m) m31 (.-m11 m) m32 (.-m21 m) m33 (.-m31 m))
        (mm/madd m30 (.-m02 m) m31 (.-m12 m) m32 (.-m22 m) m33 (.-m32 m))
        (mm/madd m30 (.-m03 m) m31 (.-m13 m) m32 (.-m23 m) m33 (.-m33 m)))
       (meta _))))
#+END_SRC
**** PDeterminant
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PDeterminant
  (determinant
   [_]
   (reduce
    clojure.core/+
    [(gmc/det-item m30 m21 m12 m03 m20 m31 m12 m03 m30 m11 m22 m03 m10 m31 m22 m03)
     (gmc/det-item m20 m11 m32 m03 m10 m21 m32 m03 m30 m21 m02 m13 m20 m31 m02 m13)
     (gmc/det-item m30 m01 m22 m13 m00 m31 m22 m13 m20 m01 m32 m13 m00 m21 m32 m13)
     (gmc/det-item m30 m11 m02 m23 m10 m31 m02 m23 m30 m01 m12 m23 m00 m31 m12 m23)
     (gmc/det-item m10 m01 m32 m23 m00 m11 m32 m23 m20 m11 m02 m33 m10 m21 m02 m33)
     (gmc/det-item m20 m01 m12 m33 m00 m21 m12 m33 m10 m01 m22 m33 m00 m11 m22 m33)]))
#+END_SRC
**** PInvert
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PInvert
  (invert
   [_]
   (let [n00 (mm/msub m00 m11 m01 m10)
         n01 (mm/msub m00 m12 m02 m10)
         n02 (mm/msub m00 m13 m03 m10)
         n03 (mm/msub m01 m12 m02 m11)
         n04 (mm/msub m01 m13 m03 m11)
         n05 (mm/msub m02 m13 m03 m12)
         n06 (mm/msub m20 m31 m21 m30)
         n07 (mm/msub m20 m32 m22 m30)
         n08 (mm/msub m20 m33 m23 m30)
         n09 (mm/msub m21 m32 m22 m31)
         n10 (mm/msub m21 m33 m23 m31)
         n11 (mm/msub m22 m33 m23 m32)
         d (mm/add
            (mm/sub
             (mm/add
              (mm/add
               (mm/msub n00 n11 n01 n10)
               (mm/mul n02 n09))
              (mm/mul n03 n08))
             (mm/mul n04 n07))
            (mm/mul n05 n06))]
     (when-not (zero? d)
       (let [invd (mm/div 1.0 d)]
         (with-meta
           (Matrix44.
            (gmc/inv-item m11 n11 m12 n10 m13 n09 invd)
            (gmc/inv-item m02 n10 m03 n09 (clojure.core/- m01) n11 invd)
            (gmc/inv-item m31 n05 m32 n04 m33 n03 invd)
            (gmc/inv-item m22 n04 m23 n03 (clojure.core/- m21) n05 invd)
            (gmc/inv-item m12 n08 m13 n07 (clojure.core/- m10) n11 invd)
            (gmc/inv-item m00 n11 m02 n08 m03 n07 invd)
            (gmc/inv-item m32 n02 m33 n01 (clojure.core/- m30) n05 invd)
            (gmc/inv-item m20 n05 m22 n02 m23 n01 invd)
            (gmc/inv-item m10 n10 m11 n08 m13 n06 invd)
            (gmc/inv-item m01 n08 m03 n06 (clojure.core/- m00) n10 invd)
            (gmc/inv-item m30 n04 m31 n02 m33 n00 invd)
            (gmc/inv-item m21 n02 m23 n00 (clojure.core/- m20) n04 invd)
            (gmc/inv-item m11 n07 m12 n06 (clojure.core/- m10) n09 invd)
            (gmc/inv-item m00 n09 m01 n07 m02 n06 invd)
            (gmc/inv-item m31 n01 m32 n00 (clojure.core/- m30) n03 invd)
            (gmc/inv-item m20 n03 m21 n01 m22 n00 invd))
           (meta _))))))
#+END_SRC
**** PTranspose
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
    PTranspose
    (transpose
     [_]
     (with-meta
       (Matrix44.
        m00 m10 m20 m30
        m01 m11 m21 m31
        m02 m12 m22 m32
        m03 m13 m23 m33)
       (meta _)))
#+END_SRC
**** Transformations
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PScale
  (scale
   [_ s]
   (let [[x y z] (if (number? s) [s s s] s)]   
     (* _ (assoc M44 :m00 x :m11 y :m22 z))))
  (scale
   [_ x y z]
   (* _ (assoc M44 :m00 x :m11 y :m22 z))) ;; TODO add scale vec support
  
  PRotate
  (rotate
   [_ theta] (rotate-z _ theta))
  
  PRotate3D
  (rotate-x
   [_ theta]
   (let [s (Math/sin theta), c (Math/cos theta)]
     (* _ (assoc M44 :m11 c :m12 (clojure.core/- s) :m21 s :m22 c))))
  (rotate-y
   [_ theta]
   (let [s (Math/sin theta), c (Math/cos theta)]
     (* _ (assoc M44 :m00 c :m02 s :m20 (clojure.core/- s) :m22 c))))
  (rotate-z
   [_ theta]
   (let [s (Math/sin theta), c (Math/cos theta)]
     (* _ (assoc M44 :m00 c :m01 (clojure.core/- s) :m10 s :m11 c))))
  (rotate-around-axis
   [_ [x y z] theta]
   (let [theta (clojure.core/- theta)
         s (Math/sin theta), c (Math/cos theta)
         sx (mm/mul s x)
         sy (mm/mul s y)
         sz (mm/mul s z)
         t (mm/sub 1.0 c)
         tx (mm/mul t x)
         ty (mm/mul t y)]
     (* _
        (Matrix44.
         (mm/madd tx x c) (mm/madd tx y sz) (mm/msub tx z sy) 0.0
         (mm/msub tx y sz) (mm/madd ty y c) (mm/madd ty z sx) 0.0
         (mm/madd tx z sy) (mm/msub ty z sx) (mm/madd (mm/mul t z) z c) 0.0
         0.0 0.0 0.0 1.0))))
  
  PTranslate
  (translate
   [_ t]
   (let [[x y z] (if (number? t) [t t t] t)]   
     (* _ (assoc M44 :m03 x :m13 y :m23 z))))
  (translate
   [_ x y z]
   (* _ (assoc M44 :m03 x :m13 y :m23 z)))
  
  PTransform
  (transform
   [_ matrix] (* _ matrix))
#+END_SRC
**** PVectorTransform
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PVectorTransform
  (transform-vector
   [_ [x y z w :as v]]
   (if (= 3 (count v))
     (vec3 (mm/madd x m00 y m01 z m02 m03)
           (mm/madd x m10 y m11 z m12 m13)
           (mm/madd x m20 y m21 z m22 m23))
     [(mm/madd x m00 y m01 z m02 w m03)
      (mm/madd x m10 y m11 z m12 w m13)
      (mm/madd x m20 y m21 z m22 w m23)
      (mm/madd x m30 y m31 z m32 w m33)]))
#+END_SRC
**** End of implementation
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
    )
#+END_SRC
*** Constants
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (def ^:const M32
    (Matrix32.
     1.0 0.0 0.0
     0.0 1.0 0.0))

  (def ^:const M44
    (Matrix44.
     1.0 0.0 0.0 0.0
     0.0 1.0 0.0 0.0
     0.0 0.0 1.0 0.0
     0.0 0.0 0.0 1.0))
#+END_SRC
*** Constructors
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defn matrix32
    ([] M32)
    ([[m00 m01 m02 m10 m11 m12]]
       (Matrix32. m00 m01 m02 m10 m11 m12))
    ([m00 m01 m02 m10 m11 m12]
       (Matrix32. m00 m01 m02 m10 m11 m12)))

  (defn matrix44
    ([] M44)
    ([[m00 m01 m02 m03 m10 m11 m12 m13 m20 m21 m22 m23 m30 m31 m32 m33]]
       (Matrix44. m00 m01 m02 m03 m10 m11 m12 m13 m20 m21 m22 m23 m30 m31 m32 m33))
    ([m00 m01 m02 m03 m10 m11 m12 m13 m20 m21 m22 m23 m30 m31 m32 m33]
       (Matrix44. m00 m01 m02 m03 m10 m11 m12 m13 m20 m21 m22 m23 m30 m31 m32 m33)))
#+END_SRC
** Quaternion
*** Implementation
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (deftype Quat4
    ,#+clj  [^double x ^double y ^double z ^double w _meta]
    ,#+cljs [x y z w _meta]
#+END_SRC
**** Clojure protocols
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
    ,#+clj clojure.lang.IObj
    ,#+clj (meta [_] _meta)
    ,#+clj (withMeta [_ m*] (Quat4. x y z w m*))
    ,#+cljs IMeta
    ,#+cljs (-meta [_] _meta)
    ,#+cljs IWithMeta
    ,#+cljs (-with-meta [_ m*] (Quat4. x y z w m*))

    Object
    (toString [_] (str "[" x " " y " " z " " w "]"))
#+END_SRC
**** PScale
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PScale
  (scale
   [_ s]
   (Quat4. (mm/mul x s) (mm/mul y s) (mm/mul z s) (mm/mul w s) _meta))
#+END_SRC
**** PRotate3D
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PRotate3D
  (rotate-x
   [_ theta]
   (let [t (mm/div theta 2.0)
         s (Math/sin t) c (Math/cos t)]
     (Quat4.
      (mm/madd x c w s)
      (mm/madd y c z s)
      (mm/msub z c y s)
      (mm/msub w c x s) _meta)))
  (rotate-y
   [_ theta]
   (let [t (mm/div theta 2.0)
         s (Math/sin t) c (Math/cos t)]
     (Quat4.
      (mm/msub x c z s)
      (mm/madd y c w s)
      (mm/madd z c x s)
      (mm/msub w c y s) _meta)))
  (rotate-z
   [_ theta]
   (let [t (mm/div theta 2.0)
         s (Math/sin t) c (Math/cos t)]
     (Quat4.
      (mm/madd x c y s)
      (mm/msub y c x s)
      (mm/madd z c w s)
      (mm/msub w c z s) _meta)))
#+END_SRC
**** PMathOps
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PMathOps
  (+
   [_ q]
   (let [q ^Quat4 q]
     (Quat4.
      (mm/add x (.-x q))
      (mm/add y (.-y q))
      (mm/add z (.-z q))
      (mm/add w (.-w q)) _meta)))
  (-
   [_ q]
   (let [q ^Quat4 q]
     (Quat4.
      (mm/sub x (.-x q))
      (mm/sub y (.-y q))
      (mm/sub z (.-z q))
      (mm/sub w (.-w q)) _meta)))
  (*
   [_ q]
   (let [q ^Quat4 q
         qx (.-x q) qy (.-y q) qz (.-z q) qw (.-w q)]
     (Quat4.
      (mm/maddsub x qw w qx y qz z qy)
      (mm/maddsub y qw w qy z qx x qz)
      (mm/maddsub z qw w qz x qy y qx)
      (mm/msub w qw x qx y qy z qz)
      _meta)))
  (*
   [_ q r]
   (let [q ^Quat4 q r ^Quat4 r
         qx (.-x q) qy (.-y q) qz (.-z q) qw (.-w q)
         rx (.-x r) ry (.-y r) rz (.-z r) rw (.-w r)
         x' (mm/maddsub x qw w qx y qz z qy)
         y' (mm/maddsub y qw w qy z qx x qz)
         z' (mm/maddsub z qw w qz x qy y qx)
         w' (mm/msub w qw x qx y qy z qz)]
     (Quat4.
      (mm/maddsub x' rw w' rx y' rz z' ry)
      (mm/maddsub y' rw w' ry z' rx x' rz)
      (mm/maddsub z' rw w' rz x' ry y' rx)
      (mm/msub w' rw x' rx y' ry z' rz)
      _meta)))
#+END_SRC
**** PDotProduct
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PDotProduct
  (dot
   [_ q]
   (let [q ^Quat4 q]
     (mm/madd x (.-x q) y (.-y q) z (.-z q) w (.-w q))))
#+END_SRC
**** PMagnitude
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PMagnitude
  (mag
   [_] (Math/sqrt (mm/madd x x y y z z w w)))
  (mag-squared
   [_] (mm/madd x x y y z z w w))
#+END_SRC
**** PNormalize
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PNormalize
  (normalize [_]
    (let [m (Math/sqrt (mm/madd x x y y z z w w))]
      (if (> m *eps*)
        (Quat4. (mm/div x m) (mm/div y m) (mm/div z m) (mm/div w m) _meta)
        _)))
#+END_SRC
**** PConjugate
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PConjugate
  (conjugate [_]
    (Quat4. (clojure.core/- x) (clojure.core/- y) (clojure.core/- z) w _meta))
#+END_SRC
**** PInvert
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PInvert
  (invert [_]
    (let [d (mag-squared _)
          d (if (zero? d) 0.0 (clojure.core// d))
          id (clojure.core/- d)]
      (Quat4. (mm/mul x id) (mm/mul y id) (mm/mul z id) (mm/mul w d) _meta)))
#+END_SRC
**** PInterpolate
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PInterpolate
  (mix [_ q] (mix _ q 0.5))
  (mix [_ q t]
    (let [d (dot _ q)]
      (if (< (m/abs d) 1.0)
        (let [theta (Math/acos d)
              stheta (Math/sqrt (mm/madd d d -1.0))
              [a b] (if (< (m/abs stheta) 0.001)
                      [0.5 0.5]
                      [(mm/div (Math/sin (mm/subm 1.0 t theta)) stheta)
                       (mm/div (Math/sin (mm/mul t theta)) stheta)])
              q ^Quat4 q]
          (Quat4.
           (mm/madd x a (.-x q) b)
           (mm/madd y a (.-y q) b)
           (mm/madd z a (.-z q) b)
           (mm/madd w a (.-w q) b)
           _meta))
        _)))
#+END_SRC
**** PMatrixConvert
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PMatrixConvert
  (as-matrix
   [_]
   (let [x2 (mm/add x x)
         y2 (mm/add y y)
         z2 (mm/add z z)
         xx (mm/mul x x2)
         yx (mm/mul y x2)
         yy (mm/mul y y2)
         zx (mm/mul z x2)
         zy (mm/mul z y2)
         zz (mm/mul z z2)
         wx (mm/mul w x2)
         wy (mm/mul w y2)
         wz (mm/mul w z2)]
     (Matrix44.
      (mm/sub 1.0 yy zz) ;m00
      (mm/sub yx wz)     ;m10
      (mm/add zx wy)     ;m20
      0.0
      (mm/add yx wz)     ;m01
      (mm/sub 1.0 xx zz) ;m11
      (mm/sub zy wx)     ;m21
      0.0
      (mm/sub zx wy)     ;m02
      (mm/add zy wx)     ;m12
      (mm/sub 1.0 xx yy) ;m22
      0.0
      0.0 0.0 0.0 1.0)))
#+END_SRC
**** PVectorTransform
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  PVectorTransform
  (transform-vector
   [_ [vx vy vz :as v]]
   (let [ix (mm/maddsub w vx y vz z vy)
         iy (mm/maddsub w vy z vx x vz)
         iz (mm/maddsub w vz x vy y vx)
         nx (clojure.core/- x) ny (clojure.core/- y) nz (clojure.core/- z)
         iw (mm/msub nx vx y vy z vz)]
     (Vec3.
      (mm/maddsub ix w iw nx iy nz iz ny)
      (mm/maddsub iy w iw ny iz nx ix nz)
      (mm/maddsub iz w iw nz ix ny iy nx)
      (meta v))))
#+END_SRC
**** End of implementation
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
    )
#+END_SRC
**** Override print methods
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  #+clj (defmethod print-method Quat4 [o ^java.io.Writer w] (.write w (.toString o)))
#+END_SRC
*** Constructors
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defn quat
    ([] (Quat4. 0.0 0.0 0.0 1.0 nil))
    ([[x y z] w] (Quat4. x y z w nil))
    ([[x y z w]] (Quat4. x y z w nil))
    ([x y z w] (Quat4. x y z w nil)))
  
  (defn quat-from-axis-angle
    [axis theta]
    (let [theta (mm/mul theta 0.5)]
      (quat (normalize (vec3 axis) (Math/sin theta)) (Math/cos theta))))
  
  (defn quat-from-euler
    [order & [alpha beta gamma]]
    (let [[a b c] (case order
                    :xyz [V3X V3Y V3Z]
                    :yxz [V3Y V3X V3Z]
                    :xzy [V3X V3Z V3Y]
                    :zxy [V3Z V3X V3Y]
                    :yzx [V3Y V3Z V3X]
                    :zyx [V3Z V3Y V3X]
                    (err/illegal-arg! order))]
      (* (quat-from-axis-angle a alpha)
         (quat-from-axis-angle b beta)
         (quat-from-axis-angle c gamma))))
  
  ;; Allan and Mark Watt's "Advanced Animation and Rendering Techniques"
  ;; (ACM Press 1992)
  (defn quat-from-m44
    [^Matrix44 m]
    (let [trace (mm/add (.-m00 m) (.-m11 m) (.-m22 m))]
      (if (pos? trace)
        (let [s (Math/sqrt (mm/add 1.0 trace))
              w (mm/div s 2.0)
              s (mm/div 0.5 s)]
          (Quat4.
           (mm/subm (.-m21 m) (.-m12 m) s)
           (mm/subm (.-m02 m) (.-m20 m) s)
           (mm/subm (.-m10 m) (.-m01 m) s)
           w nil))
        (let [[i ii] (if (> (.-m11 m) (.-m00 m))
                       [1 (.-m11 m)] [0 (.-m00 m)])
              [i ii] (if (> (.-m22 m) ii)
                       [2 (.-m22 m)] [i ii])
              [jj kk jk kj ij ji ik ki]
              (case i
                0 [(.-m11 m) (.-m22 m) (.-m12 m) (.-m21 m) (.-m01 m) (.-m10 m) (.-m02 m) (.-m20 m)]
                1 [(.-m22 m) (.-m00 m) (.-m20 m) (.-m02 m) (.-m12 m) (.-m21 m) (.-m10 m) (.-m01 m)]
                2 [(.-m00 m) (.-m11 m) (.-m01 m) (.-m10 m) (.-m20 m) (.-m02 m) (.-m21 m) (.-m12 m)])
              s (Math/sqrt (inc (mm/sub ii (mm/add jj kk))))
              x (mm/div s 2.0)
              s (mm/div 0.5 s)
              qj (mm/addm ij ji s)
              qk (mm/addm ik ki s)
              qw (mm/subm kj jk s)]
          (case i
            0 (Quat4. x qj qk qw nil)
            1 (Quat4. qk x qj qw nil)
            2 (Quat4. qj qk x qw nil))))))
  
  (defn alignment-quat
    [a b]
    (let [d (dot a b)]
      (cond
       (< d -0.999999) (let [c (cross V3X a)
                             c (if (< (mag c) 1e-6) (cross V3Y a) c)]
                         (quat-from-axis-angle c PI))
       (> d 0.999999) (quat)
       :default (normalize (quat (cross a b) (inc d))))))
#+END_SRC
** Constants
*** Default circle resolution
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (def ^:dynamic *resolution* 20)
#+END_SRC
**** TODO Binding macro
#+BEGIN_SRC clojure
  ;; :tangle ../babel/src-cljs/thi/ng/geom/macros.clj
  (defmacro with-resolution
    [res & body]
    (binding [*resolution* res] ~@body))
#+END_SRC
** Shared functions
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx :mkdirp yes :padline no
  (defn closest-point*
    [lines q]
    (reduce (fn [a b]
              (if (< (dist-squared q a) (dist-squared q b)) a b))
            (map #(closest-point % q) lines)))
  
  (defn from-barycentric*
    [points weights]
    (reduce + (map * points weights)))
  
  (defn centroid*
    [[x & xs :as coll]]
    (case (count coll)
      0 nil
      1 x
      2 (mix x (first xs))
      3 (div (+ x (nth xs 0) (nth xs 1)) 3.0)
      4 (addm (+ x (first xs) (nth xs 1)) (nth xs 2) 0.25)
      (* ((if (instance? Vec2 x) vec2-op-seq vec3-op-seq) clojure.core/+ x xs)
         (clojure.core// (count coll)))))
  
  (defn center*
    ([coll]
       (let [c (centroid* coll)] (mapv #(- % c) coll)))
    ([c' coll]
       (center* (centroid* coll) c' coll))
    ([c c' coll]
       (let [d (- c' c)] (mapv #(+ % d) coll))))
  
  (defn scale-size*
    ([s coll] (scale-size* (centroid* coll) s coll))
    ([c s coll] (mapv #(-> % (- c) (madd s c)) coll)))
  
  (defn bounding-rect*
    ([[x & xs :as coll]]
       (let [c (count coll)]
         (cond
          (> c 1) (let [p (vec2-op-seq clojure.core/min x xs)
                        q (vec2-op-seq clojure.core/max x xs)
                        [w h] (- q p)]
                    (thi.ng.geom.types.Rect. p w h))
          (= c 1) (thi.ng.geom.types.Rect. x 0.0 0.0)
          :default nil)))
    ([p w h] (thi.ng.geom.types.Rect. p w h)))
  
  (defn bounding-box*
    ([[x & xs :as coll]]
       (let [c (count coll)]
         (cond
          (> c 1) (let [p (vec3-op-seq clojure.core/min x xs)
                        q (vec3-op-seq clojure.core/max x xs)]
                    (thi.ng.geom.types.AABB. p (- q p)))
          (= c 1) (thi.ng.geom.types.AABB. x (vec3))
          :default nil)))
    ([p q] (thi.ng.geom.types.AABB. p (- q p))))
  
  (defn max-dist*
    [c points]
    (->> points
         (map #(dist-squared c %))
         (reduce clojure.core/max)
         (Math/sqrt)))
  
  (defn bounding-circle*
    [c r-or-points]
    (thi.ng.geom.types.Circle.
     (vec2 c)
     (if (coll? r-or-points)
       (max-dist* c r-or-points)
       r-or-points)))
  
  (defn bounding-sphere*
    [c r-or-points]
    (thi.ng.geom.types.Sphere.
     (vec3 c)
     (if (coll? r-or-points)
       (max-dist* c r-or-points)
       r-or-points)))
  
  (defn axis-bounds*
    [axis coll]
    (let [xs (map #(nth % axis) coll)]
      [(reduce clojure.core/min xs) (reduce clojure.core/max xs)]))
  
  (defn axis-range*
    [axis coll]
    (let [xs (map #(nth % axis) coll)]
      (mm/sub (reduce clojure.core/max xs) (reduce clojure.core/min xs))))
  
  (defn arc-length-index*
    [points]
    (->> points
         (d/successive-nth 2)
         (map #(dist (% 0) (% 1)))
         (reductions clojure.core/+ 0)
         (vec)))
  
  (defn arc-length*
    [points]
    (d/reduce-pairs clojure.core/+ dist points))
  
  (defn sample-uniform*
    [udist include-last? points]
    (let [idx (arc-length-index* points)
          total (peek idx)
          delta (mm/div udist total)
          samples (loop [t 0.0, i 1, acc []]
                    (if (< t 1.0)
                      (let [ct (mm/mul t total)
                            i (int (loop [i i] (if (>= ct (idx i)) (recur (inc i)) i)))
                            pi (idx (dec i))]
                        (recur (mm/add t delta) i
                               (conj acc
                                     (mix (nth points (dec i)) (nth points i)
                                          (mm/subdiv ct pi (idx i) pi)))))
                      acc))]
      (if include-last?
        (conj samples (last points))
        samples)))
  
  (defn point-at*
    ([t points] (point-at* t points nil))
    ([t points idx]
       (when (m/in-range? 0.0 1.0 t)
         (let [n (count points)
               t (double t)]
           (cond
            (== 0 n) nil
            (== 1 n) (first points)
            (== 1.0 t) (last points)
            :default (let [idx (or idx (arc-length-index* points))
                           total (peek idx)
                           ct (mm/mul t total)
                           i (int (loop [i 1] (if (>= ct (idx i)) (recur (inc i)) i)))
                           pi (idx (dec i))]
                       (mix (nth points (dec i)) (nth points i)
                            (mm/subdiv ct pi (idx i) pi))))))))
  
  (defn edges*
    [ctor points]
    (->> points (d/successive-nth 2) (mapv ctor)))
  
  (defn tessellate*
    ([points] (tessellate* (centroid* points) points))
    ([c points]
       (->> [(first points)]
            (concat points)
            (d/successive-nth 2)
            (map #(vector c (% 0) (% 1))))))
  
  (defn normal3*
    ([a b c] (normalize (cross (- b a) (- c a))))
    ([[a b c]] (normalize (cross (- b a) (- c a)))))
#+END_SRC
** Matrix functions
#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/core.cljx
  (defn frustum
    "Sets up a viewing frustum, shaped like a truncated pyramid with the
    camera where the tip of the pyramid would be.
    This emulates the OpenGL function glFrustum()."
    [l t r b n f]
    (let [dx (mm/sub r l)
          dy (mm/sub t b)
          dz (mm/sub f n)]
      (Matrix44.
       (mm/div (mm/mul 2.0 n) dx) 0.0 (mm/adddiv r l dx) 0.0
       0.0 (mm/div (mm/mul 2.0 n) dy) (mm/adddiv t b dy) 0.0
       0.0 0.0 (clojure.core/- (mm/adddiv f n dz)) (mm/div (mm/mul -2.0 f n) dz)
       0.0 0.0 -1.0 0.0)))
  
  (defn frustum-bounds
    [fov aspect near]
    (let [rad (mm/mul 0.5 (m/radians fov))
          top (mm/mul near (Math/tan rad))
          right (mm/mul top aspect)]
      {:left (clojure.core/- right)
       :right right
       :top top
       :bottom (clojure.core/- top)}))
  
  (defn ortho
    "Returns an orthographic projection matrix, in which objects are the same size no
    matter how far away or nearby they are.
    This emulates the OpenGL function glOrtho()."
    [l t r b n f]
    (let[dx (mm/sub r l)
         dy (mm/sub t b)
         dz (mm/sub f n)]
      (Matrix44.
       (mm/div 2.0 dx) 0.0 0.0 (clojure.core/- (mm/adddiv r l dx))
       0.0 (mm/div 2.0 dy) 0.0 (clojure.core/- (mm/adddiv t b dy))
       0.0 0.0 (mm/div -2.0 dz) (clojure.core/- (mm/adddiv f n dz))
       0.0 0.0 0.0 1.0)))
  
  (defn perspective
    "Returns a perspective transform matrix, which makes far away objects appear
    smaller than nearby objects. The `aspect` argument should be the width
    divided by the height of your viewport and `fov` is the vertical angle
    of the field of view in degrees.
    This emulates the OpenGL function gluPerspective()."
    [fov aspect near far]
    (let [rad (mm/mul 0.5 (m/radians fov))
          cot (mm/div (Math/cos rad) (Math/sin rad))
          deltaz (mm/sub far near)
          a (mm/div cot aspect)
          b (clojure.core/- (mm/adddiv far near deltaz))
          c (mm/div (mm/mul -2.0 near far) deltaz)]
      (Matrix44.
       a 0.0 0.0 0.0
       0.0 cot 0.0 0.0
       0.0 0.0 b c
       0.0 0.0 -1.0 0.0)))
  
  (defn perspective-frustum
    [fov aspect near far]
    (let [{:keys [left right top bottom]} (frustum-bounds fov aspect near)]
      (frustum left top right bottom near far)))
  
  (defn look-at
    "Returns a matrix that puts the camera at the eye position looking
    toward the target point with the given up direction.
    This emulates the OpenGL function `gluLookAt()`."
    [eye target upvec]
    (let [[fx fy fz :as f] (normalize (- eye target))
          [sx sy sz :as s] (normalize (cross upvec f))
          [tx ty tz :as t] (normalize (cross f s))]
      (Matrix44.
       sx sy sz (clojure.core/- (dot s eye))
       tx ty tz (clojure.core/- (dot t eye))
       fx fy fz (clojure.core/- (dot f eye))
       0.0 0.0 0.0 1.0)))
  
  (defn unproject
    "Takes a vec3 in screenspace, view matrix, projection matrix and
    view rect. Returns vector in model space or nil."
    [v vmat pmat {:keys [p width height]}]
    (let [x (mm/msub (mm/sub (v 0) (p 0)) (mm/div 2.0 width) 1.0)
          y (mm/msub (mm/sub (v 1) (p 1)) (mm/div 2.0 height) 1.0)
          z (mm/msub (v 2) 2.0 1.0)
          vpm (* pmat vmat)]
      (if (invert vpm)
        (let [v' (transform-vector vpm [x y z 1.0])]
          (if-not (zero? (v' 3))
            (div (vec3 v') (v' 3)))))))
#+END_SRC
