#+SEQ_TODO:       TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:           write(w) update(u) fix(f) verify(v) noexport(n)
#+EXPORT_EXCLUDE_TAGS: noexport

* thi.ng.geom.sphere
** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/sphere.cljx
  (ns thi.ng.geom.sphere
    #+cljs (:require-macros [thi.ng.macromath.core :as mm])
    (:require
     #+clj [thi.ng.macromath.core :as mm]
     [thi.ng.common.math.core :as m :refer [TWO_PI PI *eps*]]
     [thi.ng.geom.core :as g :refer [vec3 *resolution*]]
     [thi.ng.geom.gmesh :as gm]
     [thi.ng.geom.types :as types])
    ,#+clj
    (:import
     [thi.ng.geom.types Line3 AABB Sphere]))
#+END_SRC
** Constructor
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/sphere.cljx
  (defn sphere
    ([] (thi.ng.geom.types.Sphere. (vec3) 1.0))
    ([r] (thi.ng.geom.types.Sphere. (vec3) #+clj (double r) #+cljs r))
    ([p r] (thi.ng.geom.types.Sphere. (vec3 p) #+clj (double r) #+cljs r)))
#+END_SRC
** Type specific functions
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/sphere.cljx

#+END_SRC
** Protocol implementations
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/sphere.cljx
  (extend-type thi.ng.geom.types.Sphere
#+END_SRC
*** PArea
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/sphere.cljx
  g/PArea
  (area
   [{r :r}] (* 4.0 PI r r))
#+END_SRC
*** PBounds
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/sphere.cljx
  g/PBounds
  (bounds
   [_] (thi.ng.geom.types.AABB. (g/- (:p _) (:r _)) (vec3 (* 2 (:r _)))))
  (width  [_] (* 2.0 (:r _)))
  (height [_] (* 2.0 (:r _)))
  (depth  [_] (* 2.0 (:r _)))
#+END_SRC
*** PBoundingSphere
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/sphere.cljx
  g/PBoundingSphere
  (bounding-sphere [_] _)
#+END_SRC
*** PBoundary
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/sphere.cljx
  g/PBoundary
  (contains-point?
   [{p :p r :r} q] (<= (g/dist-squared p q) (* r r)))
  g/PClassify
  (classify-point
   [{p :p r :r} q]
   (m/signum (- (* r r) (g/dist-squared p q)) *eps*))
  g/PSample
  (random-point-inside
   [_]
   (g/+ (:p _) (g/randvec3 (m/random (:r _)))))
  (random-point
   [_]
   (g/+ (:p _) (g/randvec3 (:r _))))
#+END_SRC
*** PCenter
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/sphere.cljx
  g/PCenter
  (center
   ([_] (thi.ng.geom.types.Sphere. (vec3) (:r _)))
   ([_ p] (thi.ng.geom.types.Sphere. (vec3 p) (:r _))))
  (centroid [_] (:p _))
#+END_SRC
*** TODO PGraph
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/sphere.cljx

#+END_SRC
*** TODO PMeshConvert
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/sphere.cljx
  g/PMeshConvert
  (as-mesh
   ([_] (g/as-mesh _ {}))
   ([{[x y z] :o r :r} {:keys [res slices stacks] :or {res *resolution*}}]
      (let [slices (or slices res), stacks (or stacks res)
            range-u (range slices), range-v (range stacks)]
        (->> (for [i range-u, j range-v
                   :let [u (/ i slices)
                         v (/ j stacks)
                         u1 (/ (inc i) slices)
                         v1 (/ (inc j) stacks)
                         verts [[u v]]
                         verts (if (pos? j) (conj verts [u1 v]) verts)
                         verts (if (< j (dec stacks)) (conj verts [u1 v1]) verts)]]
               (conj verts [u v1]))
             (reduce
              (fn [m verts]
                (->> verts
                     (map
                      (fn [[u v]]
                        (let [theta (* TWO_PI u) ;; FIXME optimize trig
                              phi (* PI v)
                              st (Math/sin theta) ct (Math/cos theta)
                              sp (Math/sin phi) cp (Math/cos phi)]
                          (vec3
                           (+ (mm/mul ct sp r) x)
                           (mm/madd cp r y)
                           (+ (mm/mul st sp r) z)))))
                     (g/add-face m)))
              (gm/gmesh))))))
#+END_SRC
*** PVolume
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/sphere.cljx
  g/PVolume
  (volume [{r :r}] (mm/mul (/ 4.0 3.0) PI r r r))
#+END_SRC
*** End of implementation                                          :noexport:
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/sphere.cljx
  )
#+END_SRC


