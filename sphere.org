#+SEQ_TODO:       TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:           Write(w) Update(u) Fix(f) Check(c) noexport(n)
#+EXPORT_EXCLUDE_TAGS: noexport

* thi.ng.geom.sphere
** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/sphere.cljx
  (ns thi.ng.geom.sphere
    (:refer-clojure :exclude [* - +])
    (:refer-clojure :rename {+ c+, - c-, * c*})
    (:require
     [thi.ng.common.math.core :as m :refer [PI *eps*]]
     [thi.ng.geom.core :as g :refer [+ - * vec3 *resolution*]]
     [thi.ng.geom.mesh :as mesh]
     [thi.ng.geom.types :as types])
    ,#+clj
    (:import
     [thi.ng.geom.types Line3 AABB Sphere]))
#+END_SRC
** Constructor
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/sphere.cljx
  (defn sphere
    ([] (thi.ng.geom.types.Sphere. (vec3) 1.0))
    ([r] (thi.ng.geom.types.Sphere. (vec3) #+clj (double r) #+cljs r))
    ([p r] (thi.ng.geom.types.Sphere. (vec3 p) #+clj (double r) #+cljs r)))
#+END_SRC
** Type specific functions
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/sphere.cljx

#+END_SRC
** Protocol implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/sphere.cljx
  (extend-type thi.ng.geom.types.Sphere
#+END_SRC
*** TODO PGraph
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/sphere.cljx

#+END_SRC
*** PArea
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/sphere.cljx
  g/PArea
  (area
   [{r :r}] (c* 4.0 PI r r))
#+END_SRC
*** PBounds
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/sphere.cljx
  g/PBounds
  (bounds
   [this] (thi.ng.geom.types.AABB. (:p this) (vec3 (:r this))))
  (width  [this] (c* 2.0 (:r this)))
  (height [this] (c* 2.0 (:r this)))
  (depth  [this] (c* 2.0 (:r this)))
#+END_SRC
*** PCenter
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/sphere.cljx
  g/PCenter
  (center
   ([this] (thi.ng.geom.types.Sphere. (vec3) (:r this)))
   ([this p] (thi.ng.geom.types.Sphere. p (:r this))))
  (centroid [this] (:p this))
#+END_SRC
*** PBoundingSphere
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/sphere.cljx
  g/PBoundingSphere
  (bounding-sphere [this] this)
#+END_SRC
*** PVolume
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/sphere.cljx
  g/PVolume
  (volume [{r :r}] (* (/ 4.0 3.0) PI r r r))
#+END_SRC
*** PBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/sphere.cljx
  g/PBoundary
  (contains-point?
   [{p :p r :r} q] (<= (g/dist-squared p q) (c* r r)))
  g/PClassify
  (classify-point
   [{p :p r :r} q]
   (m/signum (c- (c* r r) (g/dist-squared p q)) *eps*))
  g/PSampleable
  (random-point-inside
   [this]
   (+ (:p this) (g/randvec3 (m/random (:r this)))))
  (random-point
   [this]
   (+ (:p this) (g/randvec3 (:r this))))
#+END_SRC
*** TODO PMeshable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/sphere.cljx
  g/PMeshable
  (as-mesh
   ([this] (g/as-mesh this *resolution*))
   ([this res] nil))
#+END_SRC
*** End of implementation                                          :noexport:
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/sphere.cljx
  )
#+END_SRC


