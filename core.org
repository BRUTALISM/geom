#+SEQ_TODO:       TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:           Write(w) Update(u) Fix(f) Check(c) noexport(n)
#+EXPORT_EXCLUDE_TAGS: noexport

* Namespace: thi.ng.geom.core
  Providing an easy-to-use & easy-to-learn API for both common and
  advanced geometry operations is one of this project's main focal
  points. We attempt to realise this by defining all operations in
  the form of protocols which are then implemented by various core
  types.

  This namespace contains all basic vector operations and core
  protocols related to common higher level geometric operations.

#+INCLUDE: "types.org" :minlevel 3

** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx :mkdirp yes :padline no
  (ns thi.ng.geom.core
    (:refer-clojure :exclude [* - + min max])
    (:require
     [thi.ng.common.data.core :as d]
     [thi.ng.common.error :as err]
     [thi.ng.common.math.core :as m :refer [*eps* PI TWO_PI]]
     [thi.ng.geom.types :as types]
    #+clj [thi.ng.geom.macros.core :as mc])
    #+cljs (:require-macros [thi.ng.geom.macros.core :as mc])
    #+clj
    (:import
     [thi.ng.geom.types Circle Rect AABB Sphere]))
#+END_SRC
** Core implementations
*** Protocols
**** Math operations
***** PMathOps
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PMathOps
    (+ [_] [_ a] [_ a b] [_ a b c])
    (- [_] [_ a] [_ a b] [_ a b c])
    (* [_] [_ a] [_ a b] [_ a b c])
    (div [_] [_ a] [_ a b] [_ a b c])
    (madd [_ a b])
    (abs [_]))
#+END_SRC
***** PSetOps
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PSetOps
    (union [_ x])
    (intersection [_ y])
    (difference [_ x]))
#+END_SRC
***** PDotProduct
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PDotProduct
    (dot [_ a]))
#+END_SRC
***** PCrossProduct
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PCrossProduct
    (cross [_ a]))
#+END_SRC
***** PLimit
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PLimit
    (limit [_ x]))
#+END_SRC
***** PMinMax
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PMinMax
    (min [_ x] [_ a b])
    (max [_ y] [_ a b]))
#+END_SRC
***** PTranspose
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PTranspose
    (transpose [_]))
#+END_SRC
***** PNormalize
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PNormalize
    (normalize [_] [_ len])
    (normalized? [_]))
#+END_SRC
***** PInterpolate
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PInterpolate
    (mix [_ x] [_ x t]))
#+END_SRC
***** PMagnitude
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PMagnitude
    (mag [_])
    (mag-squared [_]))
#+END_SRC
***** PDistance
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PDistance
    (dist [_ a])
    (dist-squared [_ a]))
#+END_SRC
***** PHeading
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PHeading
    (heading-xy [_])
    (heading-xz [_])
    (heading-yz [_])
    (angle-between [_ a])
    (normal [_] [_ a])
    (slope-xy [_])
    (slope-xz [_])
    (slope-yz [_]))
#+END_SRC
***** PMatrix
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PMatrix
    (set-position [_ p] [_ x y])
    (set-scale [_ s] [_ sx sy])
    (set-rotation [_ r])
    (set-shear [_ s] [_ sx sy])
    (determinant [_]))
#+END_SRC
***** PQuaternion
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PQuaternion
    (conjugate [_]))
#+END_SRC
***** PMatrixConvert
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PMatrixConvert
    (as-matrix [_]))
#+END_SRC
**** Spatial transform operations
     The position, size and orientation of spatial entities can
     usually be manipulated via the three basic operations: rotate,
     scale & translate. Other, more complex transformations can be
     achieved through combination and repetition of these.
***** PRotate & PRotate3D
  Rotation is always relative to the world origin. For 2D
  implementations, the rotation angle \theta (theta) is always
  interpreted clockwise and only the =rotate= method is
  implemented.
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PRotate
    (rotate [_ t]))

  (defprotocol PRotate3D
    (rotate-x [_ t])
    (rotate-y [_ t])
    (rotate-z [_ t])
    (rotate-around-axis [_ a t]))
#+END_SRC
***** PScale
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx 
  (defprotocol PScale
    (scale [_ s] [_ a b] [_ a b c])
    (scale-size [_ s]))
#+END_SRC
***** PShear
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx 
  (defprotocol PShear
    (shear [_ s] [_ sx sy] [_ sx sy sz]))
#+END_SRC
***** PTranslate
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx 
  (defprotocol PTranslate
    (translate [_ t] [_ x y] [_ x y z]))
#+END_SRC
***** PTransform
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx 
  (defprotocol PTransform
    (transform [_ matrix]))
#+END_SRC
***** PVectorTransform
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PVectorTransform
    (transform-vector [_ v]))
#+END_SRC
***** PReflect
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PReflect
    (reflect [_ r]))
#+END_SRC
***** PPolar
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PPolar
    (as-polar [_])
    (as-cartesian [_]))
#+END_SRC
**** Graph operations
Most geometric shape constructs can be understood as an undirected
graph of vertices, connected by edges. This protocol provides read
access to entities in _ context.
***** PGraph
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PGraph
    (cyclic? [_])
    (edges [_] [_ n])
    (vertices [_] [_ n])
    (vertex-valence [_ v])
    (vertex-neighbors [_ v]))
#+END_SRC
***** PDirectedGraph
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PDirectedGraph
    (in-vertices [_ v])
    (out-vertices [_ v]))
#+END_SRC
***** PGraphConvert
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PGraphConvert
    (as-graph [_] [_ opts]))
#+END_SRC
**** Shape based & structural operations
***** PAlign
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PAlign
    (align-with [_ x opts]
      "Returns updated entity aligned with `x` in the specified manner"))
#+END_SRC
***** PArea
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PArea
    (area [_]
      "Returns an entity's total surface area"))
#+END_SRC
***** PBoundary
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PBoundary
    (contains-point? [_ p])
    (contains-entity? [_ s]))
#+END_SRC
***** PBoundingCircle
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PBoundingCircle
    (bounding-circle [_]))
#+END_SRC
***** PBoundingSphere
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PBoundingSphere
    (bounding-sphere [_]))
#+END_SRC
***** PBounds
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PBounds
    (bounds [_]
      "Returns bounding rect for 2d entities or box for 3d")
    (width [_]
      "Returns entity's extent along X axis")
    (height [_]
      "Returns entity's extent along Y axis")
    (depth [_]
      "Returns entity's extent along Z (zero for 2d)"))
#+END_SRC
***** PCenter
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PCenter
    (center [_] [_ p]
      "Returns updated entity centered around world origin or given point")
    (centroid [_]
      "Returns centroid of entity"))
#+END_SRC
***** PCircumference
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PCircumference
    (circumference [_]
      "Returns an entity's circumference"))
#+END_SRC
***** PClassify
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PClassify
    (classify-point [_ p]))
#+END_SRC
***** PClip
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PClip
    (clip-with [_ s]))
#+END_SRC
***** PConvexHull
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PConvexHull
    (convex-hull [_]))
#+END_SRC
***** PExtrude
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PExtrude
    (extrude [_ opts])
    (extrude-shell [_ opts]))
#+END_SRC
***** PFlip
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PFlip
    (flip [_]))
#+END_SRC
***** PIntersect
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PIntersect
    (intersect-line [_ l])
    (intersect-ray [_ r])
    (intersect-shape [_ s]))
#+END_SRC
***** PInvert
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PInvert
    (invert [_]))
#+END_SRC
***** PMeshConvert
       Anything which can be turned into a 2D or 3D mesh will implement _
       protocol consisting of just _ one function: =as-mesh=.
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PMeshConvert
    (as-mesh [_] [_ opts]
      "Transforms the current enitity into a Mesh instance"))
 #+END_SRC
***** PPolygonConvert
       Anything which can be turned into a polygon will implement _
       protocol consisting of just _ one function: =as-polygon=.
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PPolygonConvert
    (as-polygon [_] [_ res]
      "Transforms current entity into a Polygon instance"))
#+END_SRC
***** PProximity
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PProximity
    (closest-point [_ p]))
#+END_SRC
***** PSample
****** TODO move random-point-inside into PBoundary
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PSample
    (point-at [_ t] [_ u v])
    (random-point [_])
    (random-point-inside [_])
    (sample-uniform [_ dist include-last?])
    (sample-with-resolution [_ res]))
#+END_SRC
***** PSlice
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PSlice
    (slice-with [_ e] [_ e classifier] [_ e classifier parts]))
#+END_SRC
***** PSubdivide
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PSubdivide
    (subdivide [_] [_ opts])
    (subdivide-edge [_ a b splits])
    (subdivide-face [_ f p displace splits]))
#+END_SRC
***** PTessellate
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PTessellate
    (tessellate [_] [_ opts]))
#+END_SRC
***** PVolume
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PVolume
    (volume [_]
      "Returns an entity's inner volume."))
#+END_SRC
**** Type specific operations
***** PCurve
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PCurve
    (arc-length [_])
    (auto-spline [_]))
#+END_SRC
***** PMesh
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PMesh
    (faces [_])
    (vertex-faces [_ v])
    (add-face [_ f])
    (remove-face [_ f])
    (add-mesh [_ m])
    (compute-face-normals [_])
    (compute-vertex-normals [_])
    (remove-vertex [_ v])
    (replace-vertex [_ a b])
    (merge-vertices [_ a b]))
#+END_SRC
*** Vector implementations
    For performance reasons, we decided to define custom datatypes
    for handling vectors & matrices. These types can be used much
    like standard Clojure vectors since they all implement the same
    protocols and interfaces, but also provide implementations for
    [[PVector]] and provide custom key lookups to provide swizzling features.

    Furthermore, since we aim for full ClojureScript compatibiliy,
    the following implementations are quite lengthy.
**** Declarations
    Some functions used by the following vector types will be
    defined further on, but need to be declared already.
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (declare vec2 swizzle2 swizzle2-assoc)
  (declare vec3 swizzle3 swizzle3-assoc)
  (declare ID32 ID44)
  (declare vec2-op-1 vec2-op-2 vec2-op-2* vec2-op-3)
  (declare vec3-op-1 vec3-op-2 vec3-op-3)
#+END_SRC
**** Protocol helpers
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  #+clj
  (defn map-entry [k ^double v]
    (reify
      clojure.lang.IMapEntry
      java.util.Map$Entry

      (key [_] k)
      (getKey [_] k)

      (val [_] v)
      (getValue [_] v)

      (hashCode [_]
        (bit-xor (clojure.lang.Util/hash k) (clojure.lang.Util/hash v)))
      (equals [_ x]
        (and (instance? java.util.Map$Entry x)
             (clojure.lang.Util/equals k (.getKey ^java.util.Map$Entry x))
             (clojure.lang.Util/equals v (.getValue ^java.util.Map$Entry x))))))
#+END_SRC
**** 2D
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx :mkdirp yes
  (deftype Vec2
    ,#+clj [^double x ^double y _meta]
    ,#+cljs [x y _meta]
#+END_SRC
***** Clojure protocols
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  ,#+clj clojure.lang.IObj
  ,#+clj (meta
         [_]_meta)
  ,#+clj (withMeta
         [_ m*] (Vec2. x y m*))
  
  ,#+clj clojure.lang.ILookup
  ,#+clj (valAt
         [_ k] (swizzle2 _ k nil))
  ,#+clj (valAt
         [_ k nf] (swizzle2 _ k nf))
  
  ,#+clj java.util.concurrent.Callable
  ,#+clj (call
         [_] (.invoke ^clojure.lang.IFn _))
  ,#+clj java.lang.Runnable
  ,#+clj (run
         [_] (.invoke ^clojure.lang.IFn _))
  
  ,#+clj clojure.lang.IFn
  ,#+clj (invoke
         [_ k] (swizzle2 _ k nil))
  ,#+clj (invoke
         [_ k nf] (swizzle2 _ k nf))
  ,#+clj (applyTo
         [_ args]
         (condp = (count args)
           1 (swizzle2 _ (first args) nil)
           2 (swizzle2 _ (first args) (second args))
           (err/arity-error! (count args))))
  
  ,#+clj clojure.lang.IMapEntry
  ,#+clj java.util.Map$Entry
  ,#+clj (key
         [_] x)
  ,#+clj (getKey
         [_] x)
  ,#+clj (val
         [_] y)
  ,#+clj (getValue
         [_] y)
  
  ,#+clj clojure.lang.Associative
  ,#+clj clojure.lang.IPersistentVector
  ,#+clj (count
         [_] 2)
  ,#+clj (length
         [_] 2)
  ,#+clj (containsKey
         [_ k] (not (nil? (#{0 1 :x :y} k))))
  ,#+clj (entryAt
         [_ k] (map-entry k (case (int k) 0 x, 1 y, (err/key-error! k))))
  ,#+clj (assoc
            [_ k v] (swizzle2-assoc _ k v))
  ,#+clj (assocN
         [_ k v] (case (int k) 0 (Vec2. v y _meta), 1 (Vec2. x v _meta), (err/key-error! k)))
  
  ,#+clj java.util.Collection
  ,#+clj (isEmpty
         [_] false)
  ,#+clj (iterator
         [_] (.iterator ^java.util.Collection (list x y)))
  ,#+clj (toArray
         [_] (double-array 2 [x y]))
  ,#+clj (size [_] 2)
  
  ,#+clj clojure.lang.IPersistentCollection
  ,#+clj clojure.lang.Indexed
  ,#+clj clojure.lang.Sequential
  ,#+clj clojure.lang.ISeq
  ,#+clj clojure.lang.Seqable
  ,#+clj (first
         [_] x)
  ,#+clj (next
         [_] (cons y nil))
  ,#+clj (more
         [_] (cons y nil))
  ,#+clj (cons
         [_ z] (with-meta (vec3 x y z) _meta))
  ,#+clj (peek
         [_] y)
  ,#+clj (pop
         [_] [x])
  ,#+clj (rseq
         [_] (Vec2. y x _meta))
  ,#+clj (seq
         [_] _)
  ,#+clj (nth
         [_ n] (case (int n) 0 x, 1 y, (err/key-error! n)))
  ,#+clj (nth
         [_ n nf] (case (int n) 0 x, 1 y, nf))
  ,#+clj (equiv
         [_ o]
         (if (instance? Vec2 o)
           (and (clojure.lang.Numbers/equiv x (.-x ^Vec2 o))
                (clojure.lang.Numbers/equiv y (.-y ^Vec2 o)))
           (and (instance? java.util.Collection o)
                (= 2 (count o))
                (clojure.lang.Util/equiv x (nth o 0))
                (clojure.lang.Util/equiv y (nth o 1)))))
  ,#+clj (equals
         [_ o]
         (if (instance? Vec2 o)
           (and (clojure.lang.Util/equals x (.-x ^Vec2 o))
                (clojure.lang.Util/equals y (.-y ^Vec2 o)))
           (and (instance? java.util.Collection o)
                (= 2 (count o))
                (clojure.lang.Util/equals x (nth o 0))
                (clojure.lang.Util/equals y (nth o 1)))))
  
  ;; http://docs.oracle.com/javase/7/docs/api/java/util/List.html#hashCode()
  ,#+clj (hashCode
         [_]
         (-> 31
             (unchecked-add-int (hash x))
             (unchecked-multiply-int 31)
             (unchecked-add-int (hash y))))
  
  ;; http://clojure.org/data_structures#hash
  ,#+clj clojure.lang.IHashEq
  ,#+clj (hasheq
         [_]
         (-> 31
             (unchecked-add-int (hash x))
             (unchecked-multiply-int 31)
             (unchecked-add-int (hash y))
             (mix-collection-hash 2)))
  
  Object
  (toString
   [_] (str "[" x " " y "]"))
#+END_SRC
***** ClojureScript protocols
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  ,#+cljs IMeta
  ,#+cljs (-meta
          [_] _meta)
  ,#+cljs IWithMeta
  ,#+cljs (-with-meta
          [_ m*] (Vec2. x y m*))
  
  ,#+cljs ICloneable
  ,#+cljs (-clone
          [_] (Vec2. x y _meta))
  
  ,#+cljs ILookup
  ,#+cljs (-lookup
          [_ k] (swizzle2 _ k nil))
  ,#+cljs (-lookup
          [_ k nf] (swizzle2 _ k nf))
  
  ,#+cljs IFn
  ,#+cljs (-invoke
          [_ k] (swizzle2 _ k nil))
  ,#+cljs (-invoke
          [_ k nf] (swizzle2 _ k nf))
  
  ,#+cljs ICounted
  ,#+cljs (-count
          [_] 2)
  
  ,#+cljs IAssociative
  ,#+cljs (-contains-key?
          [_ k] (not (nil? (#{0 1 :x :y} k))))
  ,#+cljs (-assoc
          [_ k v] (swizzle2-assoc _ k v))
  
  ,#+cljs IVector
  ,#+cljs (-assoc-n
          [_ k v] (case k 0 (Vec2. v y _meta), 1 (Vec2. x v _meta), (err/key-error! k)))
  
  ,#+cljs ISequential
  ,#+cljs ISeq
  ,#+cljs (-first
          [_] x)
  ,#+cljs (-rest
          [_] (cons y nil))
  
  ,#+cljs INext
  ,#+cljs (-next
          [_] (cons y nil))
  
  ,#+cljs ISeqable
  ,#+cljs (-seq
          [_] _)
  
  ,#+cljs IReversible
  ,#+cljs (-rseq
          [_] (Vec2. y x _meta))
  
  ,#+cljs IIndexed
  ,#+cljs (-nth
          [_ n] (case n 0 x, 1 y, (err/key-error! n)))
  ,#+cljs (-nth
          [_ n nf] (case n 0 x, 1 y, nf))
  
  ,#+cljs ICollection
  ,#+cljs (-conj
          [_ z] (with-meta (vec3 x y z) _meta))
  
  ,#+cljs IStack
  ,#+cljs (-peek
          [_] y)
  ,#+cljs (-pop
          [_] [x])
  
  ,#+cljs IComparable
  ,#+cljs (-compare
          [_ o]
          (if (instance? Vec2 o)
            (let [c (compare x (.-x ^Vec2 o))]
              (if (== 0 c) (compare y (.-y ^Vec2 o)) c))
            (let [c (count o)]
              (if (= 2 c) (compare o _) (- 2 c)))))
  
  ,#+cljs IHash
  ,#+cljs (-hash
          [_] (hash-combine (hash x) (hash y)))
  
  ,#+cljs IEquiv
  ,#+cljs (-equiv
          [_ o]
          (if (instance? Vec2 o)
            (and (== x (.-x ^Vec2 o)) (== y (.-y ^Vec2 o)))
            (and (sequential? o) (= 2 (count o))
                 (= x (nth o 0)) (= y (nth o 1)))))
#+END_SRC
***** Transformations
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PScale
  (scale
   [_ a] (vec2-op-1 clojure.core/* _ a 1.0 _meta))
  (scale
   [_ a b] (vec2-op-2 clojure.core/* _ a b 1.0 1.0 _meta))
  (scale
   [_ a b c] (vec2-op-3 clojure.core/* _ a b c 1.0 _meta))
  
  PTranslate
  (translate
   [_ a] (vec2-op-1 clojure.core/+ _ a 0.0 _meta))
  (translate
   [_ a b] (vec2-op-2 clojure.core/+ _ a b 0.0 0.0 _meta))
  (translate
   [_ a b c] (vec2-op-3 clojure.core/+ _ a b c 0.0 _meta))
  
  PRotate
  (rotate
   [_ theta]
   (let [s (Math/sin theta) c (Math/cos theta)]
     (Vec2.
      (clojure.core/- (clojure.core/* x c) (clojure.core/* y s))
      (clojure.core/+ (clojure.core/* x s) (clojure.core/* y c)) _meta)))
  PRotate3D
  (rotate-x
   [_ theta] (rotate-x (vec3 _) theta))
  (rotate-y
   [_ theta] (rotate-y (vec3 _) theta))
  (rotate-z
   [_ theta] (vec3 (rotate _ theta)))
  (rotate-around-axis
   [_ axis theta] (rotate-around-axis (vec3 _) axis theta))
  
  PTransform
  (transform
   [_ m] (transform-vector m _))
#+END_SRC
***** PMathOps
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PMathOps
  (abs [_] (Vec2. (m/abs x) (m/abs y) _meta))
  (+ [_] _)
  (+ [_ a] (vec2-op-1 clojure.core/+ _ a 0.0 _meta))
  (+ [_ a b] (vec2-op-2 clojure.core/+ _ a b 0.0 0.0 _meta))
  (+ [_ a b c] (vec2-op-3 clojure.core/+ _ a b c 0.0 _meta))
  
  (- [_] (Vec2. (clojure.core/- x) (clojure.core/- y) _meta))
  (- [_ a] (vec2-op-1 clojure.core/- _ a 0.0 _meta))
  (- [_ a b] (vec2-op-2 clojure.core/- _ a b 0.0 0.0 _meta))
  (- [_ a b c] (vec2-op-3 clojure.core/- _ a b c 0.0 _meta))
  
  (* [_] _)
  (* [_ a] (vec2-op-1 clojure.core/* _ a 1.0 _meta))
  (* [_ a b] (vec2-op-2 clojure.core/* _ a b 1.0 1.0 _meta))
  (* [_ a b c] (vec2-op-3 clojure.core/* _ a b c 1.0 _meta))
  
  (div [_] (Vec2. (/ x) (/ y) _meta))
  (div [_ a] (vec2-op-1 / _ a 0.0 _meta))
  (div [_ a b] (vec2-op-2 / _ a b 0.0 0.0 _meta))
  (div [_ a b c] (vec2-op-3 / _ a b c 0.0 _meta))
  
  (madd [_ a b] (vec2-op-2* clojure.core/* clojure.core/+ _ a b 1.0 0.0 _meta))
#+END_SRC
***** PDotProduct
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PDotProduct
  (dot
   [_ [ax ay]] (clojure.core/+ (clojure.core/* x ax) (clojure.core/* y ay)))
#+END_SRC
***** PCrossProduct
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx  
  PCrossProduct
  (cross
   [_ [ax ay]] (clojure.core/- (clojure.core/* x ay) (clojure.core/* y ax)))
#+END_SRC
***** PLimit
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx  
  PLimit
  (limit
   [_ len]
   (if (> (mag-squared _) (clojure.core/* len len))
     (normalize _ len) _))
#+END_SRC
***** PMinMax
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PMinMax
  (min
   [_ [ax ay]]
   (Vec2.
    (clojure.core/min x ax)
    (clojure.core/min y ay) _meta))
  (min
   [_ [ax ay] [bx by]]
   (Vec2.
    (clojure.core/min (clojure.core/min x ax) bx)
    (clojure.core/min (clojure.core/min y ay) by) _meta))
  (max
   [_ [ax ay]]
   (Vec2.
    (clojure.core/max x ax)
    (clojure.core/max y ay) _meta))
  (max
   [_ [ax ay] [bx by]]
   (Vec2.
    (clojure.core/max (clojure.core/max x ax) bx)
    (clojure.core/max (clojure.core/max y ay) by) _meta))
#+END_SRC
***** PMagnitude
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PMagnitude
  (mag
   [_]
   (Math/sqrt
    (clojure.core/+ (clojure.core/* x x) (clojure.core/* y y))))
  (mag-squared
   [_] (clojure.core/+ (clojure.core/* x x) (clojure.core/* y y)))
#+END_SRC
***** PNormalize
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PNormalize
  (normalize
   [_]
   (let [l (mag _)]
     (if (pos? l)
       (Vec2. (/ x l) (/ y l) _meta)
       _)))
  (normalize
   [_ len]
   (let [l (mag _)]
     (if (pos? l)
       (let [l (/ len l)]
         (Vec2. (clojure.core/* x l) (clojure.core/* y l) _meta))
       _)))
  (normalized?
   [_] (m/delta= 1.0 (mag-squared _)))
#+END_SRC
***** PDistance
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PDistance
  (dist
   [_ a]
   (let [[dx dy] (if (instance? Vec2 a)
                   [(clojure.core/- x (.-x ^Vec2 a))
                    (clojure.core/- y (.-y ^Vec2 a))]
                   [(clojure.core/- x (nth a 0))
                    (clojure.core/- y (nth a 1))])]
     (Math/sqrt
      (clojure.core/+
       (clojure.core/* dx dx) (clojure.core/* dy dy)))))
  (dist-squared
   [_ a]
   (let [[dx dy] (if (instance? Vec2 a)
                   [(clojure.core/- x (.-x ^Vec2 a))
                    (clojure.core/- y (.-y ^Vec2 a))]
                   [(clojure.core/- x (nth a 0))
                    (clojure.core/- y (nth a 1))])]
     (clojure.core/+
      (clojure.core/* dx dx) (clojure.core/* dy dy))))
#+END_SRC
***** PReflect
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PReflect
  (reflect
   [_ [rx ry :as r]]
    (let [d (clojure.core/* (dot _ r) 2.0)]
      (Vec2.
       (clojure.core/- (clojure.core/* rx d) x)
       (clojure.core/- (clojure.core/* ry d) y) _meta)))
#+END_SRC
***** PInvert
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PInvert
  (invert
   [_] (Vec2. (clojure.core/- x) (clojure.core/- y) _meta))
#+END_SRC
***** PInterpolate
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PInterpolate
  (mix
   [_ [ax ay]]
   (Vec2.
    (clojure.core/+ x (clojure.core/* (clojure.core/- ax x) 0.5))
    (clojure.core/+ y (clojure.core/* (clojure.core/- ay y) 0.5)) _meta))
  (mix
   [_ [ax ay] t]
   (Vec2.
    (clojure.core/+ x (clojure.core/* (clojure.core/- ax x) t))
    (clojure.core/+ y (clojure.core/* (clojure.core/- ay y) t)) _meta))
#+END_SRC
***** PHeading
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PHeading
  (heading-xy
   [_]
   (let [t (Math/atan2 y x)]
     (if (neg? t) (clojure.core/+ TWO_PI t) t)))
  (angle-between
   [_ a]
   (let [t (clojure.core/- (heading-xy a) (heading-xy _))]
     (if (neg? t) (clojure.core/+ TWO_PI t) t)))
  (slope-xy
   [_] (/ y x))
  (normal
   [_] (Vec2. (clojure.core/- y) x _meta))
#+END_SRC
***** PPolar
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PPolar
  (as-polar
   [_]
   (Vec2. (mag _) (heading-xy _) _meta))
  (as-cartesian
   [_]
   (Vec2.
    (clojure.core/* x (Math/cos y))
    (clojure.core/* x (Math/sin y)) _meta))
#+END_SRC
***** End of implementations
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  )
#+END_SRC
***** Override print methods
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  #+clj (require 'clojure.pprint)
  #+clj (prefer-method clojure.pprint/simple-dispatch clojure.lang.IPersistentVector clojure.lang.ISeq)
  #+clj (defmethod print-method Vec2 [o ^java.io.Writer w] (.write w (.toString o)))
#+END_SRC
**** 3D
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (deftype Vec3
    #+clj [^double x ^double y ^double z _meta]
    #+cljs [x y z _meta]
#+END_SRC
***** Clojure protocols
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  ,#+clj clojure.lang.IObj
  ,#+clj (meta
         [_] _meta)
  ,#+clj (withMeta
         [_ m*] (Vec3. x y z m*))
  
  ,#+clj clojure.lang.ILookup
  ,#+clj (valAt
         [_ k] (swizzle3 _ k nil))
  ,#+clj (valAt
         [_ k nf] (swizzle3 _ k nf))
  
  ,#+clj java.util.concurrent.Callable
  ,#+clj (call
         [_] (.invoke ^clojure.lang.IFn _))
  ,#+clj java.lang.Runnable
  ,#+clj (run
         [_] (.invoke ^clojure.lang.IFn _))
  
  ,#+clj clojure.lang.IFn
  ,#+clj (invoke
         [_ k] (swizzle3 _ k nil))
  ,#+clj (invoke
         [_ k nf] (swizzle3 _ k nf))
  ,#+clj (applyTo
         [_ args]
         (condp = (count args)
           1 (swizzle3 _ (first args) nil)
           2 (swizzle3 _ (first args) (second args))
           (err/arity-error! (count args))))
  
  ,#+clj clojure.lang.Associative
  ,#+clj clojure.lang.IPersistentVector
  ,#+clj (count
         [_] 3)
  ,#+clj (length
         [_] 3)
  ,#+clj (containsKey
         [_ k] (not (nil? (#{0 1 2 :x :y :z} k))))
  ,#+clj (entryAt
         [_ k] (map-entry k (case (int k) 0 x, 1 y, 2 z, (err/key-error! k))))
  ,#+clj (assoc
            [_ k v] (swizzle3-assoc _ k v))
  ,#+clj (assocN
         [_ k v]
         (case (int k)
           0 (Vec3. v y z _meta)
           1 (Vec3. x v z _meta)
           2 (Vec3. x y v _meta)
           (err/key-error! k)))
  
  ,#+clj java.util.Collection
  ,#+clj (isEmpty
         [_] false)
  ,#+clj (iterator
         [_] (.iterator ^java.util.Collection (list x y z)))
  ,#+clj (toArray
         [_] (double-array 3 [x y z]))
  ,#+clj (size
         [_] 3)
  
  ,#+clj clojure.lang.IPersistentCollection
  ,#+clj clojure.lang.Indexed
  ,#+clj clojure.lang.Sequential
  ,#+clj clojure.lang.ISeq
  ,#+clj clojure.lang.Seqable
  ,#+clj (first
         [_] x)
  ,#+clj (next
         [_] (cons y (cons z nil)))
  ,#+clj (more
         [_] (cons y (cons z nil)))
  ,#+clj (cons
         [_ w] (with-meta [x y z w] _meta))
  ,#+clj (peek
         [_] z)
  ,#+clj (pop
         [_] (Vec2. x y _meta))
  ,#+clj (rseq
         [_] (Vec3. z y x _meta))
  ,#+clj (seq
         [_] _)
  ,#+clj (nth
         [_ n] (condp = n 0 x 1 y 2 z (err/key-error! n)))
  ,#+clj (nth
         [_ n nf] (condp = n 0 x 1 y 2 z nf))
  ,#+clj (equiv
         [_ o]
         (if (instance? Vec3 o)
           (and (clojure.lang.Numbers/equiv x (.-x ^Vec3 o))
                (clojure.lang.Numbers/equiv y (.-y ^Vec3 o))
                (clojure.lang.Numbers/equiv z (.-z ^Vec3 o)))
           (and (instance? java.util.Collection o)
                (= 3 (count o))
                (clojure.lang.Util/equiv x (nth o 0))
                (clojure.lang.Util/equiv y (nth o 1))
                (clojure.lang.Util/equiv z (nth o 2)))))
  ,#+clj (equals
         [_ o]
         (if (instance? Vec3 o)
           (and (clojure.lang.Util/equals x (.-x ^Vec3 o))
                (clojure.lang.Util/equals y (.-y ^Vec3 o))
                (clojure.lang.Util/equals z (.-z ^Vec3 o)))
           (and (instance? java.util.Collection o)
                (= 3 (count o))
                (clojure.lang.Util/equals x (nth o 0))
                (clojure.lang.Util/equals y (nth o 1))
                (clojure.lang.Util/equals z (nth o 2)))))
  
  ,#+clj Comparable
  ,#+clj (compareTo
         [_ o]
         (if (instance? Vec3 o)
           (let [c (compare x (.-x ^Vec3 o))]
             (if (== 0 c)
               (let [c (compare y (.-y ^Vec3 o))]
                 (if (== 0 c)
                   (compare z (.-z ^Vec3 o))
                   c))
               c))
           (let [c (count o)]
             (if (== 3 c) (compare o _) (- 3 c)))))
  ,#+clj (hashCode
         [_]
         (-> 31
             (unchecked-add-int (hash x))
             (unchecked-multiply-int 31)
             (unchecked-add-int (hash y))
             (unchecked-multiply-int 31)
             (unchecked-add-int (hash z))))
  
  ,#+clj clojure.lang.IHashEq
  ,#+clj (hasheq
           [_]
           (-> 31
               (unchecked-add-int (hash x))
               (unchecked-multiply-int 31)
               (unchecked-add-int (hash y))
               (unchecked-multiply-int 31)
               (unchecked-add-int (hash z))
               (mix-collection-hash 3)))
  
  Object
  (toString
    [_] (str "[" x " " y " " z "]"))
#+END_SRC
***** ClojureScript protocols
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  ,#+cljs IMeta
  ,#+cljs (-meta
          [_] _meta)
  ,#+cljs IWithMeta
  ,#+cljs (-with-meta
          [_ m*] (Vec3. x y z m*))
  
  ,#+cljs ICloneable
  ,#+cljs (-clone
          [_] (Vec3. x y z _meta))
  
  ,#+cljs ILookup
  ,#+cljs (-lookup
          [_ k] (swizzle3 _ k nil))
  ,#+cljs (-lookup
          [_ k nf] (swizzle3 _ k nf))
  
  ,#+cljs IFn
  ,#+cljs (-invoke
          [_ k] (swizzle3 _ k nil))
  ,#+cljs (-invoke
          [_ k nf] (swizzle3 _ k nf))
  
  ,#+cljs ICounted
  ,#+cljs (-count
          [_] 3)
  
  ,#+cljs IAssociative
  ,#+cljs (-contains-key?
          [_ k] (not (nil? (#{0 1 2 :x :y :z} k))))
  ,#+cljs (-assoc
          [_ k v] (swizzle3-assoc _ k v))
  
  ,#+cljs IVector
  ,#+cljs (-assoc-n
          [_ k v]
          (case k
            0 (Vec3. v y z _meta)
            1 (Vec3. x v z _meta)
            2 (Vec3. x y v _meta)
            (err/key-error! k)))
  
  ,#+cljs ISequential
  ,#+cljs ISeq
  ,#+cljs (-first
          [_] x)
  ,#+cljs (-rest
          [_] (cons y (cons z nil)))
  
  ,#+cljs INext
  ,#+cljs (-next
          [_] (cons y (cons z nil)))
  
  ,#+cljs ISeqable
  ,#+cljs (-seq
          [_] _)
  
  ,#+cljs IReversible
  ,#+cljs (-rseq
          [_] (Vec3. z y x _meta))
  
  ,#+cljs IIndexed
  ,#+cljs (-nth
          [_ n] (case n 0 x, 1 y, 2 z, (err/key-error! n)))
  ,#+cljs (-nth
          [_ n nf] (case n 0 x, 1 y, 2 z, nf))
  
  ,#+cljs ICollection
  ,#+cljs (-conj
          [_ w] (with-meta [x y z w] _meta))
  
  ,#+cljs IStack
  ,#+cljs (-peek
          [_] z)
  ,#+cljs (-pop
          [_] (Vec2. x y _meta))
  
  ,#+cljs IComparable
  ,#+cljs (-compare
          [_ o]
          (if (instance? Vec3 o)
            (let [c (compare x (.-x ^Vec3 o))]
              (if (== 0 c)
                (let [c (compare y (.-y ^Vec3 o))]
                  (if (== 0 c)
                    (compare z (.-z ^Vec3 o))
                    c))
                c))
            (let [c (count o)]
              (if (= 3 c) (compare o _) (- 3 c)))))
  
  ,#+cljs IHash
  ,#+cljs (-hash
          [_] (-> (hash x)
                  (hash-combine (hash y))
                  (hash-combine (hash z))))
  
  ,#+cljs IEquiv
  ,#+cljs (-equiv
          [_ o]
          (if (instance? Vec3 o)
            (and (== x (.-x ^Vec3 o)) (== y (.-y ^Vec3 o)) (== z (.-z ^Vec3 o)))
            (and (sequential? o) (= 3 (count o))
                 (= x (nth o 0)) (= y (nth o 1)) (= z (nth o 2)))))
#+END_SRC
***** TODO Transformations
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PScale
  (scale
   [_ a] (vec3-op-1 clojure.core/* _ a 1.0 _meta))
  (scale
   [_ a b] (vec3-op-2 clojure.core/* clojure.core/* _ a b 1.0 1.0 _meta))
  (scale
   [_ a b c] (vec3-op-3 clojure.core/* _ a b c 1.0 _meta))
  
  PTranslate
  (translate
   [_ a] (vec3-op-1 clojure.core/+ _ a 0.0 _meta))
  (translate
   [_ a b] (vec3-op-2 clojure.core/+ clojure.core/+ _ a b 0.0 0.0 _meta))
  (translate
   [_ a b c] (vec3-op-3 clojure.core/+ _ a b c 0.0 _meta))
  
  PRotate3D
  (rotate-x
   [_ theta]
   (let [s (Math/sin theta) c (Math/cos theta)]
     (Vec3.
      x
      (clojure.core/- (clojure.core/- (clojure.core/* z c) (clojure.core/* y s)))
      (clojure.core/- (clojure.core/+ (clojure.core/* z s) (clojure.core/* y c))) _meta)))
  (rotate-y
   [_ theta]
   (let [s (Math/sin theta) c (Math/cos theta)]
     (Vec3.
      (clojure.core/- (clojure.core/- (clojure.core/* x c) (clojure.core/* z s)))
      y
      (clojure.core/+ (clojure.core/* x s) (clojure.core/* z c)) _meta)))
  (rotate-z
   [_ theta]
   (let [s (Math/sin theta) c (Math/cos theta)]
     (Vec3.
      (clojure.core/- (clojure.core/* x c) (clojure.core/* y s))
      (clojure.core/+ (clojure.core/* x s) (clojure.core/* y c))
      z _meta)))
  (rotate-around-axis ;; TODO
   [_ axis theta])
  
  PTransform
  (transform
   [_ m] (transform-vector m _))
#+END_SRC
***** PMathOps
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PMathOps
  (abs [_] (Vec3. (m/abs x) (m/abs y) (m/abs z) _meta))
  (+ [_] _)
  (+ [_ a] (vec3-op-1 clojure.core/+ _ a 0.0 _meta))
  (+ [_ a b] (vec3-op-2 clojure.core/+ clojure.core/+ _ a b 0.0 0.0 _meta))
  (+ [_ a b c] (vec3-op-3 clojure.core/+ _ a b c 0.0 _meta))
  
  (- [_] (Vec3. (clojure.core/- x) (clojure.core/- y) (clojure.core/- z) _meta))
  (- [_ a] (vec3-op-1 clojure.core/- _ a 0.0 _meta))
  (- [_ a b] (vec3-op-2 clojure.core/- clojure.core/- _ a b 0.0 0.0 _meta))
  (- [_ a b c] (vec3-op-3 clojure.core/- _ a b c 0.0 _meta))
  
  (* [_] _)
  (* [_ a] (vec3-op-1 clojure.core/* _ a 1.0 _meta))
  (* [_ a b] (vec3-op-2 clojure.core/* clojure.core/* _ a b 1.0 1.0 _meta))
  (* [_ a b c] (vec3-op-3 clojure.core/* _ a b c 1.0 _meta))
  
  (div [_] (Vec3. (/ x) (/ y) (/ z) _meta))
  (div [_ a] (vec3-op-1 / _ a 0.0 _meta))
  (div [_ a b] (vec3-op-2 / / _ a b 0.0 0.0 _meta))
  (div [_ a b c] (vec3-op-3 / _ a b c 0.0 _meta))
  
  (madd
   [_ a b] (vec3-op-2 clojure.core/* clojure.core/+ _ a b 1.0 0.0 _meta))
  
  PDotProduct
  (dot
   [_ [ax ay az]]
   (clojure.core/+
    (clojure.core/+ (clojure.core/* x ax) (clojure.core/* y ay))
    (clojure.core/* z az)))
  
  PCrossProduct
  (cross
   [_ [ax ay az]]
   (Vec3.
    (clojure.core/- (clojure.core/* y az) (clojure.core/* ay z))
    (clojure.core/- (clojure.core/* z ax) (clojure.core/* az x))
    (clojure.core/- (clojure.core/* x ay) (clojure.core/* ax y)) _meta))
  
  PLimit
  (limit
   [_ len]
   (if (> (mag-squared _)(clojure.core/* len len))
     (normalize _ len) _))
  
  PMinMax
  (min
   [_ [ax ay az]]
   (Vec3.
    (clojure.core/min x ax)
    (clojure.core/min y ay)
    (clojure.core/min z az) _meta))
  (min
   [_ [ax ay az] [bx by bz]]
   (Vec3.
    (clojure.core/min (clojure.core/min x ax) bx)
    (clojure.core/min (clojure.core/min y ay) by)
    (clojure.core/min (clojure.core/min z az) bz) _meta))
  (max
   [_ [ax ay az]]
   (Vec3.
    (clojure.core/max x ax)
    (clojure.core/max y ay)
    (clojure.core/max z az) _meta))
  (max
   [_ [ax ay az] [bx by bz]]
   (Vec3.
    (clojure.core/max (clojure.core/max x ax) bx)
    (clojure.core/max (clojure.core/max y ay) by)
    (clojure.core/max (clojure.core/max z az) bz) _meta))
#+END_SRC
***** PMagnitude
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PMagnitude
  (mag
   [_]
   (Math/sqrt
    (clojure.core/+
     (clojure.core/+ (clojure.core/* x x) (clojure.core/* y y))
     (clojure.core/* z z))))
  (mag-squared
   [_]
   (clojure.core/+
    (clojure.core/+ (clojure.core/* x x) (clojure.core/* y y))
    (clojure.core/* z z)))
#+END_SRC
***** PNormalize
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PNormalize
  (normalize
   [_]
   (let [l (mag _)]
     (if (pos? l)
       (Vec3. (/ x l) (/ y l) (/ z l) _meta)
       _)))
  (normalize
   [_ len]
   (let [l (mag _)]
     (if (pos? l)
       (let [l (/ len l)]
         (Vec3.
          (clojure.core/* x l)
          (clojure.core/* y l)
          (clojure.core/* z l) _meta)) _)))
  (normalized?
   [_] (m/delta= 1.0 (mag-squared _)))
#+END_SRC
***** PDistance
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PDistance
  (dist
   [_ a]
   (let [[dx dy dz] (if (instance? Vec3 a)
                      [(clojure.core/- x (.-x ^Vec3 a))
                       (clojure.core/- y (.-y ^Vec3 a))
                       (clojure.core/- z (.-z ^Vec3 a))]
                      [(clojure.core/- x (nth a 0))
                       (clojure.core/- y (nth a 1))
                       (clojure.core/- z (nth a 2 0.0))])]
     (Math/sqrt
      (clojure.core/+
       (clojure.core/+ (clojure.core/* dx dx) (clojure.core/* dy dy))
       (clojure.core/* dz dz)))))
  (dist-squared
   [_ a]
   (let [[dx dy dz] (if (instance? Vec3 a)
                      [(clojure.core/- x (.-x ^Vec3 a))
                       (clojure.core/- y (.-y ^Vec3 a))
                       (clojure.core/- z (.-z ^Vec3 a))]
                      [(clojure.core/- x (nth a 0))
                       (clojure.core/- y (nth a 1))
                       (clojure.core/- z (nth a 2 0.0))])]
     (clojure.core/+
      (clojure.core/+ (clojure.core/* dx dx) (clojure.core/* dy dy))
      (clojure.core/* dz dz))))
#+END_SRC
***** PReflect
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PReflect
  (reflect
   [_ [rx ry rz :as r]]
    (let [d (clojure.core/* (dot _ r) 2.0)]
      (Vec3.
       (clojure.core/- (clojure.core/* rx d) x)
       (clojure.core/- (clojure.core/* ry d) y)
       (clojure.core/- (clojure.core/* rz d) z) _meta)))
#+END_SRC
***** PInvert
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PInvert
  (invert
   [_] (Vec3. (clojure.core/- x) (clojure.core/- y) (clojure.core/- z) _meta))
#+END_SRC
***** PInterpolate
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PInterpolate
  (mix
   [_ [ax ay az]]
   (Vec3.
    (clojure.core/+ x (clojure.core/* (clojure.core/- ax x) 0.5))
    (clojure.core/+ y (clojure.core/* (clojure.core/- ay y) 0.5))
    (clojure.core/+ z (clojure.core/* (clojure.core/- az z) 0.5)) _meta))
  (mix
   [_ [ax ay az] t]
   (Vec3.
    (clojure.core/+ x (clojure.core/* (clojure.core/- ax x) t))
    (clojure.core/+ y (clojure.core/* (clojure.core/- ay y) t))
    (clojure.core/+ z (clojure.core/* (clojure.core/- az z) t)) _meta))
#+END_SRC
***** PPolar
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  ;; http://mathworld.wolfram.com/SphericalCoordinates.html
  PPolar
  (as-polar
   [_]
    (let [r (mag _)
          theta (Math/atan2 y x)
          phi (Math/acos (/ z r))]
      (Vec3. r theta phi _meta)))
  (as-cartesian [_]
    (let [rsphi (clojure.core/* x (Math/sin z))]
      (Vec3.
       (clojure.core/* (Math/cos y) rsphi)
       (clojure.core/* (Math/sin y) rsphi)
       (clojure.core/* x (Math/cos z)) _meta)))
#+END_SRC
***** End of implementations
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
    )
#+END_SRC
***** Override print methods
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  #+clj (defmethod print-method Vec3 [o ^java.io.Writer w] (.write w (.toString o)))
#+END_SRC
**** Vector operations
***** 2D
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defn vec2-op-1
    [op ^Vec2 _ a d m]
    (if (instance? Vec2 a)
      (Vec2.
       (op (.-x _) (.-x ^Vec2 a))
       (op (.-y _) (.-y ^Vec2 a)) m)
      (if (number? a)
        (Vec2. (op (.-x _) a) (op (.-y _) a) m)
        (Vec2.
         (op (.-x _) (nth a 0 d))
         (op (.-y _) (nth a 1 d)) m))))
  
  (defn vec2-op-2
    [op ^Vec2 _ a b d1 d2 m]
    (if (instance? Vec2 a)
      (if (instance? Vec2 b)
        (Vec2. ;; v v
         (op (op (.-x _) (.-x ^Vec2 a)) (.-x ^Vec2 b))
         (op (op (.-y _) (.-y ^Vec2 a)) (.-y ^Vec2 b)) m)
        (if (number? b)
          (Vec2. ;; v n
           (op (op (.-x _) (.-x ^Vec2 a)) b)
           (op (op (.-y _) (.-y ^Vec2 a)) b) m)
          (Vec2. ;; v ?
           (op (op (.-x _) (.-x ^Vec2 a)) (nth b 0 d2))
           (op (op (.-y _) (.-y ^Vec2 a)) (nth b 1 d2)) m)))
      (let [an? (number? a) bn? (number? b)]
        (if (and an? bn?)
          (Vec2. ;; n n
           (op (.-x _) a)
           (op (.-y _) b) m)
          (let [[ax ay] (if an? [a a] a)
                [bx by] (if bn? [b b] b)]
            (Vec2. ;; ? ?
             (op (op (.-x _) (or ax d1)) (or bx d2))
             (op (op (.-y _) (or ay d1)) (or by d2)) m))))))
  
  (defn vec2-op-2*
    "Similar to vec2-op-2 but takes 2 fn args and handles case with
    a & b being both numbers differently."
    [op op2 ^Vec2 _ a b d1 d2 m]
    (if (instance? Vec2 a)
      (if (instance? Vec2 b)
        (Vec2. ;; v v
         (op2 (op (.-x _) (.-x ^Vec2 a)) (.-x ^Vec2 b))
         (op2 (op (.-y _) (.-y ^Vec2 a)) (.-y ^Vec2 b)) m)
        (if (number? b)
          (Vec2. ;; v n
           (op2 (op (.-x _) (.-x ^Vec2 a)) b)
           (op2 (op (.-y _) (.-y ^Vec2 a)) b) m)
          (Vec2. ;; v ?
           (op2 (op (.-x _) (.-x ^Vec2 a)) (nth b 0 d2))
           (op2 (op (.-y _) (.-y ^Vec2 a)) (nth b 1 d2)) m)))
      (let [an? (number? a) bn? (number? b)]
        (if (and an? bn?)
          (Vec2. ;; n n
           (op2 (op (.-x _) a) b)    ;; difference to vec2-op-2
           (op2 (op (.-y _) a) b) m)
          (let [[ax ay] (if an? [a a] a)
                [bx by] (if bn? [b b] b)]
            (Vec2. ;; ? ?
             (op2 (op (.-x _) (or ax d1)) (or bx d2))
             (op2 (op (.-y _) (or ay d1)) (or by d2)) m))))))
  
  (defn vec2-op-3
    [op ^Vec2 _ a b c d m]
    (if (instance? Vec2 a)
      (if (instance? Vec2 b)
        (if (instance? Vec2 c)
          (Vec2. ;; v v v
           (op (op (op (.-x _) (.-x ^Vec2 a)) (.-x ^Vec2 b)) (.-x ^Vec2 c))
           (op (op (op (.-y _) (.-y ^Vec2 a)) (.-y ^Vec2 b)) (.-y ^Vec2 c)) m)
          (if (number? c)
            (Vec2. ;; v v n
             (op (op (op (.-x _) (.-x ^Vec2 a)) (.-x ^Vec2 b)) c)
             (op (op (op (.-y _) (.-y ^Vec2 a)) (.-y ^Vec2 b)) c) m)
            (Vec2. ;; v v ?
             (op (op (op (.-x _) (.-x ^Vec2 a)) (.-x ^Vec2 b)) (nth c 0 d))
             (op (op (op (.-y _) (.-y ^Vec2 a)) (.-y ^Vec2 b)) (nth c 1 d)) m)))
        (let [[bx by] (if (number? b) [b b] b)
              [cx cy] (if (number? c) [c c] c)]
          (Vec2. ;; v ? ?
           (op (op (op (.-x _) (.-x ^Vec2 a)) (or bx d)) (or cx d))
           (op (op (op (.-y _) (.-y ^Vec2 a)) (or by d)) (or cy d)) m)))
      (let [[ax ay] (if (number? a) [a a] a)
            [bx by] (if (number? b) [b b] b)
            [cx cy] (if (number? c) [c c] c)]
        (Vec2. ;; ? ? ?
         (op (op (op (.-x _) (or ax d)) (or bx d)) (or cx d))
         (op (op (op (.-y _) (or ay d)) (or by d)) (or cy d)) m))))
#+END_SRC
***** 3D
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defn vec3-op-1
    [op ^Vec3 _ a d m]
    (if (instance? Vec3 a)
      (Vec3.
       (op (.-x _) (.-x ^Vec3 a))
       (op (.-y _) (.-y ^Vec3 a))
       (op (.-z _) (.-z ^Vec3 a)) m)
      (if (number? a)
        (Vec3. (op (.-x _) a) (op (.-y _) a) (op (.-z _) a) m)
        (Vec3.
         (op (.-x _) (nth a 0 d))
         (op (.-y _) (nth a 1 d))
         (op (.-z _) (nth a 2 d)) m))))
  
  (defn vec3-op-2
    [op op2 ^Vec3 _ a b d1 d2 m]
    (if (instance? Vec3 a)
      (if (instance? Vec3 b)
        (Vec3. ;; v v
         (op2 (op (.-x _) (.-x ^Vec3 a)) (.-x ^Vec3 b))
         (op2 (op (.-y _) (.-y ^Vec3 a)) (.-y ^Vec3 b))
         (op2 (op (.-z _) (.-z ^Vec3 a)) (.-z ^Vec3 b)) m)
        (if (number? b)
          (Vec3. ;; v n
           (op2 (op (.-x _) (.-x ^Vec3 a)) b)
           (op2 (op (.-y _) (.-y ^Vec3 a)) b)
           (op2 (op (.-z _) (.-z ^Vec3 a)) b) m)
          (Vec3. ;; v ?
           (op2 (op (.-x _) (.-x ^Vec3 a)) (nth b 0 d2))
           (op2 (op (.-y _) (.-y ^Vec3 a)) (nth b 1 d2))
           (op2 (op (.-z _) (.-z ^Vec3 a)) (nth b 2 d2)) m)))
      (let [[ax ay az] (if (number? a) [a a a] a)
            [bx by bz] (if (number? b) [b b b] b)]
        (Vec3. ;; ? ? ?
         (op2 (op (.-x _) (or ax d1)) (or bx d2))
         (op2 (op (.-y _) (or ay d1)) (or by d2))
         (op2 (op (.-z _) (or az d1)) (or bz d2)) m))))
  
  (defn vec3-op-3
    [op ^Vec3 _ a b c d m]
    (if (instance? Vec3 a)
      (if (instance? Vec3 b)
        (if (instance? Vec3 c)
          (Vec3. ;; v v v
           (op (op (op (.-x _) (.-x ^Vec3 a)) (.-x ^Vec3 b)) (.-x ^Vec3 c))
           (op (op (op (.-y _) (.-y ^Vec3 a)) (.-y ^Vec3 b)) (.-y ^Vec3 c))
           (op (op (op (.-z _) (.-z ^Vec3 a)) (.-z ^Vec3 b)) (.-z ^Vec3 c)) m)
          (if (number? c)
            (Vec3. ;; v v n
             (op (op (op (.-x _) (.-x ^Vec3 a)) (.-x ^Vec3 b)) c)
             (op (op (op (.-y _) (.-y ^Vec3 a)) (.-y ^Vec3 b)) c)
             (op (op (op (.-z _) (.-z ^Vec3 a)) (.-z ^Vec3 b)) c) m)
            (Vec3. ;; v v ?
             (op (op (op (.-x _) (.-x ^Vec3 a)) (.-x ^Vec3 b)) (nth c 0 d))
             (op (op (op (.-y _) (.-y ^Vec3 a)) (.-y ^Vec3 b)) (nth c 1 d))
             (op (op (op (.-z _) (.-z ^Vec3 a)) (.-z ^Vec3 b)) (nth c 2 d)) m)))
        (let [[bx by bz] (if (number? b) [b b b] b)
              [cx cy cz] (if (number? c) [c c c] c)]
          (Vec3. ;; v ? ?
           (op (op (op (.-x _) (.-x ^Vec3 a)) (or bx d)) (or cx d))
           (op (op (op (.-y _) (.-y ^Vec3 a)) (or by d)) (or cy d))
           (op (op (op (.-z _) (.-z ^Vec3 a)) (or bz d)) (or cz d)) m)))
      (let [an? (number? a) bn? (number? b) cn? (number? c)]
        (if (and an? bn? cn?)
          (Vec3. ;; n n n
           (op (.-x _) a)
           (op (.-y _) b)
           (op (.-z _) c) m)
          (let [[ax ay az] (if (number? a) [a a a] a)
                [bx by bz] (if (number? b) [b b b] b)
                [cx cy cz] (if (number? c) [c c c] c)]
            (Vec3. ;; ? ? ?
             (op (op (op (.-x _) (or ax d)) (or bx d)) (or cx d))
             (op (op (op (.-y _) (or ay d)) (or by d)) (or cy d))
             (op (op (op (.-z _) (or az d)) (or bz d)) (or cz d)) m))))))
#+END_SRC
**** Constants
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (def ^:const VEC2 (Vec2. 0.0 0.0 nil))
  (def ^:const VEC3 (Vec3. 0.0 0.0 0.0 nil))

  (def ^:const V2X (Vec2. 1.0 0.0 nil))
  (def ^:const V2Y (Vec2. 0.0 1.0 nil))

  (def ^:const V3X (Vec3. 1.0 0.0 0.0 nil))
  (def ^:const V3Y (Vec3. 0.0 1.0 0.0 nil))
  (def ^:const V3Z (Vec3. 0.0 0.0 1.0 nil))
#+END_SRC
**** Constructors
      To simplify vector type construction, factory functions
      are provided which coerce arguments into vectors with these
      rules:

      | Input                 | Behavior                                           | Examples call        | Example result  |
      |-----------------------+----------------------------------------------------+----------------------+-----------------|
      | Clojure vector or seq | select first =n= elements or fill missing with 0.0 | =(vec2 [1 2 3 4])=   | =[1.0 2.0]=     |
      |                       |                                                    | =(vec3 '(1 2)=       | =[1.0 2.0 0.0]= |
      | Map                   | select values of =:x :y :z= or fill with 0.0       | =(vec2 {:x 1 :y 2})= | =[1.0 2.0]=     |
      |                       |                                                    | =(vec3 {:x 1 :y 2})= | =[1.0 2.0 0.0]= |
      | Single number         | set all vector components                          | =(vec3 1)=           | =[1.0 1.0 1.0]= |

#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defn vec2
    ([] VEC2)
    ([x] (cond
          (instance? Vec2 x) x
          (sequential? x) (Vec2. (nth x 0 0.0) (nth x 1 0.0) (meta x))
          (number? x) (Vec2. x x nil)
          (map? x) (Vec2. (get x :x 0.0) (get x :y 0.0) (meta x))
          :default (err/type-error! "Vec2" x)))
    ([x y] (Vec2. x y nil)))
  
  (defn vec3
    ([] VEC3)
    ([x] (cond
          (instance? Vec3 x) x
          (sequential? x) (Vec3. (nth x 0 0.0) (nth x 1 0.0) (nth x 2 0.0) (meta x))
          (number? x) (Vec3. x x x nil)
          (map? x) (Vec3. (get x :x 0.0) (get x :y 0.0) (get x :z 0.0) (meta x))
          :default (err/type-error! "Vec3" x)))
    ([x y] (Vec3. x y 0.0 nil))
    ([x y z] (Vec3. x y z nil)))
  
  (defn vec2? [x] (instance? Vec2 x))
  (defn vec3? [x] (instance? Vec3 x))
#+END_SRC
**** Random vectors
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defn randvec2
    ([] (normalize (vec2 (m/randnorm) (m/randnorm))))
    ([n] (normalize (vec2 (m/randnorm) (m/randnorm)) n)))

  (defn randvec3
    ([] (normalize (vec3 (m/randnorm) (m/randnorm) (m/randnorm))))
    ([n] (normalize (vec3 (m/randnorm) (m/randnorm) (m/randnorm)) n)))
#+END_SRC
**** Swizzling
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defn- swizzle2
    [^Vec2 _ k default]
    (if (number? k)
      (case (int k)
        0 (.-x _)
        1 (.-y _)
        (or default (err/key-error! k)))
      (case k
        :x (.-x _)
        :y (.-y _)
        (let [n (name k) c (count n)]
          (case c
            2 (->> n
                   (map #(case % \x (.-x _) \y (.-y _) (or default (err/key-error! k))))
                   ((fn [[x y]] (Vec2. x y (.-_meta _)))))
            3 (->> n
                   (map #(case % \x (.-x _) \y (.-y _) (or default (err/key-error! k))))
                   ((fn [[x y z]] (Vec3. x y z (.-_meta _)))))
            (or default (err/key-error! k)))))))
  
  (defn- swizzle2-assoc
    [^Vec2 _ k v]
    (case k
      0 (Vec2. v (.-y _) (.-_meta _))
      1 (Vec2. (.-x _) v (.-_meta _))
      :x (Vec2. v (.-y _) (.-_meta _))
      :y (Vec2. (.-x _) v (.-_meta _))
      :xy (Vec2. (v 0) (v 1) (.-_meta _))
      :yx (Vec2. (v 1) (v 0) (.-_meta _))
      (err/key-error! k)))
  
  (defn- swizzle3
    [^Vec3 _ k default]
    (if (number? k)
      (case (int k)
        0 (.-x _)
        1 (.-y _)
        2 (.-z _)
        (or default (err/key-error! k)))
      (case k
        :x (.-x _)
        :y (.-y _)
        :z (.-z _)
        (let [n (name k) c (count n)]
          (case c
            2 (->> n
                   (map #(case % \x (.-x _) \y (.-y _) \z (.-z _) (or default (err/key-error! k))))
                   ((fn [[x y]] (Vec2. x y (.-_meta _)))))
            3 (->> n
                   (map #(case % \x (.-x _) \y (.-y _) \z (.-z _) (or default (err/key-error! k))))
                   ((fn [[x y z]] (Vec3. x y z (.-_meta _)))))
            (or default (err/key-error! k)))))))
  
  (defn- swizzle3-assoc
    [^Vec3 _ k v]
    (case k
      :x (Vec3. v (.-y _) (.-z _) (.-_meta _))
      :y (Vec3. (.-x _) v (.-z _) (.-_meta _))
      :z (Vec3. (.-x _) (.-y _) v (.-_meta _))
      0 (Vec3. v (.-y _) (.-z _) (.-_meta _))
      1 (Vec3. (.-x _) v (.-z _) (.-_meta _))
      2 (Vec3. (.-x _) (.-y _) v (.-_meta _))
      :xy (Vec3. (v 0) (v 1) (.-z _) (.-_meta _)) ;; (assoc [x y z] :xy [a b]) => [a b z]
      :yx (Vec3. (v 1) (v 0) (.-z _) (.-_meta _)) ;; (assoc [x y z] :yx [a b]) => [b a z]
      :xz (Vec3. (v 0) (.-y _) (v 1) (.-_meta _)) ;; (assoc [x y z] :xz [a b]) => [a y b]
      :zx (Vec3. (v 1) (.-y _) (v 0) (.-_meta _)) ;; (assoc [x y z] :zx [a b]) => [b y a]
      :yz (Vec3. (.-x _) (v 0) (v 1) (.-_meta _)) ;; (assoc [x y z] :yz [a b]) => [x a b]
      :zy (Vec3. (.-x _) (v 1) (v 0) (.-_meta _)) ;; (assoc [x y z] :zy [a b]) => [x b a]
      (err/key-error! k)))
#+END_SRC
*** Matrix implementations
**** 3x2 Matrix (Affine 2D transform)
***** Implementation
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defrecord Matrix32
    #+clj  [^double m00 ^double m01 ^double m02
            ^double m10 ^double m11 ^double m12]
    #+cljs [m00 m01 m02 m10 m11 m12]
#+END_SRC
****** PMathOps
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PMathOps
  (*
   [_ m]
   (let [m ^Matrix32 m]
     (with-meta
       (Matrix32.
        (mc/mat-item m00 (.-m00 m) m01 (.-m10 m))
        (mc/mat-item m00 (.-m01 m) m01 (.-m11 m))
        (mc/mat-item m00 (.-m02 m) m01 (.-m12 m) m02)
        (mc/mat-item m10 (.-m00 m) m11 (.-m10 m))
        (mc/mat-item m10 (.-m01 m) m11 (.-m11 m))
        (mc/mat-item m10 (.-m02 m) m11 (.-m12 m) m12))
       (meta _))))
#+END_SRC
****** PMatrix
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PMatrix
  (set-scale
   [_ s]
   (let [[sx sy] (if (number? s) [s s] s)]
     (Matrix32. sx 0.0 0.0, 0.0 sy 0.0)))
  (set-scale
   [_ sx sy]
   (Matrix32. sx 0.0 0.0, 0.0 sy 0.0))
  (set-position
   [_ [x y]]
   (Matrix32. 1.0 0.0 x, 0.0 1.0 y))
  (set-position
   [_ x y]
   (Matrix32. 1.0 0.0 x, 0.0 1.0 y))
  (set-rotation
   [_ theta]
   (let [s (Math/sin theta), c (Math/cos theta)]
     (Matrix32. c (clojure.core/- s) 0.0, s c 0.0)))
  (set-shear
   [_ s]
   (let [[sx sy] (if (number? s) [s s] s)]
     (Matrix32. 1.0 sx 0.0, sy 1.0 0.0)))
  (set-shear
   [_ sx sy]
   (Matrix32. 1.0 sx 0.0, sy 1.0 0.0))
  (determinant
   [_]
   (clojure.core/-
    (clojure.core/* m00 m11) (clojure.core/* m01 m10)))
#+END_SRC
****** PInvert
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PInvert
  (invert
   [_]
   (let [d (determinant _)]
     (when-not (zero? d)
       (Matrix32.
        (/ m11 d) (clojure.core/- (/ m01 d)) (/ (clojure.core/- (clojure.core/* m01 m12) (clojure.core/* m11 m02)) d)
        (clojure.core/- (/ m10 d)) (/ m00 d) (/ (clojure.core/- (clojure.core/* m10 m02) (clojure.core/* m00 m12)) d)))))
#+END_SRC
****** PRotate, PScale, PTranslate, PTransform
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PRotate
  (rotate
   [_ theta] (* _ (set-rotation ID32 theta)))
  
  PScale
  (scale
   [_ s] (* _ (set-scale ID32 s)))
  (scale
   [_ sx sy] (* _ (set-scale ID32 sx sy)))
  
  PTranslate
  (translate
   [_ t] (* _ (set-position ID32 t)))
  (translate
   [_ tx ty] (* _ (set-position ID32 tx ty)))
  
  PTransform
  (transform
   [_ matrix] (* _ matrix))
#+END_SRC
****** PVectorTransform
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PVectorTransform
  (transform-vector
   [_ v]
   (let [x (v 0) y (v 1)]
     (Vec2.
      (clojure.core/+
       (clojure.core/+ (clojure.core/* x m00) (clojure.core/* y m01)) m02)
      (clojure.core/+
       (clojure.core/+ (clojure.core/* x m10) (clojure.core/* y m11)) m12)
      (meta v))))
#+END_SRC
****** End of implementations
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  )
#+END_SRC
**** 4x4 Matrix
***** TODO add unproject from [[file:/Users/toxi/dev/js/gl-matrix.orig/gl-matrix.js::385]]
***** Implementation
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defrecord Matrix44
    #+clj  [^double m00 ^double m01 ^double m02 ^double m03
            ^double m10 ^double m11 ^double m12 ^double m13
            ^double m20 ^double m21 ^double m22 ^double m23
            ^double m30 ^double m31 ^double m32 ^double m33]
    #+cljs [m00 m01 m02 m03
            m10 m11 m12 m13
            m20 m21 m22 m23
            m30 m31 m32 m33]
#+END_SRC
****** PMathOps
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PMathOps
  (*
   [_ m]
   (let [^Matrix44 m m]
     (with-meta
       (Matrix44.
        (mc/mat-item m00 (.-m00 m) m01 (.-m10 m) m02 (.-m20 m) m03 (.-m30 m))
        (mc/mat-item m00 (.-m01 m) m01 (.-m11 m) m02 (.-m21 m) m03 (.-m31 m))
        (mc/mat-item m00 (.-m02 m) m01 (.-m12 m) m02 (.-m22 m) m03 (.-m32 m))
        (mc/mat-item m00 (.-m03 m) m01 (.-m13 m) m02 (.-m23 m) m03 (.-m33 m))
  
        (mc/mat-item m10 (.-m00 m) m11 (.-m10 m) m12 (.-m20 m) m13 (.-m30 m))
        (mc/mat-item m10 (.-m01 m) m11 (.-m11 m) m12 (.-m21 m) m13 (.-m31 m))
        (mc/mat-item m10 (.-m02 m) m11 (.-m12 m) m12 (.-m22 m) m13 (.-m32 m))
        (mc/mat-item m10 (.-m03 m) m11 (.-m13 m) m12 (.-m23 m) m13 (.-m33 m))
  
        (mc/mat-item m20 (.-m00 m) m21 (.-m10 m) m22 (.-m20 m) m23 (.-m30 m))
        (mc/mat-item m20 (.-m01 m) m21 (.-m11 m) m22 (.-m21 m) m23 (.-m31 m))
        (mc/mat-item m20 (.-m02 m) m21 (.-m12 m) m22 (.-m22 m) m23 (.-m32 m))
        (mc/mat-item m20 (.-m03 m) m21 (.-m13 m) m22 (.-m23 m) m23 (.-m33 m))
  
        (mc/mat-item m30 (.-m00 m) m31 (.-m10 m) m32 (.-m20 m) m33 (.-m30 m))
        (mc/mat-item m30 (.-m01 m) m31 (.-m11 m) m32 (.-m21 m) m33 (.-m31 m))
        (mc/mat-item m30 (.-m02 m) m31 (.-m12 m) m32 (.-m22 m) m33 (.-m32 m))
        (mc/mat-item m30 (.-m03 m) m31 (.-m13 m) m32 (.-m23 m) m33 (.-m33 m)))
       (meta _))))
#+END_SRC
****** PMatrix
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PMatrix
  (set-position
   [_ [x y z]]
   (assoc _ :m03 x :m13 y :m23 z))
  
  (set-scale
   [_ s]
   (let [[x y z] (if (number? s) [s s s] s)]
     (assoc _ :m00 x :m11 y :m22 z)))
  
  (set-rotation
   [_ [rx ry rz]] ;; TODO
   _)
  
  (determinant
   [_]
   (reduce
    clojure.core/+
    [(mc/det-item m30 m21 m12 m03 m20 m31 m12 m03 m30 m11 m22 m03 m10 m31 m22 m03)
     (mc/det-item m20 m11 m32 m03 m10 m21 m32 m03 m30 m21 m02 m13 m20 m31 m02 m13)
     (mc/det-item m30 m01 m22 m13 m00 m31 m22 m13 m20 m01 m32 m13 m00 m21 m32 m13)
     (mc/det-item m30 m11 m02 m23 m10 m31 m02 m23 m30 m01 m12 m23 m00 m31 m12 m23)
     (mc/det-item m10 m01 m32 m23 m00 m11 m32 m23 m20 m11 m02 m33 m10 m21 m02 m33)
     (mc/det-item m20 m01 m12 m33 m00 m21 m12 m33 m10 m01 m22 m33 m00 m11 m22 m33)]))
#+END_SRC
****** PInvert
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PInvert
  (invert
   [_]
   (let [n00 (clojure.core/- (clojure.core/* m00 m11) (clojure.core/* m01 m10))
         n01 (clojure.core/- (clojure.core/* m00 m12) (clojure.core/* m02 m10))
         n02 (clojure.core/- (clojure.core/* m00 m13) (clojure.core/* m03 m10))
         n03 (clojure.core/- (clojure.core/* m01 m12) (clojure.core/* m02 m11))
         n04 (clojure.core/- (clojure.core/* m01 m13) (clojure.core/* m03 m11))
         n05 (clojure.core/- (clojure.core/* m02 m13) (clojure.core/* m03 m12))
         n06 (clojure.core/- (clojure.core/* m20 m31) (clojure.core/* m21 m30))
         n07 (clojure.core/- (clojure.core/* m20 m32) (clojure.core/* m22 m30))
         n08 (clojure.core/- (clojure.core/* m20 m33) (clojure.core/* m32 m30))
         n09 (clojure.core/- (clojure.core/* m21 m32) (clojure.core/* m22 m31))
         n10 (clojure.core/- (clojure.core/* m21 m33) (clojure.core/* m23 m31))
         n11 (clojure.core/- (clojure.core/* m22 m33) (clojure.core/* m23 m32))
         d (clojure.core/+
            (clojure.core/-
             (clojure.core/+
              (clojure.core/+
               (clojure.core/-
                (clojure.core/* n00 n11) (clojure.core/* n01 n10))
               (clojure.core/* n02 n09))
              (clojure.core/* n03 n08))
             (clojure.core/* n04 n07))
            (clojure.core/* n05 n06))]
     (when-not (zero? d)
       (let [invd (/ 1.0 d)]
         (with-meta
           (Matrix44.
            (clojure.core/* invd (clojure.core/+ (clojure.core/- (clojure.core/* m11 n11) (clojure.core/* m12 n10)) (clojure.core/* m13 n09))) ;0
            (clojure.core/* invd (clojure.core/+ (clojure.core/- (clojure.core/* m02 n10) (clojure.core/* m03 n09)) (clojure.core/* (clojure.core/- m01) n11))) ;1
            (clojure.core/* invd (clojure.core/+ (clojure.core/- (clojure.core/* m31 n05) (clojure.core/* m32 n04)) (clojure.core/* m33 n03))) ;2
            (clojure.core/* invd (clojure.core/+ (clojure.core/- (clojure.core/* m22 n04) (clojure.core/* m23 n03)) (clojure.core/* (clojure.core/- m21) n05))) ;3
            (clojure.core/* invd (clojure.core/+ (clojure.core/- (clojure.core/* m12 n08) (clojure.core/* m13 n07)) (clojure.core/* (clojure.core/- m10) n11))) ;4
            (clojure.core/* invd (clojure.core/+ (clojure.core/- (clojure.core/* m00 n11) (clojure.core/* m02 n08)) (clojure.core/* m03 n07))) ;5
            (clojure.core/* invd (clojure.core/+ (clojure.core/- (clojure.core/* m32 n02) (clojure.core/* m33 n01)) (clojure.core/* (clojure.core/- m30) n05))) ;6
            (clojure.core/* invd (clojure.core/+ (clojure.core/- (clojure.core/* m20 n05) (clojure.core/* m22 n02)) (clojure.core/* m23 n01))) ;7
            (clojure.core/* invd (clojure.core/+ (clojure.core/- (clojure.core/* m10 n10) (clojure.core/* m11 n08)) (clojure.core/* m13 n06))) ;8
            (clojure.core/* invd (clojure.core/+ (clojure.core/- (clojure.core/* m01 n08) (clojure.core/* m03 n06)) (clojure.core/* (clojure.core/- m00) n10))) ;9
            (clojure.core/* invd (clojure.core/+ (clojure.core/- (clojure.core/* m30 n04) (clojure.core/* m31 n02)) (clojure.core/* m33 n00))) ;10
            (clojure.core/* invd (clojure.core/+ (clojure.core/- (clojure.core/* m21 n02) (clojure.core/* m23 n00)) (clojure.core/* (clojure.core/- m20) n04))) ;11
            (clojure.core/* invd (clojure.core/+ (clojure.core/- (clojure.core/* m11 n07) (clojure.core/* m12 n06)) (clojure.core/* (clojure.core/- m10) n09))) ;12
            (clojure.core/* invd (clojure.core/+ (clojure.core/- (clojure.core/* m00 n09) (clojure.core/* m01 n07)) (clojure.core/* m02 n06))) ;13
            (clojure.core/* invd (clojure.core/+ (clojure.core/- (clojure.core/* m31 n01) (clojure.core/* m32 n00)) (clojure.core/* (clojure.core/- m30) n03))) ;14
            (clojure.core/* invd (clojure.core/+ (clojure.core/- (clojure.core/* m20 n03) (clojure.core/* m21 n01)) (clojure.core/* m22 n00)))) ;15
           (meta _))))))
#+END_SRC
****** PTranspose
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
    PTranspose
    (transpose
     [_]
     (with-meta
       (Matrix44.
        m00 m10 m20 m30
        m01 m11 m21 m31
        m02 m12 m22 m32
        m03 m13 m23 m33)
       (meta _)))
#+END_SRC
****** PTransform
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PScale
  (scale
   [_ s]
   (* _ (set-scale ID44 s)))
  (scale
   [_ sx sy sz]
   (* _ (set-scale ID44 [sx sy sz])))
  
  PRotate
  (rotate
   [_ theta] (rotate-z _ theta))
  
  PRotate3D
  (rotate-x
   [_ theta]
   (let [s (Math/sin theta), c (Math/cos theta)]
     (* _ (assoc ID44 :m11 c :m12 (clojure.core/- s) :m21 s :m22 c))))
  (rotate-y
   [_ theta]
   (let [s (Math/sin theta), c (Math/cos theta)]
     (* _ (assoc ID44 :m00 c :m02 s :m20 (clojure.core/- s) :m22 c))))
  (rotate-z
   [_ theta]
   (let [s (Math/sin theta), c (Math/cos theta)]
     (* _ (assoc ID44 :m00 c :m01 (clojure.core/- s) :m10 s :m11 c))))
  (rotate-around-axis
   [_ [x y z] theta]
   (let [s (Math/sin theta), c (Math/cos theta)
         sx (clojure.core/* s x)
         sy (clojure.core/* s y)
         sz (clojure.core/* s z)
         t (clojure.core/- 1.0 c)
         tx (clojure.core/* t x)
         ty (clojure.core/* t y)]
     (* _
        (Matrix44.
         (clojure.core/+ (clojure.core/* tx x) c)
         (clojure.core/+ (clojure.core/* tx y) sz)
         (clojure.core/- (clojure.core/* tx z) sy) 0.0
         (clojure.core/- (clojure.core/* tx y) sz)
         (clojure.core/+ (clojure.core/* ty y) c)
         (clojure.core/+ (clojure.core/* ty z) sx) 0.0
         (clojure.core/+ (clojure.core/* tx z) sy)
         (clojure.core/- (clojure.core/* ty z) sx)
         (clojure.core/+ (clojure.core/* t z z) c) 0.0
         0.0 0.0 0.0 1.0))))
  
  PTranslate
  (translate
   [_ t]
   (* _ (set-position ID44 t)))
  
  PTransform
  (transform
   [_ matrix] (* _ matrix))
#+END_SRC
****** PVectorTransform
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PVectorTransform
  (transform-vector
   [_ [x y z :as v]]
   (vec3 (mc/mat-item x m00 y m01 z m02 m03)
         (mc/mat-item x m10 y m11 z m12 m13)
         (mc/mat-item x m20 y m21 z m22 m23)))
#+END_SRC
****** End of implementation
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
    )
#+END_SRC
**** Constants
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (def ^:const ID32
    (Matrix32.
     1.0 0.0 0.0
     0.0 1.0 0.0))

  (def ^:const ID44
    (Matrix44.
     1.0 0.0 0.0 0.0
     0.0 1.0 0.0 0.0
     0.0 0.0 1.0 0.0
     0.0 0.0 0.0 1.0))
#+END_SRC
**** Constructors
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defn matrix32
    ([] ID32)
    ([[m00 m01 m02 m10 m11 m12]]
       (Matrix32. m00 m01 m02 m10 m11 m12))
    ([m00 m01 m02 m10 m11 m12]
       (Matrix32. m00 m01 m02 m10 m11 m12)))

  (defn matrix44
    ([] ID44)
    ([[m00 m01 m02 m03 m10 m11 m12 m13 m20 m21 m22 m23 m30 m31 m32 m33]]
       (Matrix44. m00 m01 m02 m03 m10 m11 m12 m13 m20 m21 m22 m23 m30 m31 m32 m33))
    ([m00 m01 m02 m03 m10 m11 m12 m13 m20 m21 m22 m23 m30 m31 m32 m33]
       (Matrix44. m00 m01 m02 m03 m10 m11 m12 m13 m20 m21 m22 m23 m30 m31 m32 m33)))
#+END_SRC
*** Quaternion
**** Implementation
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (deftype Quaternion [^double x ^double y ^double z ^double w _meta]
#+END_SRC
***** Clojure protocols
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
    ,#+clj clojure.lang.IObj
    ,#+clj (meta [_] _meta)
    ,#+clj (withMeta [_ m*] (Quaternion. x y z w m*))
    ,#+cljs IMeta
    ,#+cljs (-meta [_] _meta)
    ,#+cljs IWithMeta
    ,#+cljs (-with-meta [_ m*] (Quaternion. x y z w m*))
#+END_SRC
***** PScale
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PScale
  (scale
   [_ s]
   (Quaternion.
    (clojure.core/* x s)
    (clojure.core/* y s)
    (clojure.core/* z s)
    (clojure.core/* w s) _meta))
#+END_SRC
***** PMatrix
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PMathOps
  (+ [_ q]
     (let [q ^Quaternion q]
       (Quaternion. (clojure.core/+ x (.-x q)) (clojure.core/+ y (.-y q)) (clojure.core/+ z (.-z q)) (clojure.core/+ w (.-w q)) _meta)))
  (- [_ q]
     (let [q ^Quaternion q]
       (Quaternion. (clojure.core/- x (.-x q)) (clojure.core/- y (.-y q)) (clojure.core/- z (.-z q)) (clojure.core/- w (.-w q)) _meta)))
  (* [_ q]
     (let [q ^Quaternion q
           qx (.-x q) qy (.-y q) qz (.-z q) qw (.-w q)]
       (Quaternion.
        (clojure.core/- (clojure.core/+ (clojure.core/+ (clojure.core/* x qw) (clojure.core/* w qx)) (clojure.core/* y qz)) (clojure.core/* z qy))
        (clojure.core/- (clojure.core/+ (clojure.core/+ (clojure.core/* y qw) (clojure.core/* w qy)) (clojure.core/* z qx)) (clojure.core/* x qz))
        (clojure.core/- (clojure.core/+ (clojure.core/+ (clojure.core/* z qw) (clojure.core/* w qz)) (clojure.core/* x qy)) (clojure.core/* y qx))
        (clojure.core/- (clojure.core/- (clojure.core/- (clojure.core/* w qw) (clojure.core/* x qx)) (clojure.core/* y qy)) (clojure.core/* z qz))
        _meta)))
#+END_SRC
***** PDotProduct
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx  
  PDotProduct
  (dot [_ q]
    (let [q ^Quaternion q]
      (clojure.core/+ (clojure.core/+ (clojure.core/+ (clojure.core/* x (.-x q)) (clojure.core/* y (.-y q))) (clojure.core/* z (.-z q))) (clojure.core/* w (.-w q)))))
#+END_SRC
***** PMagnitude
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PMagnitude
  (mag-squared [_]
    (clojure.core/+ (clojure.core/+ (clojure.core/+ (clojure.core/* x x) (clojure.core/* y y)) (clojure.core/* z z)) (clojure.core/* w w)))
  (mag [_]
    (Math/sqrt (clojure.core/+ (clojure.core/+ (clojure.core/+ (clojure.core/* x x) (clojure.core/* y y)) (clojure.core/* z z)) (clojure.core/* w w))))
#+END_SRC
***** PNormalize
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PNormalize
  (normalize [_]
    (let [mag (clojure.core/+ (clojure.core/+ (clojure.core/+ (clojure.core/* x x) (clojure.core/* y y)) (clojure.core/* z z)) (clojure.core/* w w))]
      (if (> mag *eps*)
        (let [m (/ mag)]
          (Quaternion. (clojure.core/* x m) (clojure.core/* y m) (clojure.core/* z m) (clojure.core/* w m) _meta))
        _)))
#+END_SRC
***** PInvert
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PInvert
  (invert [_]
    (let [d (mag-squared _)
          d (if (zero? d) 0.0 (/ d))
          id (clojure.core/- d)]
      (Quaternion. (clojure.core/* x id) (clojure.core/* y id) (clojure.core/* z id) (clojure.core/* w d) _meta)))
#+END_SRC
***** PInterpolate
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PInterpolate
  (mix [_ q] (mix _ q 0.5))
  (mix [_ q t]
    (let [d (dot _ q)]
      (if (>= (m/abs d) 1.0)
        _
        (let [theta (Math/acos d)
              stheta (Math/sqrt (clojure.core/- 1.0 (clojure.core/* d d)))
              [a b] (if (< (m/abs stheta) 0.001)
                      [0.5 0.5]
                      [(/ (Math/sin (clojure.core/* theta (clojure.core/- 1.0 t))) stheta)
                       (/ (Math/sin (clojure.core/* theta t)) stheta)])
              q ^Quaternion q]
          (Quaternion.
           (m/madd x a (clojure.core/* (.-x q) b))
           (m/madd y a (clojure.core/* (.-y q) b))
           (m/madd z a (clojure.core/* (.-z q) b))
           (m/madd w a (clojure.core/* (.-w q) b))
           _meta)))))
#+END_SRC
***** PMatrixConvert
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PMatrixConvert
  (as-matrix [_]
    (let [x2 (clojure.core/+ x x) y2 (clojure.core/+ y y) z2 (clojure.core/+ z z)
          xx (clojure.core/* x x2) xy (clojure.core/* x y2) xz (clojure.core/* x z2)
          yy (clojure.core/* y y2) yz (clojure.core/* y z2) zz (clojure.core/* z z2)
          wx (clojure.core/* w x2) wy (clojure.core/* w y2) wz (clojure.core/* w z2)]
      (Matrix44.
       (clojure.core/- 1.0 (clojure.core/+ yy zz)) (clojure.core/+ xy wz) (clojure.core/- xz wy) 0.0
       (clojure.core/- xy wz) (clojure.core/- 1.0 (clojure.core/+ xx zz)) (clojure.core/+ yz wx) 0.0
       (clojure.core/+ xz wy) (clojure.core/- yz wx) (clojure.core/- 1.0 (clojure.core/+ xx yy)) 0.0
       0.0 0.0 0.0 1.0)))
#+END_SRC
***** PVectorTransform
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PVectorTransform
  (transform-vector
   [_ [vx vy vz :as v]]
   (let [ix (clojure.core/-
             (clojure.core/+ (clojure.core/* w vx) (clojure.core/* y vz))
             (clojure.core/* z vy))
         iy (clojure.core/-
             (clojure.core/+ (clojure.core/* w vy) (clojure.core/* z vx))
             (clojure.core/* x vz))
         iz (clojure.core/-
             (clojure.core/+ (clojure.core/* w vz) (clojure.core/* x vy))
             (clojure.core/* y vx))
         iw (clojure.core/-
             (clojure.core/- (clojure.core/* (clojure.core/- x) vx) (clojure.core/* y vy))
             (clojure.core/* z vz))]
     (Vec3.
      (clojure.core/-
       (clojure.core/+
        (clojure.core/+ (clojure.core/* ix w) (clojure.core/* iw (clojure.core/- x)))
        (clojure.core/* iy (clojure.core/- z))) (clojure.core/* iz (clojure.core/- y)))
      (clojure.core/-
       (clojure.core/+
        (clojure.core/+ (clojure.core/* iy w) (clojure.core/* iw (clojure.core/- y)))
        (clojure.core/* iz (clojure.core/- x))) (clojure.core/* ix (clojure.core/- z)))
      (clojure.core/-
       (clojure.core/+
        (clojure.core/+ (clojure.core/* iz w) (clojure.core/* iw (clojure.core/- z)))
        (clojure.core/* ix (clojure.core/- y))) (clojure.core/* iy (clojure.core/- x)))
      (meta v))))
#+END_SRC
***** End of implementation
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
    )
#+END_SRC
**** Constructors
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defn quat
    ([[x y z] w] (Quaternion. x y z w nil))
    ([[x y z w]] (Quaternion. x y z w nil))
    ([x y z w] (Quaternion. x y z w nil)))
  
  (defn quat-from-axis-angle
    [axis theta]
    (let [theta (clojure.core/* theta 0.5)]
      (quat (normalize (vec3 axis) (Math/sin theta)) (Math/cos theta))))
  
  (defn quat-from-euler
    [^double pitch ^double yaw ^double roll]
    (let [pitch (clojure.core/* pitch 0.5) yaw (clojure.core/* yaw 0.5) roll (clojure.core/* roll 0.5)
          sp (Math/sin pitch) cp (Math/cos pitch)
          sy (Math/sin yaw) cy (Math/cos yaw)
          sr (Math/sin roll) cr (Math/cos roll)
          spsy (clojure.core/* sp sy) cpcy (clojure.core/* cp cy)]
      (Quaternion.
       (clojure.core/- (clojure.core/* sr cpcy) (clojure.core/* cr spsy))
       (clojure.core/+ (clojure.core/* (clojure.core/* cr sp) cy) (clojure.core/* (clojure.core/* sr cp) sy))
       (clojure.core/- (clojure.core/* (clojure.core/* cr cp) sy) (clojure.core/* (clojure.core/* sr sp) cy))
       (clojure.core/+ (clojure.core/* cr cpcy) (clojure.core/* sr spsy))
       nil)))
  
  (defn quat-from-matrix44
    [^Matrix44 m]
    (let [trace (clojure.core/+ (clojure.core/+ (.-m00 m) (.-m11 m)) (.-m22 m))]
      (if (pos? trace)
        (let [s (Math/sqrt (clojure.core/+ 1.0 trace))
              w (clojure.core/* s 0.5)
              s (/ -0.5 s)]
          (Quaternion.
           (m/madd (.-m21 m) s (.-m12 m))
           (m/madd (.-m02 m) s (.-m20 m))
           (m/madd (.-m10 m) s (.-m01 m))
           w nil))
        (let [[i mi] (if (> (.-m11 m) (.-m00 m))
                       [1 (.-m11 m)] [0 (.-m00 m)])
              [i mi] (if (> (.-m22 m) mi)
                       [2 (.-m22 m)] [i mi])]
          (condp = i
            0 (let [s (Math/sqrt (clojure.core/+ 1.0 (clojure.core/+ (clojure.core/- mi (.-m11 m)) (.-m22 m))))
                    x (clojure.core/* s 0.5)
                    s (/ 0.5 s)]
                (Quaternion. ; i=0 j=1 k=2
                 x
                 (clojure.core/* (clojure.core/+ (.-m10 m) (.-m01 m)) s)
                 (clojure.core/* (clojure.core/+ (.-m20 m) (.-m02 m)) s)
                 (clojure.core/* (clojure.core/- (.-m21 m) (.-m12 m)) s) nil))
            1 (let [s (Math/sqrt (clojure.core/+ 1.0 (clojure.core/+ (clojure.core/- mi (.-m22 m)) (.-m00 m))))
                    x (clojure.core/* s 0.5)
                    s (/ 0.5 s)]
                (Quaternion. ; i=1 j=2 k=0
                 (clojure.core/* (clojure.core/+ (.-m10 m) (.-m01 m)) s)
                 x
                 (clojure.core/* (clojure.core/+ (.-m12 m) (.-m21 m)) s)
                 (clojure.core/* (clojure.core/- (.-m20 m) (.-m02 m)) s) nil))
            2 (let [s (Math/sqrt (clojure.core/+ 1.0 (clojure.core/+ (clojure.core/- mi (.-m00 m)) (.-m11 m))))
                    x (clojure.core/* s 0.5)
                    s (/ 0.5 s)]
                (Quaternion. ; i=2 j=0 k=1
                 (clojure.core/* (clojure.core/+ (.-m20 m) (.-m02 m)) s)
                 (clojure.core/* (clojure.core/+ (.-m21 m) (.-m12 m)) s)
                 x
                 (clojure.core/* (clojure.core/- (.-m01 m) (.-m10 m)) s) nil)))))))
  
  (defn alignment-quat
    [target forward]
    (let [target (normalize target)
          forward (normalize forward)
          axis (cross forward target)
          len (mag axis)
          theta (Math/atan2 len (dot forward target))]
      (quat-from-axis-angle axis theta)))
#+END_SRC
** Constants
*** Default circle resolution
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (def ^:dynamic *resolution* 20)
#+END_SRC
**** TODO Binding macro
#+BEGIN_SRC clojure
  ;; :tangle babel/src-cljs/thi/ng/geom/macros.clj
  (defmacro with-resolution
    [res & body]
    (binding [*resolution* res] ~@body))
#+END_SRC
** Shared functions
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defn closest-point*
    [lines q]
    (reduce (fn [a b]
              (if (< (dist-squared q a) (dist-squared q b)) a b))
            (map #(closest-point % q) lines)))

  (defn from-barycentric*
    [points weights]
    (reduce + (map * points weights)))

  (defn centroid*
    [coll]
    (when (seq coll)
      (* (reduce + coll) (/ 1.0 (count coll)))))

  (defn bounding-rect*
    ([coll]
       (let [c (count coll)]
         (cond
          (> c 1) (let [p (reduce min coll)
                        q (reduce max coll)
                        [w h] (- q p)]
                    (thi.ng.geom.types.Rect. p w h))
          (= c 1) (thi.ng.geom.types.Rect. (first coll) 0.0 0.0)
          :default nil)))
    ([p w h] (thi.ng.geom.types.Rect. p w h)))

  (defn bounding-box*
    ([coll]
       (let [cnt (count coll)]
         (cond
          (> cnt 1) (let [p (reduce min coll)
                          q (reduce max coll)]
                      (thi.ng.geom.types.AABB. p q))
          (= cnt 1) (thi.ng.geom.types.AABB. (first coll) [0.0 0.0 0.0])
          :default nil)))
    ([p q] (thi.ng.geom.types.AABB. p (- q p))))

  (defn max-dist*
    [c points]
    (->> points
         (map #(dist-squared c %))
         (reduce clojure.core/max)
         (Math/sqrt)))

  (defn bounding-circle*
    [c r-or-points]
    (thi.ng.geom.types.Circle.
     (vec2 c)
     (if (coll? r-or-points)
       (max-dist* c r-or-points)
       r-or-points)))

  (defn bounding-sphere*
    [c r-or-points]
    (thi.ng.geom.types.Sphere.
     (vec3 c)
     (if (coll? r-or-points)
       (max-dist* c r-or-points)
       r-or-points)))

  (defn axis-bounds*
    [axis coll]
    (let [xs (map #(nth % axis) coll)]
      [(reduce clojure.core/min xs) (reduce clojure.core/max xs)]))

  (defn axis-range*
    [axis coll]
    (let [xs (map #(nth % axis) coll)]
      (clojure.core/- (reduce clojure.core/max xs) (reduce clojure.core/min xs))))

  ;; TODO rename into arc-length-index*
  (defn total-length*
    [points]
    (->> points
         (d/successive-nth 2)
         (map #(dist (% 0) (% 1)))
         (reductions clojure.core/+ 0)
         (vec)))

  (defn arc-length*
    [points]
    (->> points
         (d/successive-nth 2)
         (map #(dist (% 0) (% 1)))
         (reduce clojure.core/+)))

  (defn sample-uniform*
    [udist include-last? points]
    (let [idx (total-length* points)
          total (peek idx)
          delta (/ udist total)
          samples (loop [t 0.0 i 1 acc []]
                    (if (< t 1.0)
                      (let [ct (* t total)
                            i (int (loop [i i] (if (>= ct (idx i)) (recur (inc i)) i)))
                            p (nth points (dec i))
                            q (nth points i)
                            pi (idx (dec i))
                            frac (/ (clojure.core/- ct pi) (clojure.core/- (idx i) pi))]
                        (recur (clojure.core/+ t delta) i (conj acc (mix p q frac))))
                      acc))]
      (if include-last?
        (conj samples (last points))
        samples)))

  (defn point-at*
    ([t points] (point-at* t points nil))
    ([t points idx]
       (when (m/in-range? 0.0 1.0 t)
         (let [n (count points)
               t (double t)]
           (cond
            (= 0 n) nil
            (= 1 n) (first points)
            (= 1.0 t) (last points)
            :default (let [idx (or idx (total-length* points))
                           total (peek idx)
                           ct (* t total)
                           i (loop [i 1] (if (>= ct (idx i)) (recur (inc i)) i))
                           p (nth points (dec i))
                           q (nth points i)
                           pi (idx (dec i))
                           frac (/ (clojure.core/- ct pi) (clojure.core/- (idx i) pi))]
                       (mix p q frac)))))))

  (defn edges*
    [ctor points]
    (->> points (d/successive-nth 2) (mapv ctor)))

  (defn tessellate*
    [c points]
    (->> [(first points)]
         (concat points)
         (d/successive-nth 2)
         (map #(vector (% 0) c (% 1)))))

  (defn normal3*
    ([a b c] (normalize (cross (- b a) (- c a))))
    ([[a b c]] (normalize (cross (- b a) (- c a)))))
#+END_SRC
** Matrix functions
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defn frustum
    "Sets up a viewing frustum, shaped like a truncated pyramid with the
    camera where the tip of the pyramid would be.
    This emulates the OpenGL function glFrustum()."
    [l t r b n f]
    (let [dx (clojure.core/- r l)
          dy (clojure.core/- t b)
          dz (clojure.core/- f n)]
      (Matrix44.
       (/ (* 2.0 n) dx) 0.0 (/ (clojure.core/+ r l) dx) 0.0
       0.0 (/ (* 2.0 n) dy) (/ (clojure.core/+ t b) dy) 0.0
       0.0 0.0 (* -1.0 (/ (clojure.core/+ f n) dz)) (/ (* (* -2.0 f) n) dz)
       0.0 0.0 -1.0 0.0)))

  (defn frustum-bounds
    [fov aspect near]
    (let [rad (* 0.5 (m/radians fov))
          top (* near (Math/tan rad))
          right (* top aspect)]
      {:left (clojure.core/- right)
       :right right
       :top top
       :bottom (clojure.core/- top)}))

  (defn ortho
    "Returns an orthographic projection matrix, in which objects are the same size no
    matter how far away or nearby they are.
    This emulates the OpenGL function glOrtho()."
    [l t r b n f]
    (let[dx (clojure.core/- r l)
         dy (clojure.core/- t b)
         dz (clojure.core/- f n)]
      (Matrix44.
       (/ 2.0 dx) 0.0 0.0 (clojure.core/- (/ (clojure.core/+ r l) dx))
       0.0 (/ 2.0 dy) 0.0 (clojure.core/- (/ (clojure.core/+ t b) dy))
       0.0 0.0 (/ -2.0 dz) (clojure.core/- (/ (clojure.core/+ f n) dz))
       0.0 0.0 0.0 1.0)))

  (defn perspective
    "Returns a perspective transform matrix, which makes far away objects appear
    smaller than nearby objects. The `aspect` argument should be the width
    divided by the height of your viewport and `fov` is the vertical angle
    of the field of view in degrees.
    This emulates the OpenGL function gluPerspective()."
    [fov aspect near far]
    (let [rad (* 0.5 (m/radians fov))
          cot (/ (Math/cos rad) (Math/sin rad))
          deltaz (clojure.core/- far near)
          a (/ cot aspect)
          b (clojure.core/- (/ (clojure.core/+ far near) deltaz))
          c (/ (* -2.0 near far) deltaz)]
      (Matrix44.
       a 0.0 0.0 0.0
       0.0 cot 0.0 0.0
       0.0 0.0 b c
       0.0 0.0 -1.0 0.0)))

  (defn perspective-frustum
    [fov aspect near far]
    (let [{:keys [left right top bottom]} (frustum-bounds fov aspect near)]
      (frustum left top right bottom near far)))

  (defn look-at
    "Returns a matrix that puts the camera at the eye position looking
    toward the target point with the given up direction.
    This emulates the OpenGL function `gluLookAt()`."
    [eye target upvec]
    (let [[fx fy fz :as f] (normalize (- eye target))
          [sx sy sz :as s] (normalize (cross upvec f))
          [tx ty tz :as t] (normalize (cross f s))]
      (Matrix44.
       sx sy sz (clojure.core/- (dot s eye))
       tx ty tz (clojure.core/- (dot t eye))
       fx fy fz (clojure.core/- (dot f eye))
       0.0 0.0 0.0 1.0)))
#+END_SRC
