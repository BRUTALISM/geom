#+SEQ_TODO:       TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:           write(w) update(u) fix(f) verify(v) noexport(n)
#+EXPORT_EXCLUDE_TAGS: noexport

* Namespace: thi.ng.geom.core
  Providing an easy-to-use & easy-to-learn API for both common and
  advanced geometry operations is one of this project's main focal
  points. We attempt to realise this by defining all operations in
  the form of protocols which are then implemented by various core
  types.

  This namespace contains all basic vector operations and core
  protocols related to common higher level geometric operations.

#+INCLUDE: "types.org" :minlevel 3

** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx :mkdirp yes :padline no
  (ns thi.ng.geom.core
    (:refer-clojure :exclude [* - + min max])
    (:require
     [thi.ng.common.data.core :as d]
     [thi.ng.common.error :as err]
     [thi.ng.common.math.core :as m :refer [*eps* PI TWO_PI]]
     [thi.ng.geom.types :as types]
     ,#+clj [thi.ng.macromath.core :as mc]
     ,#+clj [thi.ng.geom.macros.core :as gmc])
    ,#+cljs
    (:require-macros
     [thi.ng.macromath.core :as mc]
     [thi.ng.geom.macros.core :as gmc])
    ,#+clj
    (:import
     [thi.ng.geom.types Circle Rect AABB Sphere]))
#+END_SRC
** Core implementations
*** Protocols
**** Math operations
***** PMathOps
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PMathOps
    (+ [_] [_ a] [_ a b] [_ a b c])
    (- [_] [_ a] [_ a b] [_ a b c])
    (* [_] [_ a] [_ a b] [_ a b c])
    (div [_] [_ a] [_ a b] [_ a b c])
    (madd [_ a b])
    (abs [_]))
#+END_SRC
***** PConjugate
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PConjugate
    (conjugate [_]))
#+END_SRC
***** PCrossProduct
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PCrossProduct
    (cross [_ a]))
#+END_SRC
***** PDeterminant
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PDeterminant
    (determinant [_]))
#+END_SRC
***** PDistance
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PDistance
    (dist [_ a])
    (dist-squared [_ a]))
#+END_SRC
***** PDotProduct
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PDotProduct
    (dot [_ a]))
#+END_SRC
***** PHeading
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PHeading
    (heading-xy [_])
    (heading-xz [_])
    (heading-yz [_])
    (angle-between [_ a])
    (normal [_] [_ a])
    (slope-xy [_])
    (slope-xz [_])
    (slope-yz [_]))
#+END_SRC
***** PInterpolate
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PInterpolate
    (mix [_ x] [_ x t]))
#+END_SRC
***** PInvert
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PInvert
    (invert [_]))
#+END_SRC
***** PSetOps
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PSetOps
    (union [_ x])
    (intersection [_ y])
    (difference [_ x]))
#+END_SRC
***** PLimit
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PLimit
    (limit [_ x]))
#+END_SRC
***** PMagnitude
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PMagnitude
    (mag [_])
    (mag-squared [_]))
#+END_SRC
***** PMatrixConvert
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PMatrixConvert
    (as-matrix [_]))
#+END_SRC
***** PMinMax
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PMinMax
    (min [_ x] [_ a b])
    (max [_ y] [_ a b]))
#+END_SRC
***** PNormalize
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PNormalize
    (normalize [_] [_ len])
    (normalized? [_]))
#+END_SRC
***** PTranspose
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PTranspose
    (transpose [_]))
#+END_SRC
**** Spatial transform operations
     The position, size and orientation of spatial entities can
     usually be manipulated via the three basic operations: rotate,
     scale & translate. Other, more complex transformations can be
     achieved through combination and repetition of these.
***** PPolar
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PPolar
    (as-polar [_])
    (as-cartesian [_]))
#+END_SRC
***** PReflect
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PReflect
    (reflect [_ r]))
#+END_SRC
***** PRotate & PRotate3D
  Rotation is always relative to the world origin. For 2D
  implementations, the rotation angle \theta (theta) is always
  interpreted clockwise and only the =rotate= method is
  implemented.
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PRotate
    (rotate [_ t]))

  (defprotocol PRotate3D
    (rotate-x [_ t])
    (rotate-y [_ t])
    (rotate-z [_ t])
    (rotate-around-axis [_ a t]))
#+END_SRC
***** PScale
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx 
  (defprotocol PScale
    (scale [_ s] [_ a b] [_ a b c])
    (scale-size [_ s]))
#+END_SRC
***** PShear
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx 
  (defprotocol PShear
    (shear [_ s] [_ sx sy] [_ sx sy sz]))
#+END_SRC
***** PTransform
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx 
  (defprotocol PTransform
    (transform [_ matrix]))
#+END_SRC
***** PTranslate
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx 
  (defprotocol PTranslate
    (translate [_ t] [_ x y] [_ x y z]))
#+END_SRC
***** PVectorTransform
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PVectorTransform
    (transform-vector [_ v]))
#+END_SRC
**** Graph operations
Most geometric shape constructs can be understood as an undirected
graph of vertices, connected by edges. This protocol provides read
access to entities in _ context.
***** PGraph
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PGraph
    (connected-components [_])
    (cyclic? [_])
    (edges [_] [_ n])
    (vertices [_] [_ n])
    (vertex-valence [_ v])
    (vertex-neighbors [_ v])
    (remove-vertex [_ v])
    (replace-vertex [_ a b])
    (merge-vertices [_ a b]))
#+END_SRC
***** PDirectedGraph
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PDirectedGraph
    (in-vertices [_ v])
    (out-vertices [_ v]))
#+END_SRC
***** PGraphConvert
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PGraphConvert
    (as-graph [_] [_ opts]))
#+END_SRC
**** Shape based & structural operations
***** PAlign
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PAlign
    (align-with [_ x opts]
      "Returns updated entity aligned with `x` in the specified manner"))
#+END_SRC
***** PArea
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PArea
    (area [_]
      "Returns an entity's total surface area"))
#+END_SRC
***** PBoundary
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PBoundary
    (contains-point? [_ p])
    (contains-entity? [_ s]))
#+END_SRC
***** PBoundingCircle
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PBoundingCircle
    (bounding-circle [_]))
#+END_SRC
***** PBoundingSphere
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PBoundingSphere
    (bounding-sphere [_]))
#+END_SRC
***** PBounds
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PBounds
    (bounds [_]
      "Returns bounding rect for 2d entities or box for 3d")
    (width [_]
      "Returns entity's extent along X axis")
    (height [_]
      "Returns entity's extent along Y axis")
    (depth [_]
      "Returns entity's extent along Z (zero for 2d)"))
#+END_SRC
***** PCenter
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PCenter
    (center [_] [_ p]
      "Returns updated entity centered around world origin or given point")
    (centroid [_]
      "Returns centroid of entity"))
#+END_SRC
***** PCircumference
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PCircumference
    (circumference [_]
      "Returns an entity's circumference"))
#+END_SRC
***** PClassify
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PClassify
    (classify-point [_ p]))
#+END_SRC
***** PClip
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PClip
    (clip-with [_ s]))
#+END_SRC
***** PConvexHull
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PConvexHull
    (convex-hull [_]))
#+END_SRC
***** PExtrude
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PExtrude
    (extrude [_ opts])
    (extrude-shell [_ opts]))
#+END_SRC
***** PFlip
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PFlip
    (flip [_]))
#+END_SRC
***** PIntersect
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PIntersect
    (intersect-line [_ l] [_ p q])
    (intersect-ray [_ r] [_ p dir])
    (intersect-shape [_ s]))
#+END_SRC
***** PMeshConvert
       Anything which can be turned into a 2D or 3D mesh will implement _
       protocol consisting of just _ one function: =as-mesh=.
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PMeshConvert
    (as-mesh [_] [_ opts]
      "Transforms the current enitity into a Mesh instance"))
 #+END_SRC
***** PPolygonConvert
       Anything which can be turned into a polygon will implement _
       protocol consisting of just _ one function: =as-polygon=.
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PPolygonConvert
    (as-polygon [_] [_ res]
      "Transforms current entity into a Polygon instance"))
#+END_SRC
***** PProximity
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PProximity
    (closest-point [_ p]))
#+END_SRC
***** PSample
****** TODO move random-point-inside into PBoundary
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PSample
    (point-at [_ t] [_ u v])
    (random-point [_])
    (random-point-inside [_])
    (sample-uniform [_ dist include-last?])
    (sample-with-resolution [_ res]))
#+END_SRC
***** PSlice
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PSlice
    (slice-with [_ e] [_ e classifier] [_ e classifier parts]))
#+END_SRC
***** PSubdivide
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PSubdivide
    (subdivide [_] [_ opts])
    (subdivide-edge [_ a b splits])
    (subdivide-face [_ f p displace splits]))
#+END_SRC
***** PTessellate
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PTessellate
    (tessellate [_] [_ opts]))
#+END_SRC
***** PVolume
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PVolume
    (volume [_]
      "Returns an entity's inner volume."))
#+END_SRC
**** Type specific operations
***** PCurve
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PCurve
    (arc-length [_])
    (auto-spline [_]))
#+END_SRC
***** PMesh
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defprotocol PMesh
    (faces [_])
    (vertex-faces [_ v])
    (add-face [_ f])
    (remove-face [_ f])
    (add-mesh [_ m])
    (compute-face-normals [_])
    (compute-vertex-normals [_]))
#+END_SRC
*** Vector implementations
    For performance reasons, we decided to define custom datatypes
    for handling vectors & matrices. These types can be used much
    like standard Clojure vectors since they all implement the same
    protocols and interfaces, but also provide implementations for
    [[PVector]] and provide custom key lookups to provide swizzling features.

    Furthermore, since we aim for full ClojureScript compatibiliy,
    the following implementations are quite lengthy.
**** Declarations
    Some functions used by the following vector types will be
    defined further on, but need to be declared already.
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (declare vec2 swizzle2 swizzle2-assoc)
  (declare vec3 swizzle3 swizzle3-assoc)
  (declare M32 M44)
  (declare vec2-op-1 vec2-op-2 vec2-op-2* vec2-op-3)
  (declare vec3-op-1 vec3-op-2 vec3-op-3)
#+END_SRC
**** Protocol helpers
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  #+clj
  (defn map-entry [k ^double v]
    (reify
      clojure.lang.IMapEntry
      java.util.Map$Entry

      (key [_] k)
      (getKey [_] k)

      (val [_] v)
      (getValue [_] v)

      (hashCode [_]
        (bit-xor (clojure.lang.Util/hash k) (clojure.lang.Util/hash v)))
      (equals [_ x]
        (and (instance? java.util.Map$Entry x)
             (clojure.lang.Util/equals k (.getKey ^java.util.Map$Entry x))
             (clojure.lang.Util/equals v (.getValue ^java.util.Map$Entry x))))))
#+END_SRC
**** 2D
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx :mkdirp yes
  (deftype Vec2
    ,#+clj [^double x ^double y _meta]
    ,#+cljs [x y _meta]
#+END_SRC
***** Clojure protocols
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  ,#+clj clojure.lang.IObj
  ,#+clj (meta
         [_]_meta)
  ,#+clj (withMeta
         [_ m*] (Vec2. x y m*))
  
  ,#+clj clojure.lang.ILookup
  ,#+clj (valAt
         [_ k] (swizzle2 _ k nil))
  ,#+clj (valAt
         [_ k nf] (swizzle2 _ k nf))
  
  ,#+clj java.util.concurrent.Callable
  ,#+clj (call
         [_] (.invoke ^clojure.lang.IFn _))
  ,#+clj java.lang.Runnable
  ,#+clj (run
         [_] (.invoke ^clojure.lang.IFn _))
  
  ,#+clj clojure.lang.IFn
  ,#+clj (invoke
         [_ k] (swizzle2 _ k nil))
  ,#+clj (invoke
         [_ k nf] (swizzle2 _ k nf))
  ,#+clj (applyTo
         [_ args]
         (condp = (count args)
           1 (swizzle2 _ (first args) nil)
           2 (swizzle2 _ (first args) (second args))
           (err/arity-error! (count args))))
  
  ,#+clj clojure.lang.IMapEntry
  ,#+clj java.util.Map$Entry
  ,#+clj (key
         [_] x)
  ,#+clj (getKey
         [_] x)
  ,#+clj (val
         [_] y)
  ,#+clj (getValue
         [_] y)
  
  ,#+clj clojure.lang.Associative
  ,#+clj clojure.lang.IPersistentVector
  ,#+clj (count
         [_] 2)
  ,#+clj (length
         [_] 2)
  ,#+clj (containsKey
         [_ k] (not (nil? (#{0 1 :x :y} k))))
  ,#+clj (entryAt
         [_ k] (map-entry k (case (int k) 0 x, 1 y, (err/key-error! k))))
  ,#+clj (assoc
            [_ k v] (swizzle2-assoc _ k v))
  ,#+clj (assocN
         [_ k v] (case (int k) 0 (Vec2. v y _meta), 1 (Vec2. x v _meta), (err/key-error! k)))
  
  ,#+clj java.util.Collection
  ,#+clj (isEmpty
         [_] false)
  ,#+clj (iterator
         [_] (.iterator ^java.util.Collection (list x y)))
  ,#+clj (toArray
         [_] (double-array 2 [x y]))
  ,#+clj (size [_] 2)
  
  ,#+clj clojure.lang.IPersistentCollection
  ,#+clj clojure.lang.Indexed
  ,#+clj clojure.lang.Sequential
  ,#+clj clojure.lang.ISeq
  ,#+clj clojure.lang.Seqable
  ,#+clj (first
         [_] x)
  ,#+clj (next
         [_] (cons y nil))
  ,#+clj (more
         [_] (cons y nil))
  ,#+clj (cons
         [_ z] (with-meta (vec3 x y z) _meta))
  ,#+clj (peek
         [_] y)
  ,#+clj (pop
         [_] [x])
  ,#+clj (rseq
         [_] (Vec2. y x _meta))
  ,#+clj (seq
         [_] _)
  ,#+clj (nth
         [_ n] (case (int n) 0 x, 1 y, (err/key-error! n)))
  ,#+clj (nth
         [_ n nf] (case (int n) 0 x, 1 y, nf))
  ,#+clj (equiv
         [_ o]
         (if (instance? Vec2 o)
           (and (clojure.lang.Numbers/equiv x (.-x ^Vec2 o))
                (clojure.lang.Numbers/equiv y (.-y ^Vec2 o)))
           (and (instance? java.util.Collection o)
                (= 2 (count o))
                (clojure.lang.Util/equiv x (nth o 0))
                (clojure.lang.Util/equiv y (nth o 1)))))
  ,#+clj (equals
         [_ o]
         (if (instance? Vec2 o)
           (and (clojure.lang.Util/equals x (.-x ^Vec2 o))
                (clojure.lang.Util/equals y (.-y ^Vec2 o)))
           (and (instance? java.util.Collection o)
                (= 2 (count o))
                (clojure.lang.Util/equals x (nth o 0))
                (clojure.lang.Util/equals y (nth o 1)))))
  
  ;; http://docs.oracle.com/javase/7/docs/api/java/util/List.html#hashCode()
  ,#+clj (hashCode
         [_]
         (-> 31
             (unchecked-add-int (hash x))
             (unchecked-multiply-int 31)
             (unchecked-add-int (hash y))))
  
  ;; http://clojure.org/data_structures#hash
  ,#+clj clojure.lang.IHashEq
  ,#+clj (hasheq
         [_]
         (-> 31
             (unchecked-add-int (hash x))
             (unchecked-multiply-int 31)
             (unchecked-add-int (hash y))
             (mix-collection-hash 2)))
  
  Object
  (toString
   [_] (str "[" x " " y "]"))
#+END_SRC
***** ClojureScript protocols
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  ,#+cljs IMeta
  ,#+cljs (-meta
          [_] _meta)
  ,#+cljs IWithMeta
  ,#+cljs (-with-meta
          [_ m*] (Vec2. x y m*))
  
  ,#+cljs ICloneable
  ,#+cljs (-clone
          [_] (Vec2. x y _meta))
  
  ,#+cljs ILookup
  ,#+cljs (-lookup
          [_ k] (swizzle2 _ k nil))
  ,#+cljs (-lookup
          [_ k nf] (swizzle2 _ k nf))
  
  ,#+cljs IFn
  ,#+cljs (-invoke
          [_ k] (swizzle2 _ k nil))
  ,#+cljs (-invoke
          [_ k nf] (swizzle2 _ k nf))
  
  ,#+cljs ICounted
  ,#+cljs (-count
          [_] 2)
  
  ,#+cljs IAssociative
  ,#+cljs (-contains-key?
          [_ k] (not (nil? (#{0 1 :x :y} k))))
  ,#+cljs (-assoc
          [_ k v] (swizzle2-assoc _ k v))
  
  ,#+cljs IVector
  ,#+cljs (-assoc-n
          [_ k v] (case k 0 (Vec2. v y _meta), 1 (Vec2. x v _meta), (err/key-error! k)))
  
  ,#+cljs ISequential
  ,#+cljs ISeq
  ,#+cljs (-first
          [_] x)
  ,#+cljs (-rest
          [_] (cons y nil))
  
  ,#+cljs INext
  ,#+cljs (-next
          [_] (cons y nil))
  
  ,#+cljs ISeqable
  ,#+cljs (-seq
          [_] _)
  
  ,#+cljs IReversible
  ,#+cljs (-rseq
          [_] (Vec2. y x _meta))
  
  ,#+cljs IIndexed
  ,#+cljs (-nth
          [_ n] (case n 0 x, 1 y, (err/key-error! n)))
  ,#+cljs (-nth
          [_ n nf] (case n 0 x, 1 y, nf))
  
  ,#+cljs ICollection
  ,#+cljs (-conj
          [_ z] (with-meta (vec3 x y z) _meta))
  
  ,#+cljs IStack
  ,#+cljs (-peek
          [_] y)
  ,#+cljs (-pop
          [_] [x])
  
  ,#+cljs IComparable
  ,#+cljs (-compare
          [_ o]
          (if (instance? Vec2 o)
            (let [c (compare x (.-x ^Vec2 o))]
              (if (== 0 c) (compare y (.-y ^Vec2 o)) c))
            (let [c (count o)]
              (if (= 2 c) (compare o _) (- 2 c)))))
  
  ,#+cljs IHash
  ,#+cljs (-hash
          [_] (hash-combine (hash x) (hash y)))
  
  ,#+cljs IEquiv
  ,#+cljs (-equiv
          [_ o]
          (if (instance? Vec2 o)
            (and (== x (.-x ^Vec2 o)) (== y (.-y ^Vec2 o)))
            (and (sequential? o) (= 2 (count o))
                 (= x (nth o 0)) (= y (nth o 1)))))
#+END_SRC
***** Transformations
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PScale
  (scale
   [_ a] (vec2-op-1 clojure.core/* _ a 1.0 _meta))
  (scale
   [_ a b] (vec2-op-2 clojure.core/* _ a b 1.0 1.0 _meta))
  (scale
   [_ a b c] (vec2-op-3 clojure.core/* _ a b c 1.0 _meta))
  
  PTranslate
  (translate
   [_ a] (vec2-op-1 clojure.core/+ _ a 0.0 _meta))
  (translate
   [_ a b] (vec2-op-2 clojure.core/+ _ a b 0.0 0.0 _meta))
  (translate
   [_ a b c] (vec2-op-3 clojure.core/+ _ a b c 0.0 _meta))
  
  PRotate
  (rotate
   [_ theta]
   (let [s (Math/sin theta) c (Math/cos theta)]
     (Vec2.
      (clojure.core/- (clojure.core/* x c) (clojure.core/* y s))
      (clojure.core/+ (clojure.core/* x s) (clojure.core/* y c)) _meta)))
  PRotate3D
  (rotate-x
   [_ theta] (rotate-x (vec3 _) theta))
  (rotate-y
   [_ theta] (rotate-y (vec3 _) theta))
  (rotate-z
   [_ theta] (vec3 (rotate _ theta)))
  (rotate-around-axis
   [_ axis theta] (rotate-around-axis (vec3 _) axis theta))
  
  PTransform
  (transform
   [_ m] (transform-vector m _))
#+END_SRC
***** PMathOps
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PMathOps
  (abs [_] (Vec2. (m/abs x) (m/abs y) _meta))
  (+ [_] _)
  (+ [_ a] (vec2-op-1 clojure.core/+ _ a 0.0 _meta))
  (+ [_ a b] (vec2-op-2 clojure.core/+ _ a b 0.0 0.0 _meta))
  (+ [_ a b c] (vec2-op-3 clojure.core/+ _ a b c 0.0 _meta))
  
  (- [_] (Vec2. (clojure.core/- x) (clojure.core/- y) _meta))
  (- [_ a] (vec2-op-1 clojure.core/- _ a 0.0 _meta))
  (- [_ a b] (vec2-op-2 clojure.core/- _ a b 0.0 0.0 _meta))
  (- [_ a b c] (vec2-op-3 clojure.core/- _ a b c 0.0 _meta))
  
  (* [_] _)
  (* [_ a] (vec2-op-1 clojure.core/* _ a 1.0 _meta))
  (* [_ a b] (vec2-op-2 clojure.core/* _ a b 1.0 1.0 _meta))
  (* [_ a b c] (vec2-op-3 clojure.core/* _ a b c 1.0 _meta))
  
  (div [_] (Vec2. (/ x) (/ y) _meta))
  (div [_ a] (vec2-op-1 / _ a 0.0 _meta))
  (div [_ a b] (vec2-op-2 / _ a b 0.0 0.0 _meta))
  (div [_ a b c] (vec2-op-3 / _ a b c 0.0 _meta))
  
  (madd [_ a b] (vec2-op-2* clojure.core/* clojure.core/+ _ a b 1.0 0.0 _meta))
#+END_SRC
***** PDotProduct
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PDotProduct
  (dot
   [_ [ax ay]] (mc/madd x ax y ay))
#+END_SRC
***** PCrossProduct
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx  
  PCrossProduct
  (cross
   [_ [ax ay]] (mc/msub x ay y ax))
#+END_SRC
***** PLimit
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx  
  PLimit
  (limit
   [_ len]
   (if (> (mag-squared _) (clojure.core/* len len))
     (normalize _ len) _))
#+END_SRC
***** PMinMax
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PMinMax
  (min
   [_ [ax ay]]
   (Vec2.
    (clojure.core/min x ax)
    (clojure.core/min y ay) _meta))
  (min
   [_ [ax ay] [bx by]]
   (Vec2.
    (clojure.core/min (clojure.core/min x ax) bx)
    (clojure.core/min (clojure.core/min y ay) by) _meta))
  (max
   [_ [ax ay]]
   (Vec2.
    (clojure.core/max x ax)
    (clojure.core/max y ay) _meta))
  (max
   [_ [ax ay] [bx by]]
   (Vec2.
    (clojure.core/max (clojure.core/max x ax) bx)
    (clojure.core/max (clojure.core/max y ay) by) _meta))
#+END_SRC
***** PMagnitude
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PMagnitude
  (mag
   [_]
   (Math/sqrt (mc/madd x x y y)))
  (mag-squared
   [_] (mc/madd x x y y))
#+END_SRC
***** PNormalize
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PNormalize
  (normalize
   [_]
   (let [l (Math/sqrt (mc/madd x x y y))]
     (if (pos? l)
       (Vec2. (/ x l) (/ y l) _meta)
       _)))
  (normalize
   [_ len]
   (let [l (Math/sqrt (mc/madd x x y y))]
     (if (pos? l)
       (let [l (/ len l)]
         (Vec2. (clojure.core/* x l) (clojure.core/* y l) _meta))
       _)))
  (normalized?
   [_] (m/delta= 1.0 (mag-squared _)))
#+END_SRC
***** PDistance
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PDistance
  (dist
   [_ a]
   (let [[dx dy] (if (instance? Vec2 a)
                   [(clojure.core/- x (.-x ^Vec2 a))
                    (clojure.core/- y (.-y ^Vec2 a))]
                   [(clojure.core/- x (nth a 0))
                    (clojure.core/- y (nth a 1))])]
     (Math/sqrt (mc/madd dx dx dy dy))))
  (dist-squared
   [_ a]
   (let [[dx dy] (if (instance? Vec2 a)
                   [(clojure.core/- x (.-x ^Vec2 a))
                    (clojure.core/- y (.-y ^Vec2 a))]
                   [(clojure.core/- x (nth a 0))
                    (clojure.core/- y (nth a 1))])]
     (mc/madd dx dx dy dy)))
#+END_SRC
***** PReflect
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PReflect
  (reflect
   [_ [rx ry :as r]]
    (let [d (clojure.core/* (dot _ r) 2.0)]
      (Vec2.
       (mc/msub rx d x)
       (mc/msub ry d y) _meta)))
#+END_SRC
***** PInvert
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PInvert
  (invert
   [_] (Vec2. (clojure.core/- x) (clojure.core/- y) _meta))
#+END_SRC
***** PInterpolate
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PInterpolate
  (mix
   [_ [ax ay]]
   (Vec2.
    (mc/madd (clojure.core/- ax x) 0.5 x)
    (mc/madd (clojure.core/- ay y) 0.5 y) _meta))
  (mix
   [_ [ax ay] t]
   (Vec2.
    (mc/madd (clojure.core/- ax x) t x)
    (mc/madd (clojure.core/- ay y) t y) _meta))
#+END_SRC
***** PHeading
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PHeading
  (heading-xy
   [_]
   (let [t (Math/atan2 y x)]
     (if (neg? t) (clojure.core/+ t TWO_PI) t)))
  (angle-between
   [_ a]
   (let [t (clojure.core/- (heading-xy a) (heading-xy _))]
     (if (neg? t) (clojure.core/+ t TWO_PI) t)))
  (slope-xy
   [_] (/ y x))
  (normal
   [_] (Vec2. (clojure.core/- y) x _meta))
#+END_SRC
***** PPolar
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PPolar
  (as-polar
   [_]
   (Vec2. (mag _) (heading-xy _) _meta))
  (as-cartesian
   [_]
   (Vec2.
    (clojure.core/* x (Math/cos y))
    (clojure.core/* x (Math/sin y)) _meta))
#+END_SRC
***** End of implementations
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  )
#+END_SRC
***** Override print methods
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  #+clj (require 'clojure.pprint)
  #+clj (prefer-method clojure.pprint/simple-dispatch clojure.lang.IPersistentVector clojure.lang.ISeq)
  #+clj (defmethod print-method Vec2 [o ^java.io.Writer w] (.write w (.toString o)))
#+END_SRC
**** 3D
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (deftype Vec3
    #+clj [^double x ^double y ^double z _meta]
    #+cljs [x y z _meta]
#+END_SRC
***** Clojure protocols
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  ,#+clj clojure.lang.IObj
  ,#+clj (meta
         [_] _meta)
  ,#+clj (withMeta
         [_ m*] (Vec3. x y z m*))
  
  ,#+clj clojure.lang.ILookup
  ,#+clj (valAt
         [_ k] (swizzle3 _ k nil))
  ,#+clj (valAt
         [_ k nf] (swizzle3 _ k nf))
  
  ,#+clj java.util.concurrent.Callable
  ,#+clj (call
         [_] (.invoke ^clojure.lang.IFn _))
  ,#+clj java.lang.Runnable
  ,#+clj (run
         [_] (.invoke ^clojure.lang.IFn _))
  
  ,#+clj clojure.lang.IFn
  ,#+clj (invoke
         [_ k] (swizzle3 _ k nil))
  ,#+clj (invoke
         [_ k nf] (swizzle3 _ k nf))
  ,#+clj (applyTo
         [_ args]
         (condp = (count args)
           1 (swizzle3 _ (first args) nil)
           2 (swizzle3 _ (first args) (second args))
           (err/arity-error! (count args))))
  
  ,#+clj clojure.lang.Associative
  ,#+clj clojure.lang.IPersistentVector
  ,#+clj (count
         [_] 3)
  ,#+clj (length
         [_] 3)
  ,#+clj (containsKey
         [_ k] (not (nil? (#{0 1 2 :x :y :z} k))))
  ,#+clj (entryAt
         [_ k] (map-entry k (case (int k) 0 x, 1 y, 2 z, (err/key-error! k))))
  ,#+clj (assoc
            [_ k v] (swizzle3-assoc _ k v))
  ,#+clj (assocN
         [_ k v]
         (case (int k)
           0 (Vec3. v y z _meta)
           1 (Vec3. x v z _meta)
           2 (Vec3. x y v _meta)
           (err/key-error! k)))
  
  ,#+clj java.util.Collection
  ,#+clj (isEmpty
         [_] false)
  ,#+clj (iterator
         [_] (.iterator ^java.util.Collection (list x y z)))
  ,#+clj (toArray
         [_] (double-array 3 [x y z]))
  ,#+clj (size
         [_] 3)
  
  ,#+clj clojure.lang.IPersistentCollection
  ,#+clj clojure.lang.Indexed
  ,#+clj clojure.lang.Sequential
  ,#+clj clojure.lang.ISeq
  ,#+clj clojure.lang.Seqable
  ,#+clj (first
         [_] x)
  ,#+clj (next
         [_] (cons y (cons z nil)))
  ,#+clj (more
         [_] (cons y (cons z nil)))
  ,#+clj (cons
         [_ w] (with-meta [x y z w] _meta))
  ,#+clj (peek
         [_] z)
  ,#+clj (pop
         [_] (Vec2. x y _meta))
  ,#+clj (rseq
         [_] (Vec3. z y x _meta))
  ,#+clj (seq
         [_] _)
  ,#+clj (nth
         [_ n] (condp = n 0 x 1 y 2 z (err/key-error! n)))
  ,#+clj (nth
         [_ n nf] (condp = n 0 x 1 y 2 z nf))
  ,#+clj (equiv
         [_ o]
         (if (instance? Vec3 o)
           (and (clojure.lang.Numbers/equiv x (.-x ^Vec3 o))
                (clojure.lang.Numbers/equiv y (.-y ^Vec3 o))
                (clojure.lang.Numbers/equiv z (.-z ^Vec3 o)))
           (and (instance? java.util.Collection o)
                (= 3 (count o))
                (clojure.lang.Util/equiv x (nth o 0))
                (clojure.lang.Util/equiv y (nth o 1))
                (clojure.lang.Util/equiv z (nth o 2)))))
  ,#+clj (equals
         [_ o]
         (if (instance? Vec3 o)
           (and (clojure.lang.Util/equals x (.-x ^Vec3 o))
                (clojure.lang.Util/equals y (.-y ^Vec3 o))
                (clojure.lang.Util/equals z (.-z ^Vec3 o)))
           (and (instance? java.util.Collection o)
                (= 3 (count o))
                (clojure.lang.Util/equals x (nth o 0))
                (clojure.lang.Util/equals y (nth o 1))
                (clojure.lang.Util/equals z (nth o 2)))))
  
  ,#+clj Comparable
  ,#+clj (compareTo
         [_ o]
         (if (instance? Vec3 o)
           (let [c (compare x (.-x ^Vec3 o))]
             (if (== 0 c)
               (let [c (compare y (.-y ^Vec3 o))]
                 (if (== 0 c)
                   (compare z (.-z ^Vec3 o))
                   c))
               c))
           (let [c (count o)]
             (if (== 3 c) (compare o _) (- 3 c)))))
  ,#+clj (hashCode
         [_]
         (-> 31
             (unchecked-add-int (hash x))
             (unchecked-multiply-int 31)
             (unchecked-add-int (hash y))
             (unchecked-multiply-int 31)
             (unchecked-add-int (hash z))))
  
  ,#+clj clojure.lang.IHashEq
  ,#+clj (hasheq
           [_]
           (-> 31
               (unchecked-add-int (hash x))
               (unchecked-multiply-int 31)
               (unchecked-add-int (hash y))
               (unchecked-multiply-int 31)
               (unchecked-add-int (hash z))
               (mix-collection-hash 3)))
  
  Object
  (toString
    [_] (str "[" x " " y " " z "]"))
#+END_SRC
***** ClojureScript protocols
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  ,#+cljs IMeta
  ,#+cljs (-meta
          [_] _meta)
  ,#+cljs IWithMeta
  ,#+cljs (-with-meta
          [_ m*] (Vec3. x y z m*))
  
  ,#+cljs ICloneable
  ,#+cljs (-clone
          [_] (Vec3. x y z _meta))
  
  ,#+cljs ILookup
  ,#+cljs (-lookup
          [_ k] (swizzle3 _ k nil))
  ,#+cljs (-lookup
          [_ k nf] (swizzle3 _ k nf))
  
  ,#+cljs IFn
  ,#+cljs (-invoke
          [_ k] (swizzle3 _ k nil))
  ,#+cljs (-invoke
          [_ k nf] (swizzle3 _ k nf))
  
  ,#+cljs ICounted
  ,#+cljs (-count
          [_] 3)
  
  ,#+cljs IAssociative
  ,#+cljs (-contains-key?
          [_ k] (not (nil? (#{0 1 2 :x :y :z} k))))
  ,#+cljs (-assoc
          [_ k v] (swizzle3-assoc _ k v))
  
  ,#+cljs IVector
  ,#+cljs (-assoc-n
          [_ k v]
          (case k
            0 (Vec3. v y z _meta)
            1 (Vec3. x v z _meta)
            2 (Vec3. x y v _meta)
            (err/key-error! k)))
  
  ,#+cljs ISequential
  ,#+cljs ISeq
  ,#+cljs (-first
          [_] x)
  ,#+cljs (-rest
          [_] (cons y (cons z nil)))
  
  ,#+cljs INext
  ,#+cljs (-next
          [_] (cons y (cons z nil)))
  
  ,#+cljs ISeqable
  ,#+cljs (-seq
          [_] _)
  
  ,#+cljs IReversible
  ,#+cljs (-rseq
          [_] (Vec3. z y x _meta))
  
  ,#+cljs IIndexed
  ,#+cljs (-nth
          [_ n] (case n 0 x, 1 y, 2 z, (err/key-error! n)))
  ,#+cljs (-nth
          [_ n nf] (case n 0 x, 1 y, 2 z, nf))
  
  ,#+cljs ICollection
  ,#+cljs (-conj
          [_ w] (with-meta [x y z w] _meta))
  
  ,#+cljs IStack
  ,#+cljs (-peek
          [_] z)
  ,#+cljs (-pop
          [_] (Vec2. x y _meta))
  
  ,#+cljs IComparable
  ,#+cljs (-compare
          [_ o]
          (if (instance? Vec3 o)
            (let [c (compare x (.-x ^Vec3 o))]
              (if (== 0 c)
                (let [c (compare y (.-y ^Vec3 o))]
                  (if (== 0 c)
                    (compare z (.-z ^Vec3 o))
                    c))
                c))
            (let [c (count o)]
              (if (= 3 c) (compare o _) (- 3 c)))))
  
  ,#+cljs IHash
  ,#+cljs (-hash
          [_] (-> (hash x)
                  (hash-combine (hash y))
                  (hash-combine (hash z))))
  
  ,#+cljs IEquiv
  ,#+cljs (-equiv
          [_ o]
          (if (instance? Vec3 o)
            (and (== x (.-x ^Vec3 o)) (== y (.-y ^Vec3 o)) (== z (.-z ^Vec3 o)))
            (and (sequential? o) (= 3 (count o))
                 (= x (nth o 0)) (= y (nth o 1)) (= z (nth o 2)))))
#+END_SRC
***** TODO Transformations
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PScale
  (scale
   [_ a] (vec3-op-1 clojure.core/* _ a 1.0 _meta))
  (scale
   [_ a b] (vec3-op-2 clojure.core/* clojure.core/* _ a b 1.0 1.0 _meta))
  (scale
   [_ a b c] (vec3-op-3 clojure.core/* _ a b c 1.0 _meta))
  
  PTranslate
  (translate
   [_ a] (vec3-op-1 clojure.core/+ _ a 0.0 _meta))
  (translate
   [_ a b] (vec3-op-2 clojure.core/+ clojure.core/+ _ a b 0.0 0.0 _meta))
  (translate
   [_ a b c] (vec3-op-3 clojure.core/+ _ a b c 0.0 _meta))
  
  PRotate3D
  (rotate-x
   [_ theta]
   (let [s (Math/sin theta) c (Math/cos theta)]
     (Vec3. x (mc/msub y c z s) (mc/madd y s z c) _meta)))
  (rotate-y
   [_ theta]
   (let [s (Math/sin theta) c (Math/cos theta)]
     (Vec3. (mc/madd x c z s) y (mc/msub z c x s) _meta)))
  (rotate-z
   [_ theta]
   (let [s (Math/sin theta) c (Math/cos theta)]
     (Vec3. (mc/msub x c y s) (mc/madd x s y c) z _meta)))
  (rotate-around-axis
   [_ [ax ay az] theta]
   (let [ux (clojure.core/* ax x), uy (clojure.core/* ax y), uz (clojure.core/* ax z)
         vx (clojure.core/* ay x), vy (clojure.core/* ay y), vz (clojure.core/* ay z)
         wx (clojure.core/* az x), wy (clojure.core/* az y), wz (clojure.core/* az z)
         ax2 (clojure.core/* ax ax), ay2 (clojure.core/* ay ay), az2 (clojure.core/* az az)
         s (Math/sin theta), c (Math/cos theta)
         uvw (clojure.core/+ (clojure.core/+ ux vy) wz)]
     (Vec3.
      (mc/madd uvw ax
               (mc/msub (clojure.core/+ ay2 az2) x (clojure.core/+ vy wz) ax) c
               (mc/subm vz wy s))
  
      (mc/madd uvw ay
               (mc/msub (clojure.core/+ ax2 az2) y (clojure.core/+ ux wz) ay) c
               (mc/subm wx uz s))
  
      (mc/madd uvw az
               (mc/msub (clojure.core/+ ax2 ay2) z (clojure.core/+ ux vy) az) c
               (mc/subm uy vx s))
      _meta)))
  
  PTransform
  (transform
   [_ m] (transform-vector m _))
#+END_SRC
***** PMathOps
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PMathOps
  (abs [_] (Vec3. (m/abs x) (m/abs y) (m/abs z) _meta))
  (+ [_] _)
  (+ [_ a] (vec3-op-1 clojure.core/+ _ a 0.0 _meta))
  (+ [_ a b] (vec3-op-2 clojure.core/+ clojure.core/+ _ a b 0.0 0.0 _meta))
  (+ [_ a b c] (vec3-op-3 clojure.core/+ _ a b c 0.0 _meta))
  
  (- [_] (Vec3. (clojure.core/- x) (clojure.core/- y) (clojure.core/- z) _meta))
  (- [_ a] (vec3-op-1 clojure.core/- _ a 0.0 _meta))
  (- [_ a b] (vec3-op-2 clojure.core/- clojure.core/- _ a b 0.0 0.0 _meta))
  (- [_ a b c] (vec3-op-3 clojure.core/- _ a b c 0.0 _meta))
  
  (* [_] _)
  (* [_ a] (vec3-op-1 clojure.core/* _ a 1.0 _meta))
  (* [_ a b] (vec3-op-2 clojure.core/* clojure.core/* _ a b 1.0 1.0 _meta))
  (* [_ a b c] (vec3-op-3 clojure.core/* _ a b c 1.0 _meta))
  
  (div [_] (Vec3. (/ x) (/ y) (/ z) _meta))
  (div [_ a] (vec3-op-1 / _ a 0.0 _meta))
  (div [_ a b] (vec3-op-2 / / _ a b 0.0 0.0 _meta))
  (div [_ a b c] (vec3-op-3 / _ a b c 0.0 _meta))
  
  (madd
   [_ a b] (vec3-op-2 clojure.core/* clojure.core/+ _ a b 1.0 0.0 _meta))
  
  PDotProduct
  (dot
   [_ [ax ay az]]
   (mc/madd x ax y ay z az))
  
  PCrossProduct
  (cross
   [_ [ax ay az]]
   (Vec3.
    (mc/msub y az ay z)
    (mc/msub z ax az x)
    (mc/msub x ay ax y) _meta))
  
  PLimit
  (limit
   [_ len]
   (if (> (mag-squared _) (clojure.core/* len len))
     (normalize _ len)
     _))
  
  PMinMax
  (min
   [_ [ax ay az]]
   (Vec3.
    (clojure.core/min x ax)
    (clojure.core/min y ay)
    (clojure.core/min z az) _meta))
  (min
   [_ [ax ay az] [bx by bz]]
   (Vec3.
    (clojure.core/min (clojure.core/min x ax) bx)
    (clojure.core/min (clojure.core/min y ay) by)
    (clojure.core/min (clojure.core/min z az) bz) _meta))
  (max
   [_ [ax ay az]]
   (Vec3.
    (clojure.core/max x ax)
    (clojure.core/max y ay)
    (clojure.core/max z az) _meta))
  (max
   [_ [ax ay az] [bx by bz]]
   (Vec3.
    (clojure.core/max (clojure.core/max x ax) bx)
    (clojure.core/max (clojure.core/max y ay) by)
    (clojure.core/max (clojure.core/max z az) bz) _meta))
#+END_SRC
***** PMagnitude
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PMagnitude
  (mag
   [_]
   (Math/sqrt (mc/madd x x y y z z)))
  (mag-squared
   [_] (mc/madd x x y y z z))
#+END_SRC
***** PNormalize
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PNormalize
  (normalize
   [_]
   (let [l (Math/sqrt (mc/madd x x y y z z))]
     (if (pos? l)
       (Vec3. (/ x l) (/ y l) (/ z l) _meta)
       _)))
  (normalize
   [_ len]
   (let [l (Math/sqrt (mc/madd x x y y z z))]
     (if (pos? l)
       (let [l (/ len l)]
         (Vec3.
          (clojure.core/* x l)
          (clojure.core/* y l)
          (clojure.core/* z l) _meta)) _)))
  (normalized?
   [_] (m/delta= 1.0 (mag-squared _)))
#+END_SRC
***** PDistance
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PDistance
  (dist
   [_ a] (Math/sqrt (dist-squared _ a)))
  (dist-squared
   [_ a]
   (let [[dx dy dz] (if (instance? Vec3 a)
                      [(clojure.core/- x (.-x ^Vec3 a))
                       (clojure.core/- y (.-y ^Vec3 a))
                       (clojure.core/- z (.-z ^Vec3 a))]
                      [(clojure.core/- x (nth a 0))
                       (clojure.core/- y (nth a 1))
                       (clojure.core/- z (nth a 2 0.0))])]
     (mc/madd dx dx dy dy dz dz)))
#+END_SRC
***** PReflect
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PReflect
  (reflect
   [_ [rx ry rz :as r]]
    (let [d (clojure.core/* (dot _ r) 2.0)]
      (Vec3.
       (mc/msub rx d x)
       (mc/msub ry d y)
       (mc/msub rz d z) _meta)))
#+END_SRC
***** PInvert
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PInvert
  (invert
   [_] (Vec3. (clojure.core/- x) (clojure.core/- y) (clojure.core/- z) _meta))
#+END_SRC
***** PInterpolate
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PInterpolate
  (mix
   [_ [ax ay az]]
   (Vec3.
    (mc/madd (clojure.core/- ax x) 0.5 x)
    (mc/madd (clojure.core/- ay y) 0.5 y)
    (mc/madd (clojure.core/- az z) 0.5 z) _meta))
  (mix
   [_ [ax ay az] t]
   (Vec3.
    (mc/madd (clojure.core/- ax x) t x)
    (mc/madd (clojure.core/- ay y) t y)
    (mc/madd (clojure.core/- az z) t z) _meta))
#+END_SRC
***** PPolar
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  ;; http://mathworld.wolfram.com/SphericalCoordinates.html
  PPolar
  (as-polar
   [_]
    (let [r (mag _)
          theta (Math/atan2 y x)
          phi (Math/acos (/ z r))]
      (Vec3. r theta phi _meta)))
  (as-cartesian [_]
    (let [rsphi (clojure.core/* x (Math/sin z))]
      (Vec3.
       (clojure.core/* (Math/cos y) rsphi)
       (clojure.core/* (Math/sin y) rsphi)
       (clojure.core/* x (Math/cos z)) _meta)))
#+END_SRC
***** End of implementations
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
    )
#+END_SRC
***** Override print methods
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  #+clj (defmethod print-method Vec3 [o ^java.io.Writer w] (.write w (.toString o)))
#+END_SRC
**** Vector operations
***** 2D
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defn vec2-op-seq
    [op ^Vec2 acc xs]
    (loop [ax (.-x acc), ay (.-y acc), xs xs]
      (if xs
        (let [v ^Vec2 (first xs)]
          (recur (op ax (.-x v)) (op ay (.-y v)) (next xs)))
        (Vec2. ax ay (.-meta acc)))))
  
  (defn vec2-op-1
    [op ^Vec2 _ a d m]
    (if (instance? Vec2 a)
      (Vec2.
       (op (.-x _) (.-x ^Vec2 a))
       (op (.-y _) (.-y ^Vec2 a)) m)
      (if (number? a)
        (Vec2. (op (.-x _) a) (op (.-y _) a) m)
        (if (instance? Vec2 (first a))
          (vec2-op-seq op _ a)
          (Vec2.
           (op (.-x _) (nth a 0 d))
           (op (.-y _) (nth a 1 d)) m)))))
  
  (defn vec2-op-2
    [op ^Vec2 _ a b d1 d2 m]
    (if (instance? Vec2 a)
      (if (instance? Vec2 b)
        (Vec2. ;; v v
         (op (op (.-x _) (.-x ^Vec2 a)) (.-x ^Vec2 b))
         (op (op (.-y _) (.-y ^Vec2 a)) (.-y ^Vec2 b)) m)
        (if (number? b)
          (Vec2. ;; v n
           (op (op (.-x _) (.-x ^Vec2 a)) b)
           (op (op (.-y _) (.-y ^Vec2 a)) b) m)
          (Vec2. ;; v ?
           (op (op (.-x _) (.-x ^Vec2 a)) (nth b 0 d2))
           (op (op (.-y _) (.-y ^Vec2 a)) (nth b 1 d2)) m)))
      (let [an? (number? a) bn? (number? b)]
        (if (and an? bn?)
          (Vec2. ;; n n
           (op (.-x _) a)
           (op (.-y _) b) m)
          (let [[ax ay] (if an? [a a] a)
                [bx by] (if bn? [b b] b)]
            (Vec2. ;; ? ?
             (op (op (.-x _) (or ax d1)) (or bx d2))
             (op (op (.-y _) (or ay d1)) (or by d2)) m))))))
  
  (defn vec2-op-2*
    "Similar to vec2-op-2 but takes 2 fn args and handles case with
    a & b being both numbers differently."
    [op op2 ^Vec2 _ a b d1 d2 m]
    (if (instance? Vec2 a)
      (if (instance? Vec2 b)
        (Vec2. ;; v v
         (op2 (op (.-x _) (.-x ^Vec2 a)) (.-x ^Vec2 b))
         (op2 (op (.-y _) (.-y ^Vec2 a)) (.-y ^Vec2 b)) m)
        (if (number? b)
          (Vec2. ;; v n
           (op2 (op (.-x _) (.-x ^Vec2 a)) b)
           (op2 (op (.-y _) (.-y ^Vec2 a)) b) m)
          (Vec2. ;; v ?
           (op2 (op (.-x _) (.-x ^Vec2 a)) (nth b 0 d2))
           (op2 (op (.-y _) (.-y ^Vec2 a)) (nth b 1 d2)) m)))
      (let [an? (number? a) bn? (number? b)]
        (if (and an? bn?)
          (Vec2. ;; n n
           (op2 (op (.-x _) a) b)    ;; difference to vec2-op-2
           (op2 (op (.-y _) a) b) m)
          (let [[ax ay] (if an? [a a] a)
                [bx by] (if bn? [b b] b)]
            (Vec2. ;; ? ?
             (op2 (op (.-x _) (or ax d1)) (or bx d2))
             (op2 (op (.-y _) (or ay d1)) (or by d2)) m))))))
  
  (defn vec2-op-3
    [op ^Vec2 _ a b c d m]
    (if (instance? Vec2 a)
      (if (instance? Vec2 b)
        (if (instance? Vec2 c)
          (Vec2. ;; v v v
           (op (op (op (.-x _) (.-x ^Vec2 a)) (.-x ^Vec2 b)) (.-x ^Vec2 c))
           (op (op (op (.-y _) (.-y ^Vec2 a)) (.-y ^Vec2 b)) (.-y ^Vec2 c)) m)
          (if (number? c)
            (Vec2. ;; v v n
             (op (op (op (.-x _) (.-x ^Vec2 a)) (.-x ^Vec2 b)) c)
             (op (op (op (.-y _) (.-y ^Vec2 a)) (.-y ^Vec2 b)) c) m)
            (Vec2. ;; v v ?
             (op (op (op (.-x _) (.-x ^Vec2 a)) (.-x ^Vec2 b)) (nth c 0 d))
             (op (op (op (.-y _) (.-y ^Vec2 a)) (.-y ^Vec2 b)) (nth c 1 d)) m)))
        (let [[bx by] (if (number? b) [b b] b)
              [cx cy] (if (number? c) [c c] c)]
          (Vec2. ;; v ? ?
           (op (op (op (.-x _) (.-x ^Vec2 a)) (or bx d)) (or cx d))
           (op (op (op (.-y _) (.-y ^Vec2 a)) (or by d)) (or cy d)) m)))
      (let [[ax ay] (if (number? a) [a a] a)
            [bx by] (if (number? b) [b b] b)
            [cx cy] (if (number? c) [c c] c)]
        (Vec2. ;; ? ? ?
         (op (op (op (.-x _) (or ax d)) (or bx d)) (or cx d))
         (op (op (op (.-y _) (or ay d)) (or by d)) (or cy d)) m))))
#+END_SRC
***** 3D
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defn vec3-op-seq
    [op ^Vec3 acc xs]
    (loop [ax (.-x acc), ay (.-y acc), az (.-z acc), xs xs]
      (if xs
        (let [v ^Vec3 (first xs)]
          (recur (op ax (.-x v)) (op ay (.-y v)) (op az (.-z v)) (next xs)))
        (Vec3. ax ay az (.-meta acc)))))
  
  (defn vec3-op-1
    [op ^Vec3 _ a d m]
    (if (instance? Vec3 a)
      (Vec3.
       (op (.-x _) (.-x ^Vec3 a))
       (op (.-y _) (.-y ^Vec3 a))
       (op (.-z _) (.-z ^Vec3 a)) m)
      (if (number? a)
        (Vec3. (op (.-x _) a) (op (.-y _) a) (op (.-z _) a) m)
        (if (instance? Vec3 (first a))
          (vec3-op-seq op _ a)
          (Vec3.
           (op (.-x _) (nth a 0 d))
           (op (.-y _) (nth a 1 d))
           (op (.-z _) (nth a 2 d)) m)))))
  
  (defn vec3-op-2
    [op op2 ^Vec3 _ a b d1 d2 m]
    (if (instance? Vec3 a)
      (if (instance? Vec3 b)
        (Vec3. ;; v v
         (op2 (op (.-x _) (.-x ^Vec3 a)) (.-x ^Vec3 b))
         (op2 (op (.-y _) (.-y ^Vec3 a)) (.-y ^Vec3 b))
         (op2 (op (.-z _) (.-z ^Vec3 a)) (.-z ^Vec3 b)) m)
        (if (number? b)
          (Vec3. ;; v n
           (op2 (op (.-x _) (.-x ^Vec3 a)) b)
           (op2 (op (.-y _) (.-y ^Vec3 a)) b)
           (op2 (op (.-z _) (.-z ^Vec3 a)) b) m)
          (Vec3. ;; v ?
           (op2 (op (.-x _) (.-x ^Vec3 a)) (nth b 0 d2))
           (op2 (op (.-y _) (.-y ^Vec3 a)) (nth b 1 d2))
           (op2 (op (.-z _) (.-z ^Vec3 a)) (nth b 2 d2)) m)))
      (let [[ax ay az] (if (number? a) [a a a] a)
            [bx by bz] (if (number? b) [b b b] b)]
        (Vec3. ;; ? ? ?
         (op2 (op (.-x _) (or ax d1)) (or bx d2))
         (op2 (op (.-y _) (or ay d1)) (or by d2))
         (op2 (op (.-z _) (or az d1)) (or bz d2)) m))))
  
  (defn vec3-op-3
    [op ^Vec3 _ a b c d m]
    (if (instance? Vec3 a)
      (if (instance? Vec3 b)
        (if (instance? Vec3 c)
          (Vec3. ;; v v v
           (op (op (op (.-x _) (.-x ^Vec3 a)) (.-x ^Vec3 b)) (.-x ^Vec3 c))
           (op (op (op (.-y _) (.-y ^Vec3 a)) (.-y ^Vec3 b)) (.-y ^Vec3 c))
           (op (op (op (.-z _) (.-z ^Vec3 a)) (.-z ^Vec3 b)) (.-z ^Vec3 c)) m)
          (if (number? c)
            (Vec3. ;; v v n
             (op (op (op (.-x _) (.-x ^Vec3 a)) (.-x ^Vec3 b)) c)
             (op (op (op (.-y _) (.-y ^Vec3 a)) (.-y ^Vec3 b)) c)
             (op (op (op (.-z _) (.-z ^Vec3 a)) (.-z ^Vec3 b)) c) m)
            (Vec3. ;; v v ?
             (op (op (op (.-x _) (.-x ^Vec3 a)) (.-x ^Vec3 b)) (nth c 0 d))
             (op (op (op (.-y _) (.-y ^Vec3 a)) (.-y ^Vec3 b)) (nth c 1 d))
             (op (op (op (.-z _) (.-z ^Vec3 a)) (.-z ^Vec3 b)) (nth c 2 d)) m)))
        (let [[bx by bz] (if (number? b) [b b b] b)
              [cx cy cz] (if (number? c) [c c c] c)]
          (Vec3. ;; v ? ?
           (op (op (op (.-x _) (.-x ^Vec3 a)) (or bx d)) (or cx d))
           (op (op (op (.-y _) (.-y ^Vec3 a)) (or by d)) (or cy d))
           (op (op (op (.-z _) (.-z ^Vec3 a)) (or bz d)) (or cz d)) m)))
      (let [an? (number? a) bn? (number? b) cn? (number? c)]
        (if (and an? bn? cn?)
          (Vec3. ;; n n n
           (op (.-x _) a)
           (op (.-y _) b)
           (op (.-z _) c) m)
          (let [[ax ay az] (if (number? a) [a a a] a)
                [bx by bz] (if (number? b) [b b b] b)
                [cx cy cz] (if (number? c) [c c c] c)]
            (Vec3. ;; ? ? ?
             (op (op (op (.-x _) (or ax d)) (or bx d)) (or cx d))
             (op (op (op (.-y _) (or ay d)) (or by d)) (or cy d))
             (op (op (op (.-z _) (or az d)) (or bz d)) (or cz d)) m))))))
#+END_SRC
**** Constants
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (def ^:const V2 (Vec2. 0.0 0.0 nil))
  (def ^:const V3 (Vec3. 0.0 0.0 0.0 nil))

  (def ^:const V2X (Vec2. 1.0 0.0 nil))
  (def ^:const V2Y (Vec2. 0.0 1.0 nil))

  (def ^:const V3X (Vec3. 1.0 0.0 0.0 nil))
  (def ^:const V3Y (Vec3. 0.0 1.0 0.0 nil))
  (def ^:const V3Z (Vec3. 0.0 0.0 1.0 nil))
#+END_SRC
**** Constructors
      To simplify vector type construction, factory functions
      are provided which coerce arguments into vectors with these
      rules:

      | Input                 | Behavior                                           | Examples call        | Example result  |
      |-----------------------+----------------------------------------------------+----------------------+-----------------|
      | Clojure vector or seq | select first =n= elements or fill missing with 0.0 | =(vec2 [1 2 3 4])=   | =[1.0 2.0]=     |
      |                       |                                                    | =(vec3 '(1 2)=       | =[1.0 2.0 0.0]= |
      | Map                   | select values of =:x :y :z= or fill with 0.0       | =(vec2 {:x 1 :y 2})= | =[1.0 2.0]=     |
      |                       |                                                    | =(vec3 {:x 1 :y 2})= | =[1.0 2.0 0.0]= |
      | Single number         | set all vector components                          | =(vec3 1)=           | =[1.0 1.0 1.0]= |

#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defn vec2
    ([] V2)
    ([x] (cond
          (instance? Vec2 x) x
          (sequential? x) (Vec2. (nth x 0 0.0) (nth x 1 0.0) (meta x))
          (number? x) (Vec2. x x nil)
          (map? x) (Vec2. (get x :x 0.0) (get x :y 0.0) (meta x))
          :default (err/type-error! "Vec2" x)))
    ([x y] (Vec2. x y nil)))
  
  (defn vec3
    ([] V3)
    ([x] (cond
          (instance? Vec3 x) x
          (sequential? x) (Vec3. (nth x 0 0.0) (nth x 1 0.0) (nth x 2 0.0) (meta x))
          (number? x) (Vec3. x x x nil)
          (map? x) (Vec3. (get x :x 0.0) (get x :y 0.0) (get x :z 0.0) (meta x))
          :default (err/type-error! "Vec3" x)))
    ([x y] (Vec3. x y 0.0 nil))
    ([x y z] (Vec3. x y z nil)))
  
  (defn vec2? [x] (instance? Vec2 x))
  (defn vec3? [x] (instance? Vec3 x))
#+END_SRC
**** Random vectors
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defn randvec2
    ([] (normalize (vec2 (m/randnorm) (m/randnorm))))
    ([n] (normalize (vec2 (m/randnorm) (m/randnorm)) n)))

  (defn randvec3
    ([] (normalize (vec3 (m/randnorm) (m/randnorm) (m/randnorm))))
    ([n] (normalize (vec3 (m/randnorm) (m/randnorm) (m/randnorm)) n)))
#+END_SRC
**** Swizzling
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defn- swizzle2
    [^Vec2 _ k default]
    (if (number? k)
      (case (int k)
        0 (.-x _)
        1 (.-y _)
        (or default (err/key-error! k)))
      (case k
        :x (.-x _)
        :y (.-y _)
        (let [n (name k) c (count n)]
          (case c
            2 (->> n
                   (map #(case % \x (.-x _) \y (.-y _) (or default (err/key-error! k))))
                   ((fn [[x y]] (Vec2. x y (.-_meta _)))))
            3 (->> n
                   (map #(case % \x (.-x _) \y (.-y _) (or default (err/key-error! k))))
                   ((fn [[x y z]] (Vec3. x y z (.-_meta _)))))
            (or default (err/key-error! k)))))))
  
  (defn- swizzle2-assoc
    [^Vec2 _ k v]
    (case k
      0 (Vec2. v (.-y _) (.-_meta _))
      1 (Vec2. (.-x _) v (.-_meta _))
      :x (Vec2. v (.-y _) (.-_meta _))
      :y (Vec2. (.-x _) v (.-_meta _))
      :xy (Vec2. (v 0) (v 1) (.-_meta _))
      :yx (Vec2. (v 1) (v 0) (.-_meta _))
      (err/key-error! k)))
  
  (defn- swizzle3
    [^Vec3 _ k default]
    (if (number? k)
      (case (int k)
        0 (.-x _)
        1 (.-y _)
        2 (.-z _)
        (or default (err/key-error! k)))
      (case k
        :x (.-x _)
        :y (.-y _)
        :z (.-z _)
        (let [n (name k) c (count n)]
          (case c
            2 (->> n
                   (map #(case % \x (.-x _) \y (.-y _) \z (.-z _) (or default (err/key-error! k))))
                   ((fn [[x y]] (Vec2. x y (.-_meta _)))))
            3 (->> n
                   (map #(case % \x (.-x _) \y (.-y _) \z (.-z _) (or default (err/key-error! k))))
                   ((fn [[x y z]] (Vec3. x y z (.-_meta _)))))
            (or default (err/key-error! k)))))))
  
  (defn- swizzle3-assoc
    [^Vec3 _ k v]
    (case k
      :x (Vec3. v (.-y _) (.-z _) (.-_meta _))
      :y (Vec3. (.-x _) v (.-z _) (.-_meta _))
      :z (Vec3. (.-x _) (.-y _) v (.-_meta _))
      0 (Vec3. v (.-y _) (.-z _) (.-_meta _))
      1 (Vec3. (.-x _) v (.-z _) (.-_meta _))
      2 (Vec3. (.-x _) (.-y _) v (.-_meta _))
      :xy (Vec3. (v 0) (v 1) (.-z _) (.-_meta _)) ;; (assoc [x y z] :xy [a b]) => [a b z]
      :yx (Vec3. (v 1) (v 0) (.-z _) (.-_meta _)) ;; (assoc [x y z] :yx [a b]) => [b a z]
      :xz (Vec3. (v 0) (.-y _) (v 1) (.-_meta _)) ;; (assoc [x y z] :xz [a b]) => [a y b]
      :zx (Vec3. (v 1) (.-y _) (v 0) (.-_meta _)) ;; (assoc [x y z] :zx [a b]) => [b y a]
      :yz (Vec3. (.-x _) (v 0) (v 1) (.-_meta _)) ;; (assoc [x y z] :yz [a b]) => [x a b]
      :zy (Vec3. (.-x _) (v 1) (v 0) (.-_meta _)) ;; (assoc [x y z] :zy [a b]) => [x b a]
      (err/key-error! k)))
#+END_SRC
*** Matrix implementations
**** 3x2 Matrix (Affine 2D transform)
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defrecord Matrix32
    #+clj  [^double m00 ^double m01 ^double m02
            ^double m10 ^double m11 ^double m12]
    #+cljs [m00 m01 m02 m10 m11 m12]
#+END_SRC
***** PMathOps
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PMathOps
  (*
   [_ m]
   (let [m ^Matrix32 m]
     (with-meta
       (Matrix32.
        (mc/madd m00 (.-m00 m) m01 (.-m10 m))
        (mc/madd m00 (.-m01 m) m01 (.-m11 m))
        (mc/madd m00 (.-m02 m) m01 (.-m12 m) m02)
        (mc/madd m10 (.-m00 m) m11 (.-m10 m))
        (mc/madd m10 (.-m01 m) m11 (.-m11 m))
        (mc/madd m10 (.-m02 m) m11 (.-m12 m) m12))
       (meta _))))
#+END_SRC
***** PDeterminant
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PDeterminant
  (determinant
   [_]
   (clojure.core/- (clojure.core/* m00 m11) (clojure.core/* m01 m10)))
#+END_SRC
***** PInvert
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PInvert
  (invert
   [_]
   (let [d (determinant _)]
     (when-not (zero? d)
       (Matrix32.
        (/ m11 d) (clojure.core/- (/ m01 d)) (/ (clojure.core/- (clojure.core/* m01 m12) (clojure.core/* m11 m02)) d)
        (clojure.core/- (/ m10 d)) (/ m00 d) (/ (clojure.core/- (clojure.core/* m10 m02) (clojure.core/* m00 m12)) d)))))
#+END_SRC
***** PRotate, PScale, PTranslate, PTransform
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PRotate
  (rotate
   [_ theta]
   (let [s (Math/sin theta), c (Math/cos theta)]
     (* _ (Matrix32. c (clojure.core/- s) 0.0, s c 0.0))))
  
  PScale
  (scale
   [_ s]
   (* _ (Matrix32.
         (if (number? s) s (s 0)) 0.0 0.0
         0.0 (if (number? s) s (s 1)) 0.0)))
  (scale
   [_ sx sy]
   (if (number? sx)
     (if (number? sy)
       (* _ (Matrix32. sx 0.0 0.0, 0.0 sy 0.0))
       (* _ (Matrix32. (* sx (sy 0)) 0.0 0.0, 0.0 (* sx (sy 1)) 0.0)))
     (if (number? sy)
       (* _ (Matrix32. (* sy (sx 0)) 0.0 0.0, 0.0 (* sy (sx 1)) 0.0))
       (* _ (Matrix32. (* (sx 0) (sy 0)) 0.0 0.0, 0.0 (* (sx 1) (sy 1)) 0.0)))))
  
  PShear
  (shear
   [_ s]
   (* _ (Matrix32.
         1.0 (if (number? s) s (s 0)) 0.0,
         (if (number? s) s (s 1)) 1.0 0.0)))
  (shear
   [_ sx sy]
   (* _ (Matrix32. 1.0 sx 0.0, sy 1.0 0.0)))
  
  PTranslate
  (translate
   [_ t]
   (* _ (Matrix32.
         1.0 0.0 (if (number? t) t (t 0))
         0.0 1.0 (if (number? t) t (t 1)))))
  (translate
   [_ tx ty]
   (if (number? tx)
     (if (number? ty)
       (* _ (Matrix32. 1.0 0.0 tx, 0.0 1.0 ty))
       (* _ (Matrix32. 1.0 0.0 (* tx (ty 0)), 0.0 1.0 (* tx (ty 1)))))
     (if (number? ty)
       (* _ (Matrix32. 1.0 0.0 (* ty (tx 0)), 0.0 1.0 (* ty (tx 1))))
       (* _ (Matrix32. 1.0 0.0 (* (tx 0) (ty 0)), 0.0 1.0 (* (tx 1) (ty 1)))))))
  
  PTransform
  (transform
   [_ matrix] (* _ matrix))
#+END_SRC
***** PVectorTransform
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PVectorTransform
  (transform-vector
   [_ [x y :as v]]
   (Vec2.
    (mc/madd x m00 y m01 m02)
    (mc/madd x m10 y m11 m12)
    (meta v)))
#+END_SRC
***** End of implementations
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  )
#+END_SRC
**** 4x4 Matrix
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defrecord Matrix44
    #+clj  [^double m00 ^double m01 ^double m02 ^double m03
            ^double m10 ^double m11 ^double m12 ^double m13
            ^double m20 ^double m21 ^double m22 ^double m23
            ^double m30 ^double m31 ^double m32 ^double m33]
    #+cljs [m00 m01 m02 m03
            m10 m11 m12 m13
            m20 m21 m22 m23
            m30 m31 m32 m33]
#+END_SRC
***** PMathOps
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PMathOps
  (*
   [_ m]
   (let [^Matrix44 m m]
     (with-meta
       (Matrix44.
        (mc/madd m00 (.-m00 m) m01 (.-m10 m) m02 (.-m20 m) m03 (.-m30 m))
        (mc/madd m00 (.-m01 m) m01 (.-m11 m) m02 (.-m21 m) m03 (.-m31 m))
        (mc/madd m00 (.-m02 m) m01 (.-m12 m) m02 (.-m22 m) m03 (.-m32 m))
        (mc/madd m00 (.-m03 m) m01 (.-m13 m) m02 (.-m23 m) m03 (.-m33 m))
  
        (mc/madd m10 (.-m00 m) m11 (.-m10 m) m12 (.-m20 m) m13 (.-m30 m))
        (mc/madd m10 (.-m01 m) m11 (.-m11 m) m12 (.-m21 m) m13 (.-m31 m))
        (mc/madd m10 (.-m02 m) m11 (.-m12 m) m12 (.-m22 m) m13 (.-m32 m))
        (mc/madd m10 (.-m03 m) m11 (.-m13 m) m12 (.-m23 m) m13 (.-m33 m))
  
        (mc/madd m20 (.-m00 m) m21 (.-m10 m) m22 (.-m20 m) m23 (.-m30 m))
        (mc/madd m20 (.-m01 m) m21 (.-m11 m) m22 (.-m21 m) m23 (.-m31 m))
        (mc/madd m20 (.-m02 m) m21 (.-m12 m) m22 (.-m22 m) m23 (.-m32 m))
        (mc/madd m20 (.-m03 m) m21 (.-m13 m) m22 (.-m23 m) m23 (.-m33 m))
  
        (mc/madd m30 (.-m00 m) m31 (.-m10 m) m32 (.-m20 m) m33 (.-m30 m))
        (mc/madd m30 (.-m01 m) m31 (.-m11 m) m32 (.-m21 m) m33 (.-m31 m))
        (mc/madd m30 (.-m02 m) m31 (.-m12 m) m32 (.-m22 m) m33 (.-m32 m))
        (mc/madd m30 (.-m03 m) m31 (.-m13 m) m32 (.-m23 m) m33 (.-m33 m)))
       (meta _))))
#+END_SRC
***** PDeterminant
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PDeterminant
  (determinant
   [_]
   (reduce
    clojure.core/+
    [(gmc/det-item m30 m21 m12 m03 m20 m31 m12 m03 m30 m11 m22 m03 m10 m31 m22 m03)
     (gmc/det-item m20 m11 m32 m03 m10 m21 m32 m03 m30 m21 m02 m13 m20 m31 m02 m13)
     (gmc/det-item m30 m01 m22 m13 m00 m31 m22 m13 m20 m01 m32 m13 m00 m21 m32 m13)
     (gmc/det-item m30 m11 m02 m23 m10 m31 m02 m23 m30 m01 m12 m23 m00 m31 m12 m23)
     (gmc/det-item m10 m01 m32 m23 m00 m11 m32 m23 m20 m11 m02 m33 m10 m21 m02 m33)
     (gmc/det-item m20 m01 m12 m33 m00 m21 m12 m33 m10 m01 m22 m33 m00 m11 m22 m33)]))
#+END_SRC
***** PInvert
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PInvert
  (invert
   [_]
   (let [n00 (mc/msub m00 m11 m01 m10)
         n01 (mc/msub m00 m12 m02 m10)
         n02 (mc/msub m00 m13 m03 m10)
         n03 (mc/msub m01 m12 m02 m11)
         n04 (mc/msub m01 m13 m03 m11)
         n05 (mc/msub m02 m13 m03 m12)
         n06 (mc/msub m20 m31 m21 m30)
         n07 (mc/msub m20 m32 m22 m30)
         n08 (mc/msub m20 m33 m23 m30)
         n09 (mc/msub m21 m32 m22 m31)
         n10 (mc/msub m21 m33 m23 m31)
         n11 (mc/msub m22 m33 m23 m32)
         d (clojure.core/+
            (clojure.core/-
             (clojure.core/+
              (clojure.core/+
               (clojure.core/-
                (clojure.core/* n00 n11) (clojure.core/* n01 n10))
               (clojure.core/* n02 n09))
              (clojure.core/* n03 n08))
             (clojure.core/* n04 n07))
            (clojure.core/* n05 n06))]
     (when-not (zero? d)
       (let [invd (/ 1.0 d)]
         (with-meta
           (Matrix44.
            (gmc/inv-item m11 n11 m12 n10 m13 n09 invd)
            (gmc/inv-item m02 n10 m03 n09 (clojure.core/- m01) n11 invd)
            (gmc/inv-item m31 n05 m32 n04 m33 n03 invd)
            (gmc/inv-item m22 n04 m23 n03 (clojure.core/- m21) n05 invd)
            (gmc/inv-item m12 n08 m13 n07 (clojure.core/- m10) n11 invd)
            (gmc/inv-item m00 n11 m02 n08 m03 n07 invd)
            (gmc/inv-item m32 n02 m33 n01 (clojure.core/- m30) n05 invd)
            (gmc/inv-item m20 n05 m22 n02 m23 n01 invd)
            (gmc/inv-item m10 n10 m11 n08 m13 n06 invd)
            (gmc/inv-item m01 n08 m03 n06 (clojure.core/- m00) n10 invd)
            (gmc/inv-item m30 n04 m31 n02 m33 n00 invd)
            (gmc/inv-item m21 n02 m23 n00 (clojure.core/- m20) n04 invd)
            (gmc/inv-item m11 n07 m12 n06 (clojure.core/- m10) n09 invd)
            (gmc/inv-item m00 n09 m01 n07 m02 n06 invd)
            (gmc/inv-item m31 n01 m32 n00 (clojure.core/- m30) n03 invd)
            (gmc/inv-item m20 n03 m21 n01 m22 n00 invd))
           (meta _))))))
#+END_SRC
***** PTranspose
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
    PTranspose
    (transpose
     [_]
     (with-meta
       (Matrix44.
        m00 m10 m20 m30
        m01 m11 m21 m31
        m02 m12 m22 m32
        m03 m13 m23 m33)
       (meta _)))
#+END_SRC
***** Transformations
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PScale
  (scale
   [_ s]
   (let [[x y z] (if (number? s) [s s s] s)]   
     (* _ (assoc M44 :m00 x :m11 y :m22 z))))
  (scale
   [_ x y z]
   (* _ (assoc M44 :m00 x :m11 y :m22 z))) ;; TODO add scale vec support
  
  PRotate
  (rotate
   [_ theta] (rotate-z _ theta))
  
  PRotate3D
  (rotate-x
   [_ theta]
   (let [s (Math/sin theta), c (Math/cos theta)]
     (* _ (assoc M44 :m11 c :m12 (clojure.core/- s) :m21 s :m22 c))))
  (rotate-y
   [_ theta]
   (let [s (Math/sin theta), c (Math/cos theta)]
     (* _ (assoc M44 :m00 c :m02 s :m20 (clojure.core/- s) :m22 c))))
  (rotate-z
   [_ theta]
   (let [s (Math/sin theta), c (Math/cos theta)]
     (* _ (assoc M44 :m00 c :m01 (clojure.core/- s) :m10 s :m11 c))))
  (rotate-around-axis
   [_ [x y z] theta]
   (let [theta (clojure.core/- theta)
         s (Math/sin theta), c (Math/cos theta)
         sx (clojure.core/* s x)
         sy (clojure.core/* s y)
         sz (clojure.core/* s z)
         t (clojure.core/- 1.0 c)
         tx (clojure.core/* t x)
         ty (clojure.core/* t y)]
     (* _
        (Matrix44.
         (mc/madd tx x c) (mc/madd tx y sz) (mc/msub tx z sy) 0.0
         (mc/msub tx y sz) (mc/madd ty y c) (mc/madd ty z sx) 0.0
         (mc/madd tx z sy) (mc/msub ty z sx) (mc/madd (clojure.core/* t z) z c) 0.0
         0.0 0.0 0.0 1.0))))
  
  PTranslate
  (translate
   [_ t]
   (let [[x y z] (if (number? t) [t t t] t)]   
     (* _ (assoc M44 :m03 x :m13 y :m23 z))))
  (translate
   [_ x y z]
   (* _ (assoc M44 :m03 x :m13 y :m23 z)))

  PTransform
  (transform
   [_ matrix] (* _ matrix))
#+END_SRC
***** PVectorTransform
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PVectorTransform
  (transform-vector
   [_ [x y z w :as v]]
   (if (= 3 (count v))
     (vec3 (mc/madd x m00 y m01 z m02 m03)
           (mc/madd x m10 y m11 z m12 m13)
           (mc/madd x m20 y m21 z m22 m23))
     [(mc/madd x m00 y m01 z m02 w m03)
      (mc/madd x m10 y m11 z m12 w m13)
      (mc/madd x m20 y m21 z m22 w m23)
      (mc/madd x m30 y m31 z m32 w m33)]))
#+END_SRC
***** End of implementation
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
    )
#+END_SRC
**** Constants
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (def ^:const M32
    (Matrix32.
     1.0 0.0 0.0
     0.0 1.0 0.0))

  (def ^:const M44
    (Matrix44.
     1.0 0.0 0.0 0.0
     0.0 1.0 0.0 0.0
     0.0 0.0 1.0 0.0
     0.0 0.0 0.0 1.0))
#+END_SRC
**** Constructors
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defn matrix32
    ([] M32)
    ([[m00 m01 m02 m10 m11 m12]]
       (Matrix32. m00 m01 m02 m10 m11 m12))
    ([m00 m01 m02 m10 m11 m12]
       (Matrix32. m00 m01 m02 m10 m11 m12)))

  (defn matrix44
    ([] M44)
    ([[m00 m01 m02 m03 m10 m11 m12 m13 m20 m21 m22 m23 m30 m31 m32 m33]]
       (Matrix44. m00 m01 m02 m03 m10 m11 m12 m13 m20 m21 m22 m23 m30 m31 m32 m33))
    ([m00 m01 m02 m03 m10 m11 m12 m13 m20 m21 m22 m23 m30 m31 m32 m33]
       (Matrix44. m00 m01 m02 m03 m10 m11 m12 m13 m20 m21 m22 m23 m30 m31 m32 m33)))
#+END_SRC
*** Quaternion
**** Implementation
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (deftype Quaternion
    ,#+clj  [^double x ^double y ^double z ^double w _meta]
    ,#+cljs [x y z w _meta]
#+END_SRC
***** Clojure protocols
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
    ,#+clj clojure.lang.IObj
    ,#+clj (meta [_] _meta)
    ,#+clj (withMeta [_ m*] (Quaternion. x y z w m*))
    ,#+cljs IMeta
    ,#+cljs (-meta [_] _meta)
    ,#+cljs IWithMeta
    ,#+cljs (-with-meta [_ m*] (Quaternion. x y z w m*))
#+END_SRC
***** PScale
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PScale
  (scale
   [_ s]
   (Quaternion.
    (clojure.core/* x s)
    (clojure.core/* y s)
    (clojure.core/* z s)
    (clojure.core/* w s) _meta))
#+END_SRC
***** PRotate3D
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PRotate3D
  (rotate-x
   [_ theta]
   (let [t (/ theta 2.0)
         s (Math/sin t) c (Math/cos t)]
     (Quaternion.
      (mc/madd x c w s)
      (mc/madd y c z s)
      (mc/msub z c y s)
      (mc/msub w c x s) _meta)))
  (rotate-y
   [_ theta]
   (let [t (/ theta 2.0)
         s (Math/sin t) c (Math/cos t)]
     (Quaternion.
      (mc/msub x c z s)
      (mc/madd y c w s)
      (mc/madd z c x s)
      (mc/msub w c y s) _meta)))
  (rotate-z
   [_ theta]
   (let [t (/ theta 2.0)
         s (Math/sin t) c (Math/cos t)]
     (Quaternion.
      (mc/madd x c y s)
      (mc/msub y c x s)
      (mc/madd z c w s)
      (mc/msub w c z s) _meta)))
#+END_SRC
***** PMathOps
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PMathOps
  (+
   [_ q]
   (let [q ^Quaternion q]
     (Quaternion.
      (clojure.core/+ x (.-x q))
      (clojure.core/+ y (.-y q))
      (clojure.core/+ z (.-z q))
      (clojure.core/+ w (.-w q)) _meta)))
  (-
   [_ q]
   (let [q ^Quaternion q]
     (Quaternion.
      (clojure.core/- x (.-x q))
      (clojure.core/- y (.-y q))
      (clojure.core/- z (.-z q))
      (clojure.core/- w (.-w q)) _meta)))
  (*
   [_ q]
   (let [q ^Quaternion q
         qx (.-x q) qy (.-y q) qz (.-z q) qw (.-w q)]
     (Quaternion.
      (mc/maddsub x qw w qx y qz z qy)
      (mc/maddsub y qw w qy z qx x qz)
      (mc/maddsub z qw w qz x qy y qx)
      (mc/msub w qw x qx y qy z qz)
      _meta)))
  (*
   [_ q r]
   (let [q ^Quaternion q r ^Quaternion r
         qx (.-x q) qy (.-y q) qz (.-z q) qw (.-w q)
         rx (.-x r) ry (.-y r) rz (.-z r) rw (.-w r)
         x' (mc/maddsub x qw w qx y qz z qy)
         y' (mc/maddsub y qw w qy z qx x qz)
         z' (mc/maddsub z qw w qz x qy y qx)
         w' (mc/msub w qw x qx y qy z qz)]
     (Quaternion.
      (mc/maddsub x' rw w' rx y' rz z' ry)
      (mc/maddsub y' rw w' ry z' rx x' rz)
      (mc/maddsub z' rw w' rz x' ry y' rx)
      (mc/msub w' rw x' rx y' ry z' rz)
      _meta)))
#+END_SRC
***** PDotProduct
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx  
  PDotProduct
  (dot
   [_ q]
   (let [q ^Quaternion q]
     (mc/madd x (.-x q) y (.-y q) z (.-z q) w (.-w q))))
#+END_SRC
***** PMagnitude
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PMagnitude
  (mag
   [_] (Math/sqrt (mc/madd x x y y z z w w)))
  (mag-squared
   [_] (mc/madd x x y y z z w w))
#+END_SRC
***** PNormalize
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PNormalize
  (normalize [_]
    (let [m (Math/sqrt (mc/madd x x y y z z w w))]
      (if (> m *eps*)
        (Quaternion. (/ x m) (/ y m) (/ z m) (/ w m) _meta)
        _)))
#+END_SRC
***** PConjugate
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PConjugate
  (conjugate [_]
    (Quaternion. (clojure.core/- x) (clojure.core/- y) (clojure.core/- z) w _meta))
#+END_SRC
***** PInvert
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PInvert
  (invert [_]
    (let [d (mag-squared _)
          d (if (zero? d) 0.0 (/ d))
          id (clojure.core/- d)]
      (Quaternion. (clojure.core/* x id) (clojure.core/* y id) (clojure.core/* z id) (clojure.core/* w d) _meta)))
#+END_SRC
***** PInterpolate
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PInterpolate
  (mix [_ q] (mix _ q 0.5))
  (mix [_ q t]
    (let [d (dot _ q)]
      (if (>= (m/abs d) 1.0)
        _
        (let [theta (Math/acos d)
              stheta (Math/sqrt (clojure.core/- 1.0 (clojure.core/* d d)))
              [a b] (if (< (m/abs stheta) 0.001)
                      [0.5 0.5]
                      [(/ (Math/sin (clojure.core/* theta (clojure.core/- 1.0 t))) stheta)
                       (/ (Math/sin (clojure.core/* theta t)) stheta)])
              q ^Quaternion q]
          (Quaternion.
           (mc/madd x a (.-x q) b)
           (mc/madd y a (.-y q) b)
           (mc/madd z a (.-z q) b)
           (mc/madd w a (.-w q) b)
           _meta)))))
#+END_SRC
***** PMatrixConvert
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PMatrixConvert
  (as-matrix
   [_]
   (let [x2 (clojure.core/+ x x)
         y2 (clojure.core/+ y y)
         z2 (clojure.core/+ z z)
         xx (clojure.core/* x x2)
         yx (clojure.core/* y x2)
         yy (clojure.core/* y y2)
         zx (clojure.core/* z x2)
         zy (clojure.core/* z y2)
         zz (clojure.core/* z z2)
         wx (clojure.core/* w x2)
         wy (clojure.core/* w y2)
         wz (clojure.core/* w z2)]
     (Matrix44.
      (clojure.core/- (clojure.core/- 1.0 yy) zz) ; m00
      (clojure.core/- yx wz) ;m10
      (clojure.core/+ zx wy) ;m20
      0.0
      (clojure.core/+ yx wz) ;m01
      (clojure.core/- (clojure.core/- 1.0 xx) zz) ;m11
      (clojure.core/- zy wx) ;m21
      0.0
      (clojure.core/- zx wy) ;m02
      (clojure.core/+ zy wx) ;m12
      (clojure.core/- (clojure.core/- 1.0 xx) yy) ;m22
      0.0
      0.0 0.0 0.0 1.0)))
#+END_SRC
***** PVectorTransform
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  PVectorTransform
  (transform-vector
   [_ [vx vy vz :as v]]
   (let [ix (mc/maddsub w vx y vz z vy)
         iy (mc/maddsub w vy z vx x vz)
         iz (mc/maddsub w vz x vy y vx)
         nx (clojure.core/- x) ny (clojure.core/- y) nz (clojure.core/- z)
         iw (mc/msub nx vx y vy z vz)]
     (Vec3.
      (mc/maddsub ix w iw nx iy nz iz ny)
      (mc/maddsub iy w iw ny iz nx ix nz)
      (mc/maddsub iz w iw nz ix ny iy nx)
      (meta v))))
#+END_SRC
***** End of implementation
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
    )
#+END_SRC
**** Constructors
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defn quat
    ([] (Quaternion. 0.0 0.0 0.0 1.0 nil))
    ([[x y z] w] (Quaternion. x y z w nil))
    ([[x y z w]] (Quaternion. x y z w nil))
    ([x y z w] (Quaternion. x y z w nil)))
  
  (defn quat-from-axis-angle
    [axis theta]
    (let [theta (clojure.core/* theta 0.5)]
      (quat (normalize (vec3 axis) (Math/sin theta)) (Math/cos theta))))
  
  (defn quat-from-euler
    [order & [alpha beta gamma]]
    (let [[a b c] (case order
                    :xyz [V3X V3Y V3Z]
                    :yxz [V3Y V3X V3Z]
                    :xzy [V3X V3Z V3Y]
                    :zxy [V3Z V3X V3Y]
                    :yzx [V3Y V3Z V3X]
                    :zyx [V3Z V3Y V3X]
                    (err/illegal-arg! order))]
      (* (quat-from-axis-angle a alpha)
         (quat-from-axis-angle b beta)
         (quat-from-axis-angle c gamma))))
  
  ;; Allan and Mark Watt's "Advanced Animation and Rendering Techniques"
  ;; (ACM Press 1992)
  (defn quat-from-m44
    [^Matrix44 m]
    (let [trace (mc/add (.-m00 m) (.-m11 m) (.-m22 m))]
      (if (pos? trace)
        (let [s (Math/sqrt (clojure.core/+ 1.0 trace))
              w (/ s 2.0)
              s (/ 0.5 s)]
          (Quaternion.
           (mc/subm (.-m21 m) (.-m12 m) s)
           (mc/subm (.-m02 m) (.-m20 m) s)
           (mc/subm (.-m10 m) (.-m01 m) s)
           w nil))
        (let [[i ii] (if (> (.-m11 m) (.-m00 m))
                       [1 (.-m11 m)] [0 (.-m00 m)])
              [i ii] (if (> (.-m22 m) ii)
                       [2 (.-m22 m)] [i ii])
              [jj kk jk kj ij ji ik ki]
              (case i
                0 [(.-m11 m) (.-m22 m) (.-m12 m) (.-m21 m) (.-m01 m) (.-m10 m) (.-m02 m) (.-m20 m)]
                1 [(.-m22 m) (.-m00 m) (.-m20 m) (.-m02 m) (.-m12 m) (.-m21 m) (.-m10 m) (.-m01 m)]
                2 [(.-m00 m) (.-m11 m) (.-m01 m) (.-m10 m) (.-m20 m) (.-m02 m) (.-m21 m) (.-m12 m)])
              s (Math/sqrt (inc (clojure.core/- ii (clojure.core/+ jj kk))))
              x (/ s 2.0)
              s (/ 0.5 s)
              qj (mc/addm ij ji s)
              qk (mc/addm ik ki s)
              qw (mc/subm kj jk s)]
          (case i
            0 (Quaternion. x qj qk qw nil)
            1 (Quaternion. qk x qj qw nil)
            2 (Quaternion. qj qk x qw nil))))))
  
  (defn alignment-quat
    [a b]
    (let [d (dot a b)]
      (cond
       (< d -0.999999) (let [c (cross V3X a)
                             c (if (< (mag c) 1e-6) (cross V3Y a) c)]
                         (quat-from-axis-angle c PI))
       (> d 0.999999) (quat)
       :default (normalize (quat (cross a b) (inc d))))))
#+END_SRC
** Constants
*** Default circle resolution
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (def ^:dynamic *resolution* 20)
#+END_SRC
**** TODO Binding macro
#+BEGIN_SRC clojure
  ;; :tangle babel/src-cljs/thi/ng/geom/macros.clj
  (defmacro with-resolution
    [res & body]
    (binding [*resolution* res] ~@body))
#+END_SRC
** Shared functions
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defn closest-point*
    [lines q]
    (reduce (fn [a b]
              (if (< (dist-squared q a) (dist-squared q b)) a b))
            (map #(closest-point % q) lines)))
  
  (defn from-barycentric*
    [points weights]
    (reduce + (map * points weights)))
  
  (defn centroid*
    [[x & xs :as coll]]
    (let [c (count coll)]
      (if (> c 1)
        (* ((if (instance? Vec2 x) vec2-op-seq vec3-op-seq) clojure.core/+ x xs)
           (/ (count coll)))
        x)))
  
  (defn center*
    ([coll]
       (let [c (centroid* coll)] (mapv #(- % c) coll)))
    ([c c' coll]
       (let [d (- c' c)] (mapv #(+ % d) coll))))
  
  (defn scale-size*
    ([s coll] (scale-size* (centroid* coll) s coll))
    ([c s coll] (mapv #(-> % (- c) (madd s c)) coll)))
  
  (defn bounding-rect*
    ([[x & xs :as coll]]
       (let [c (count coll)]
         (cond
          (> c 1) (let [p (vec2-op-seq clojure.core/min x xs)
                        q (vec2-op-seq clojure.core/max x xs)
                        [w h] (- q p)]
                    (thi.ng.geom.types.Rect. p w h))
          (= c 1) (thi.ng.geom.types.Rect. x 0.0 0.0)
          :default nil)))
    ([p w h] (thi.ng.geom.types.Rect. p w h)))
  
  (defn bounding-box*
    ([[x & xs :as coll]]
       (let [c (count coll)]
         (cond
          (> c 1) (let [p (vec3-op-seq clojure.core/min x xs)
                        q (vec3-op-seq clojure.core/max x xs)]
                    (thi.ng.geom.types.AABB. p (- q p)))
          (= c 1) (thi.ng.geom.types.AABB. x (vec3))
          :default nil)))
    ([p q] (thi.ng.geom.types.AABB. p (- q p))))
  
  (defn max-dist*
    [c points]
    (->> points
         (map #(dist-squared c %))
         (reduce clojure.core/max)
         (Math/sqrt)))
  
  (defn bounding-circle*
    [c r-or-points]
    (thi.ng.geom.types.Circle.
     (vec2 c)
     (if (coll? r-or-points)
       (max-dist* c r-or-points)
       r-or-points)))
  
  (defn bounding-sphere*
    [c r-or-points]
    (thi.ng.geom.types.Sphere.
     (vec3 c)
     (if (coll? r-or-points)
       (max-dist* c r-or-points)
       r-or-points)))
  
  (defn axis-bounds*
    [axis coll]
    (let [xs (map #(nth % axis) coll)]
      [(reduce clojure.core/min xs) (reduce clojure.core/max xs)]))
  
  (defn axis-range*
    [axis coll]
    (let [xs (map #(nth % axis) coll)]
      (clojure.core/- (reduce clojure.core/max xs) (reduce clojure.core/min xs))))
  
  (defn arc-length-index*
    [points]
    (->> points
         (d/successive-nth 2)
         (map #(dist (% 0) (% 1)))
         (reductions clojure.core/+ 0)
         (vec)))
  
  (defn arc-length*
    [points]
    (->> points
         (d/successive-nth 2)
         (map #(dist (% 0) (% 1)))
         (reduce clojure.core/+)))
  
  (defn sample-uniform*
    [udist include-last? points]
    (let [idx (arc-length-index* points)
          total (peek idx)
          delta (/ udist total)
          samples (loop [t 0.0, i 1, acc []]
                    (if (< t 1.0)
                      (let [ct (clojure.core/* t total)
                            i (int (loop [i i] (if (>= ct (idx i)) (recur (inc i)) i)))
                            pi (idx (dec i))]
                        (recur (clojure.core/+ t delta) i
                               (conj acc
                                     (mix (nth points (dec i)) (nth points i)
                                          (mc/subdiv ct pi (idx i) pi)))))
                      acc))]
      (if include-last?
        (conj samples (last points))
        samples)))
  
  (defn point-at*
    ([t points] (point-at* t points nil))
    ([t points idx]
       (when (m/in-range? 0.0 1.0 t)
         (let [n (count points)
               t (double t)]
           (cond
            (== 0 n) nil
            (== 1 n) (first points)
            (== 1.0 t) (last points)
            :default (let [idx (or idx (arc-length-index* points))
                           total (peek idx)
                           ct (clojure.core/* t total)
                           i (int (loop [i 1] (if (>= ct (idx i)) (recur (inc i)) i)))
                           pi (idx (dec i))]
                       (mix (nth points (dec i)) (nth points i)
                            (mc/subdiv ct pi (idx i) pi))))))))
  
  (defn edges*
    [ctor points]
    (->> points (d/successive-nth 2) (mapv ctor)))
  
  (defn tessellate*
    [c points]
    (->> [(first points)]
         (concat points)
         (d/successive-nth 2)
         (map #(vector c (% 0) (% 1)))))
  
  (defn normal3*
    ([a b c] (normalize (cross (- b a) (- c a))))
    ([[a b c]] (normalize (cross (- b a) (- c a)))))
#+END_SRC
** Matrix functions
#+BEGIN_SRC clojure :tangle babel/src/cljx/thi/ng/geom/core.cljx
  (defn frustum
    "Sets up a viewing frustum, shaped like a truncated pyramid with the
    camera where the tip of the pyramid would be.
    This emulates the OpenGL function glFrustum()."
    [l t r b n f]
    (let [dx (clojure.core/- r l)
          dy (clojure.core/- t b)
          dz (clojure.core/- f n)]
      (Matrix44.
       (/ (* 2.0 n) dx) 0.0 (/ (clojure.core/+ r l) dx) 0.0
       0.0 (/ (* 2.0 n) dy) (/ (clojure.core/+ t b) dy) 0.0
       0.0 0.0 (* -1.0 (/ (clojure.core/+ f n) dz)) (/ (* (* -2.0 f) n) dz)
       0.0 0.0 -1.0 0.0)))
  
  (defn frustum-bounds
    [fov aspect near]
    (let [rad (* 0.5 (m/radians fov))
          top (* near (Math/tan rad))
          right (* top aspect)]
      {:left (clojure.core/- right)
       :right right
       :top top
       :bottom (clojure.core/- top)}))
  
  (defn ortho
    "Returns an orthographic projection matrix, in which objects are the same size no
    matter how far away or nearby they are.
    This emulates the OpenGL function glOrtho()."
    [l t r b n f]
    (let[dx (clojure.core/- r l)
         dy (clojure.core/- t b)
         dz (clojure.core/- f n)]
      (Matrix44.
       (/ 2.0 dx) 0.0 0.0 (clojure.core/- (/ (clojure.core/+ r l) dx))
       0.0 (/ 2.0 dy) 0.0 (clojure.core/- (/ (clojure.core/+ t b) dy))
       0.0 0.0 (/ -2.0 dz) (clojure.core/- (/ (clojure.core/+ f n) dz))
       0.0 0.0 0.0 1.0)))
  
  (defn perspective
    "Returns a perspective transform matrix, which makes far away objects appear
    smaller than nearby objects. The `aspect` argument should be the width
    divided by the height of your viewport and `fov` is the vertical angle
    of the field of view in degrees.
    This emulates the OpenGL function gluPerspective()."
    [fov aspect near far]
    (let [rad (* 0.5 (m/radians fov))
          cot (/ (Math/cos rad) (Math/sin rad))
          deltaz (clojure.core/- far near)
          a (/ cot aspect)
          b (clojure.core/- (/ (clojure.core/+ far near) deltaz))
          c (/ (* -2.0 near far) deltaz)]
      (Matrix44.
       a 0.0 0.0 0.0
       0.0 cot 0.0 0.0
       0.0 0.0 b c
       0.0 0.0 -1.0 0.0)))
  
  (defn perspective-frustum
    [fov aspect near far]
    (let [{:keys [left right top bottom]} (frustum-bounds fov aspect near)]
      (frustum left top right bottom near far)))
  
  (defn look-at
    "Returns a matrix that puts the camera at the eye position looking
    toward the target point with the given up direction.
    This emulates the OpenGL function `gluLookAt()`."
    [eye target upvec]
    (let [[fx fy fz :as f] (normalize (- eye target))
          [sx sy sz :as s] (normalize (cross upvec f))
          [tx ty tz :as t] (normalize (cross f s))]
      (Matrix44.
       sx sy sz (clojure.core/- (dot s eye))
       tx ty tz (clojure.core/- (dot t eye))
       fx fy fz (clojure.core/- (dot f eye))
       0.0 0.0 0.0 1.0)))
  
  (defn unproject
    "Takes a vec3 in screenspace, view matrix, projection matrix and
    view rect. Returns vector in model space or nil."
    [v vmat pmat {:keys [p width height]}]
    (let [x (mc/msub (clojure.core/- (v 0) (p 0)) (/ 2.0 width) 1.0)
          y (mc/msub (clojure.core/- (v 1) (p 1)) (/ 2.0 height) 1.0)
          z (mc/msub (v 2) 2.0 1.0)
          vpm (* pmat vmat)]
      (if (invert vpm)
        (let [v' (transform-vector vpm [x y z 1.0])]
          (if-not (zero? (v' 3))
            (div (vec3 v') (v' 3)))))))
#+END_SRC
