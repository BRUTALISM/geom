#+SEQ_TODO:       TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:           Write(w) Update(u) Fix(f) Check(c) noexport(n)
#+EXPORT_EXCLUDE_TAGS: noexport

* thi.ng.geom.delaunay
** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/delaunay.cljx
  (ns thi.ng.geom.delaunay
    (:refer-clojure :exclude [* - + min max])
    (:refer-clojure :rename {+ c+, - c-, * c*, min cmin, max cmax})
    (:require
     [thi.ng.common.math.core :as m :refer [*eps* delta=]]
     [thi.ng.geom.core :as g :refer [+ - * min max]]
     [thi.ng.geom.triangle :refer [circumcircle-raw triangle2]])
    #+clj
    (:import
     [thi.ng.geom.types Triangle2]))
#+END_SRC
** Implementation
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/delaunay.cljx
  (defn- add-unique-edge!
    [edges p q]
    (let [e [p q]]
      (if (edges e)
        (disj! edges e)
        (let [e2 [q p]]
          (if (edges e2) (disj! edges e2) (conj! edges e))))))
  
  (defn- compute-edges
    [complete tris [px py]]
    (persistent!
     (reduce
      (fn [state t]
        (if (complete t) state
            (let [x (c- px (t 3))
                  y (c- py (t 4))]
              (if (<= (c+ (c* x x) (c* y y)) (t 5))
                (assoc! state
                        0 (let [[a b c] t]
                            (-> (state 0)
                                (add-unique-edge! a b)
                                (add-unique-edge! b c)
                                (add-unique-edge! c a))))
                (assoc! state
                        1 (conj! (state 1) t))))))
      (transient [(transient #{}) (transient [])])
      tris)))
  
  (defn- make-triangle
    [a b c]
    (let [[[ox oy] r] (circumcircle-raw a b c)]
      [a b c ox oy (c* r r) (c+ ox r)]))
  
  (defn shared-vertex?
    [[a1 b1 c1] [a2 b2 c2]]
    (or (identical? a1 a2) (identical? a1 b2) (identical? a1 c2)
        (identical? b1 a2) (identical? b1 b2) (identical? b1 c2)
        (identical? c1 a2) (identical? c1 b2) (identical? c1 c2)))
  
  (defn triangulate
    [points]
    (let [points (sort-by #(% 0) points)
          bmin (reduce min points)
          bmax (reduce max points)
          bext (- bmax bmin)
          dm (cmax (bext 0) (bext 1))
          d2 (c* 2.0 dm)
          m (g/mix bmin bmax)
          s (make-triangle (- m d2 dm) (+ m 0 d2) (+ m d2 (c- dm)))]
      (loop [points points tris [s] complete (transient #{})]
        (if-let [[px :as p] (first points)]
          (let [complete (reduce #(if (< (%2 6) px) (conj! % %2) %) complete tris)
                [edges tris] (compute-edges complete tris p)
                tris (reduce #(conj! % (make-triangle (%2 0) (%2 1) p)) tris (persistent! edges))]
            (recur (rest points) (persistent! tris) complete))
          (map
           (fn [t] (triangle2 (t 1) (t 0) (t 2)))
           (remove #(shared-vertex? s %) (persistent! (reduce conj! complete tris))))))))
#+END_SRC
