#+SEQ_TODO:       TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:           Write(w) Update(u) Fix(f) Check(c) noexport(n)
#+EXPORT_EXCLUDE_TAGS: noexport

* Protocols
** Math operations
*** PMathOps
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx :mkdir yes
  (defprotocol PMathOps
    (+ [_] [_ a] [_ a b] [_ a b c])
    (- [_] [_ a] [_ a b] [_ a b c])
    (* [_] [_ a] [_ a b] [_ a b c])
    (div [_] [_ a] [_ a b] [_ a b c])
    (madd [_ a b])
    (abs [_]))
#+END_SRC
*** PSetOps
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PSetOps
    (union [_ x])
    (intersection [_ y])
    (difference [_ x]))
#+END_SRC
*** PDotProduct
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PDotProduct
    (dot [_ a]))
#+END_SRC
*** PCrossProduct
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PCrossProduct
    (cross [_ a]))
#+END_SRC
*** PLimit
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PLimit
    (limit [_ x]))
#+END_SRC
*** PMinMax
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PMinMax
    (min [_ x] [_ a b])
    (max [_ y] [_ a b]))
#+END_SRC
*** PTransposable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PTransposable
    (transpose [_]))
#+END_SRC
*** PNormalize
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PNormalize
    (normalize [_] [_ len])
    (normalized? [_]))
#+END_SRC
*** PInterpolateable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PInterpolateable
    (mix [_ x] [_ x t]))
#+END_SRC
*** PMagnitude
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PMagnitude
    (mag [_])
    (mag-squared [_]))
#+END_SRC
*** PDistance
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PDistance
    (dist [_ a])
    (dist-squared [_ a]))
#+END_SRC
*** PHeading
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PHeading
    (heading-xy [_])
    (heading-xz [_])
    (heading-yz [_])
    (angle-between [_ a])
    (normal [_] [_ a])
    (slope-xy [_])
    (slope-xz [_])
    (slope-yz [_]))
#+END_SRC
*** PMatrix
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PMatrix
    (set-position [_ p] [_ x y])
    (set-scale [_ s] [_ sx sy])
    (set-rotation [_ r])
    (set-shear [_ s] [_ sx sy])
    (determinant [_]))
#+END_SRC
*** PQuaternion
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PQuaternion
    (conjugate [_]))
#+END_SRC
*** PMatrixConvert
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PMatrixConvert
    (as-matrix [_]))
#+END_SRC
** Spatial transform operations
   The position, size and orientation of spatial entities can
   usually be manipulated via the three basic operations: rotate,
   scale & translate. Other, more complex transformations can be
   achieved through combination and repetition of these.
*** PTransformable
  Rotation is always relative to the world origin. For 2D
  implementations, the rotation angle \theta (theta) is always
  interpreted clockwise and only the =rotate= method is
  implemented.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PTransformable
    (rotate-x [_ t])
    (rotate-y [_ t])
    (rotate-z [_ t])
    (rotate [_ t]) ;; alias for rotate-z
    (rotate-around-axis [_ a t])
    (scale [_ s] [_ a b] [_ a b c])
    (scale-size [_ s])
    (shear [_ s] [_ sx sy])
    (translate [_ t] [_ x y] [_ x y z])
    (transform [_ matrix]))
#+END_SRC
*** PVectorTransform
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PVectorTransform
    (transform-vector [_ v]))
#+END_SRC
*** PReflect
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PReflect
    (reflect [_ r]))
#+END_SRC
*** PPolar
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PPolar
    (as-polar [_])
    (as-cartesian [_]))
#+END_SRC
** Graph operations
Most geometric shape constructs can be understood as an undirected
graph of vertices, connected by edges. This protocol provides read
access to entities in _ context.
*** PGraph
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PGraph
    (cyclic? [_])
    (edges [_] [_ n])
    (vertices [_] [_ n])
    (vertex-valence [_ v])
    (vertex-neighbors [_ v]))
#+END_SRC
*** PDirectedGraph
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PDirectedGraph
    (in-vertices [_ v])
    (out-vertices [_ v]))
#+END_SRC
*** PGraphConvert
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PGraphConvert
    (as-graph [_] [_ opts]))
#+END_SRC
** Shape based & structural operations
*** PArea
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PArea
    (area [_]
      "Returns an entity's total surface area"))
#+END_SRC
*** PVolume
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PVolume
    (volume [_]
      "Returns an entity's inner volume."))
#+END_SRC
*** PCircumference
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PCircumference
    (circumference [_]
      "Returns an entity's circumference"))
#+END_SRC
*** PBounds
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PBounds
    (bounds [_]
      "Returns bounding rect for 2d entities or box for 3d")
    (width [_]
      "Returns entity's extent along X axis")
    (height [_]
      "Returns entity's extent along Y axis")
    (depth [_]
      "Returns entity's extent along Z (zero for 2d)"))
#+END_SRC
*** PBoundingCircle
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PBoundingCircle
    (bounding-circle [_]))
#+END_SRC
*** PBoundingSphere
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PBoundingSphere
    (bounding-sphere [_]))
#+END_SRC
*** PBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PBoundary
    (contains-point? [_ p])
    (contains-entity? [_ s]))
#+END_SRC
*** PClassify
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PClassify
    (classify-point [_ p]))
#+END_SRC
*** PProximity
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PProximity
    (closest-point [_ p]))
#+END_SRC
*** PCenter
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PCenter
    (center [_] [_ p]
      "Returns updated entity centered around world origin or given point")
    (centroid [_]
      "Returns centroid of entity"))
#+END_SRC
*** PAlignable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PAlignable
    (align-with [_ x opts]
      "Returns updated entity aligned with `x` in the specified manner"))
#+END_SRC
*** PSampleable
**** TODO move random-point-inside into PBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PSampleable
    (point-at [_ t] [_ u v])
    (random-point [_])
    (random-point-inside [_])
    (sample-uniform [_ dist include-last?])
    (sample-with-resolution [_ res]))
#+END_SRC
*** PPolygonizable
       Anything which can be turned into a polygon will implement _
       protocol consisting of just _ one function: =as-polygon=.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PPolygonizable
    (as-polygon [_] [_ res]
      "Transforms current entity into a Polygon instance"))
#+END_SRC
*** PMeshable
       Anything which can be turned into a 2D or 3D mesh will implement _
       protocol consisting of just _ one function: =as-mesh=.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PMeshable
    (as-mesh [_] [_ opts]
      "Transforms the current enitity into a Mesh instance"))
 #+END_SRC
*** PIntersectable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PIntersectable
    (intersect-line [_ l])
    (intersect-ray [_ r])
    (intersect-shape [_ s]))
#+END_SRC
*** PSliceable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PSliceable
    (slice-with [_ e] [_ e classifier] [_ e classifier parts]))
#+END_SRC
*** PSubdivideable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PSubdivideable
    (subdivide [_] [_ opts])
    (subdivide-edge [_ a b splits])
    (subdivide-face [_ f p displace splits]))
#+END_SRC
*** PTessellateable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PTessellateable
    (tessellate [_] [_ opts]))
#+END_SRC
*** PExtrudeable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PExtrudeable
    (extrude [_ opts])
    (extrude-shell [_ opts]))
#+END_SRC
*** PInvertible
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PInvertible
    (invert [_]))
#+END_SRC
** Type specific operations
*** PCurve
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PCurve
    (arc-length [_])
    (auto-spline [_]))
#+END_SRC
*** PMesh
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/core/protocols.cljx
  (defprotocol PMesh
    (faces [_])
    (vertex-faces [_ v])
    (add-face [_ f])
    (remove-face [_ f])
    (add-mesh [_ m])
    (compute-face-normals [_])
    (compute-vertex-normals [_])
    (remove-vertex [_ v])
    (replace-vertex [_ a b])
    (merge-vertices [_ a b]))
#+END_SRC

