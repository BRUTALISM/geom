#+SETUPFILE: ../../src/setup.org

* Contents                                                         :toc_4_gh:
 - [[#namespace-thinggeomwebglglmesh][Namespace: thi.ng.geom.webgl.glmesh]]
     - [[#limitations][Limitations]]
     - [[#constructors][Constructors]]
     - [[#type-definition][Type definition]]
         - [[#icenter][ICenter]]
         - [[#ivertexaccess][IVertexAccess]]
         - [[#ifaceaccess][IFaceAccess]]
         - [[#igeomcontainer][IGeomContainer]]
         - [[#iclear][IClear]]
         - [[#itransform][ITransform]]
         - [[#iwebglconvert][IWebGLConvert]]
         - [[#end-of-implementation][End of implementation]]
     - [[#helpers][Helpers]]
     - [[#complete-namespace-definition][Complete namespace definition]]

* Namespace: thi.ng.geom.webgl.glmesh

This namespace provides are bare-bones, but speed optimized, *mutable* mesh
implementation primarily intended for display purposes via WebGL. The
=GLMesh= type has the following features:

- customizable vertex attributes: face normals, vertex normals,
  texture coordinates & colors
- native storage in JS typed arrays
- automatic triangle tessellation when adding mesh faces
- automatic face normal calculation when adding faces (and face
  normals are enabled)
- customizable attribute names when calling =gl/as-webgl-buffer-spec=
  (see further below)

** Limitations

- Mesh is not resizable (due to fixed length buffers)
- No support for vertex normal calculation. V-normals must be pre-assigned
- Currently only partial support for mesh analysis and transformations

** Constructors

Since the mesh is built on JS typed arrays, the number of faces in the
mesh must be known at construction time. This doesn't need to (but
generally should) be the exact number, as long as it's at least the
number of faces going to be added. The mesh internally keeps track of
the actual buffer sizes used, but *does no bounds checking*.

The second arg given is an optional set of vertex attribute buffer IDs
(see table under =IWebGLConvert= further below for details).

#+BEGIN_SRC clojure :noweb-ref ctors
  (defn gl-mesh
    "Builds a fixed size mesh with given face count & attribs (a set of
    #{:fnorm :vnorm :uv :col}). All attributes (incl. vertices) are
    stored directly in typed array buffers."
    ([numf] (gl-mesh numf nil))
    ([numf attribs]
    (GLMesh.
      (ta/float32 (* numf 9))
      (if (:fnorm attribs) (ta/float32 (* numf 9)))
      (if (:vnorm attribs) (ta/float32 (* numf 9)))
      (if (:uv attribs) (ta/float32 (* numf 6)))
      (if (:col attribs) (ta/float32 (* numf 12)))
      0
      attribs)))
#+END_SRC

** Type definition

#+BEGIN_SRC clojure :noweb-ref impl
  (defrecord GLMesh
      [^js/Float32Array vertices
       ^js/Float32Array fnormals
       ^js/Float32Array vnormals
       ^js/Float32Array uvs
       ^js/Float32Array cols
       ^:mutable id
       attribs]
#+END_SRC

*** ICenter
#+BEGIN_SRC clojure :noweb-ref impl
  g/ICenter
  (center
   [_] (g/center _ (vec3)))
  (center [_ o] (g/translate _ (m/- o (g/centroid _))))
  (centroid
   [_] (gu/centroid (set (g/vertices _))))
#+END_SRC

*** IVertexAccess
#+BEGIN_SRC clojure :noweb-ref impl
  g/IVertexAccess
  (vertices
   [_]
   (let [num (* id 9)]
     (loop [acc (transient []), i 0]
       (if (< i num)
         (recur
          (conj! acc (thi.ng.geom.core.vector.Vec3. (.slice vertices i (+ i 3)) nil nil))
          (+ i 3))
         (persistent! acc)))))
#+END_SRC

*** IFaceAccess
#+BEGIN_SRC clojure :noweb-ref impl
  g/IFaceAccess
  (add-face
   [_ f] (add-face* _ f))
#+END_SRC

*** IGeomContainer
#+BEGIN_SRC clojure :noweb-ref impl
  g/IGeomContainer
  (into
   [_ faces] (tu/into-mesh _ add-face* faces))
#+END_SRC

*** IClear

These protocol methods are used internally by =g/into=.

#+BEGIN_SRC clojure :noweb-ref impl
  g/IClear
  (clear*
   [_] (gl-mesh (/ (.-length vertices) 9) attribs))
  (clear!
   [_] (set! id 0) _)
#+END_SRC

*** ITransform
#+BEGIN_SRC clojure :noweb-ref impl
  g/IScale
  (scale
   [_ s] (transform-vertices #(m/*! % s) vertices (* id 9)) _)
  (scale
   [_ sx sy sz] (transform-vertices #(m/*! % sx sy sz) vertices (* id 9)) _)
  (scale-size
   [_ s]
   (let [c (g/centroid _)]
     (transform-vertices #(m/madd! (m/-! % c) s c) vertices (* id 9))) _)
  g/ITranslate
  (translate
   [_ t] (transform-vertices #(m/+! % t) vertices (* id 9)) _)
  g/ITransform
  (transform
   [_ tx] (transform-vertices #(g/transform-vector tx %) vertices (* id 9)) _)
#+END_SRC

*** IWebGLConvert

Since a GLMesh holds all its data in typed arrays, conversion into a
readily usable format for display purposes is reduced to a straight
forward re-formatting into WebGL spec map. By supplying an =:attribs=
map in the 2nd arg (options map), all mesh attributes can be renamed
in the spec map. The default attribute names are:

| *Key*       | *Default value* | *Description*     |
|-------------+-----------------+-------------------|
| =:position= | =:position=     | vertex positions  |
| =:fnorm=    | =:normal=       | face normals      |
| =:vnorm=    | =:normal=       | vertex normals    |
| =:uv=       | =:uv=           | UV texture coords |
| =:col=      | =:color=        | vertex colors     |

*Note:* As mentioned above, the =GLMesh= is *not* able to compute
 vertex normals itself.

If a shader requires that an attribute must be renamed in the
resulting spec map, call the function like this:

#+BEGIN_SRC clojure
  ;; rename :position & :uv attribs in result spec
  (gl/as-webgl-buffer-spec mesh {:attribs {:uv :texcoord, :position :pos}})
#+END_SRC

Furthermore, the options map also supports the following other keys:

- =:mode= - WebGL draw mode (default: =gl/triangles=)
- =:num-vertices= - number of vertices to draw (default: number mesh verts)

#+BEGIN_SRC clojure :noweb-ref impl
  gl/IWebGLConvert
  (as-webgl-buffer-spec
   [_ {:keys [attribs] :as opts}]
   {:attribs      (cond->    {(or (:position attribs) :position) {:data vertices :size 3}}
                    fnormals (assoc (or (:fnorm attribs) :normal) {:data fnormals :size 3})
                    vnormals (assoc (or (:vnorm attribs) :normal) {:data vnormals :size 3})
                    uvs      (assoc (or (:uv attribs) :uv) {:data uvs :size 2})
                    cols     (assoc (or (:col attribs) :color) {:data cols :size 4}))
    :num-vertices (or (:num-vertices opts) (* id 3))
    :mode         (or (:mode opts) gl/triangles)})
#+END_SRC

*** End of implementation
#+BEGIN_SRC clojure :noweb-ref impl
  )
#+END_SRC

** Helpers

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn add-face*
    [m [verts attribs :as f]]
    (if (> (count verts) 3)
      (->> f
           ((gu/tessellate-face gu/tessellate-with-first))
           (run! #(add-face* m %)))
      (let [{:keys [vertices fnormals vnormals uvs cols id]} m
            idv     (* id 9)
            iduv    (* id 6)
            idcol   (* id 12)]
        (.set vertices (.-buf ^thi.ng.geom.core.vector.Vec3 (first verts)) idv)
        (.set vertices (.-buf ^thi.ng.geom.core.vector.Vec3 (nth verts 1)) (+ idv 3))
        (.set vertices (.-buf ^thi.ng.geom.core.vector.Vec3 (nth verts 2)) (+ idv 6))
        (when fnormals
          (let [n  (or (:fnorm attribs) (gu/ortho-normal verts))
                nb (.-buf ^thi.ng.geom.core.vector.Vec3 n)]
            (.set fnormals nb idv)
            (.set fnormals nb (+ idv 3))
            (.set fnormals nb (+ idv 6))))
        (when-let [vn (and vnormals (:vnorm attribs))]
          (.set vnormals (.-buf ^thi.ng.geom.core.vector.Vec3 (first vn)) idv)
          (.set vnormals (.-buf ^thi.ng.geom.core.vector.Vec3 (nth vn 1)) (+ idv 3))
          (.set vnormals (.-buf ^thi.ng.geom.core.vector.Vec3 (nth vn 2)) (+ idv 6)))
        (when-let [uv (and uvs (:uv attribs))]
          (.set uvs (.-buf ^thi.ng.geom.core.vector.Vec2 (first uv)) iduv)
          (.set uvs (.-buf ^thi.ng.geom.core.vector.Vec2 (nth uv 1)) (+ iduv 2))
          (.set uvs (.-buf ^thi.ng.geom.core.vector.Vec2 (nth uv 2)) (+ iduv 4)))
        (when-let [col (and cols (:col attribs))]
          (->> (streams/into-buffer (first col) cols 4 idcol)
               (streams/into-buffer (nth col 1) cols 4)
               (streams/into-buffer (nth col 2) cols 4)))
        (set! (.-id m) (inc id))))
    m)

  (defn transform-vertices
    [f buf num]
    (let [tv (vec3 0 0 0)
          tb (.-buf ^thi.ng.geom.core.vector.Vec3 tv)]
      (loop [i 0]
        (when (< i num)
          (.set tb (.slice buf i (+ i 3)) 0)
          (.set buf (.-buf ^thi.ng.geom.core.vector.Vec3 (f tv)) i)
          (recur (+ i 3))))))
#+END_SRC

** Complete namespace definition

#+BEGIN_SRC clojure :tangle ../babel/src/thi/ng/geom/webgl/glmesh.cljs :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.webgl.glmesh
    (:require
     [thi.ng.math.core :as m]
     [thi.ng.geom.core :as g]
     [thi.ng.geom.core.vector :as v :refer [vec2 vec3]]
     [thi.ng.geom.core.utils :as gu]
     [thi.ng.geom.types.utils :as tu]
     [thi.ng.geom.webgl.core :as gl]
     [thi.ng.dstruct.streams :as streams]
     [thi.ng.typedarrays.core :as ta]))

  (declare gl-mesh)

  <<helpers>>

  <<impl>>

  <<ctors>>
#+END_SRC
