#+SETUPFILE: ../../src/setup.org

* Contents                                                         :toc_4_gh:
 - [[#namespace-thinggeomwebgliglmesh][Namespace: thi.ng.geom.webgl.iglmesh]]
     - [[#limitations][Limitations]]
     - [[#constructors][Constructors]]
     - [[#type-definition][Type definition]]
         - [[#icenter][ICenter]]
         - [[#ivertexaccess][IVertexAccess]]
         - [[#ifaceaccess][IFaceAccess]]
         - [[#igeomcontainer][IGeomContainer]]
         - [[#iclear][IClear]]
         - [[#itransform][ITransform]]
         - [[#iwebglconvert][IWebGLConvert]]
         - [[#end-of-implementation][End of implementation]]
     - [[#helpers][Helpers]]
     - [[#complete-namespace-definition][Complete namespace definition]]

* Namespace: thi.ng.geom.webgl.iglmesh

This namespace provides are bare-bones, but speed optimized, *mutable* mesh
implementation primarily intended for display purposes via WebGL. The
=GLMesh= type has the following features:

- customizable vertex attributes: face normals, vertex normals,
  texture coordinates & colors
- native storage in JS typed arrays
- automatic triangle tessellation when adding mesh faces
- automatic face normal calculation when adding faces (and face
  normals are enabled)
- customizable attribute names when calling =gl/as-webgl-buffer-spec=
  (see further below)

** Limitations

- Mesh is not resizable (due to fixed length buffers)
- No support for vertex normal calculation. V-normals must be pre-assigned
- Currently only partial support for mesh analysis and transformations

** Constructors

Since the mesh is built on JS typed arrays, the number of faces in the
mesh must be known at construction time. This doesn't need to (but
generally should) be the exact number, as long as it's at least the
number of faces going to be added. The mesh internally keeps track of
the actual buffer sizes used, but *does no bounds checking*.

The second arg given is an optional set of vertex attribute buffer IDs
(see table under =IWebGLConvert= further below for details).

#+BEGIN_SRC clojure :noweb-ref ctors
  (defn igl-mesh
    "Builds a fixed size mesh with given face count & attribs (a set of
    #{:fnorm :vnorm :uv :col}). All attributes (incl. vertices) are
    stored directly in typed array buffers."
    ([numf] (igl-mesh numf nil))
    ([numf attribs]
     (IndexedGLMesh.
      (ta/float32 (* numf 9))
      (if (:fnorm attribs) (ta/float32 (* numf 9)))
      (if (:vnorm attribs) (ta/float32 (* numf 9)))
      (if (:uv attribs) (ta/float32 (* numf 6)))
      (if (:col attribs) (ta/float32 (* numf 12)))
      (ta/uint16 (* numf 3))
      attribs
      {} 0 0)))
#+END_SRC

** Type definition

#+BEGIN_SRC clojure :noweb-ref impl
  (defrecord IndexedGLMesh
      [^js/Float32Array vertices
       ^js/Float32Array fnormals
       ^js/Float32Array vnormals
       ^js/Float32Array uvs
       ^js/Float32Array cols
       ^js/Uint16Array indices
       attribs
       ^:mutable index
       ^:mutable id
       ^:mutable fid]
#+END_SRC

*** ICenter
#+BEGIN_SRC clojure :noweb-ref impl
  g/ICenter
  (center
   [_] (g/center _ (vec3)))
  (center
   [_ o] (g/translate _ (m/- o (g/centroid _))))
  (centroid
   [_] (gu/centroid (g/vertices _)))
#+END_SRC

*** IVertexAccess
#+BEGIN_SRC clojure :noweb-ref impl
  g/IVertexAccess
  (vertices
   [_]
   (let [num (* id 9)]
     (loop [acc (transient #{}), i 0]
       (if (< i num)
         (recur
          (conj! acc (thi.ng.geom.core.vector.Vec3. (.slice vertices i (+ i 3)) nil nil))
          (+ i 3))
         (persistent! acc)))))
#+END_SRC

*** IFaceAccess
#+BEGIN_SRC clojure :noweb-ref impl
  g/IFaceAccess
  (add-face
   [_ f] (add-face* _ f))
#+END_SRC

*** IGeomContainer
#+BEGIN_SRC clojure :noweb-ref impl
  g/IGeomContainer
  (into
   [_ m]
   (if (instance? IndexedGLMesh m)
     (do (into-iglmesh* _ m) (set! id (+ id (:id m))) _) ;; FIXME
     (tu/into-mesh _ add-face* m)))
#+END_SRC

*** IClear

These protocol methods are used internally by =g/into=.

#+BEGIN_SRC clojure :noweb-ref impl
  g/IClear
  (clear*
   [_] (igl-mesh (/ (.-length vertices) 9) attribs))
  (clear!
   [_] (set! id 0) (set! fid 0) _)
#+END_SRC

*** ITransform
#+BEGIN_SRC clojure :noweb-ref impl
  g/IScale
  (scale
   [_ s] (transform-vertices #(m/*! % s) vertices (* id 9)) _)
  (scale
   [_ sx sy sz] (transform-vertices #(m/*! % sx sy sz) vertices (* id 9)) _)
  (scale-size
   [_ s]
   (let [c (g/centroid _)]
     (transform-vertices #(m/madd! (m/-! % c) s c) vertices (* id 9))) _)
  g/ITranslate
  (translate
   [_ t] (transform-vertices #(m/+! % t) vertices (* id 9)) _)
  g/ITransform
  (transform
   [_ tx] (transform-vertices #(g/transform-vector tx %) vertices (* id 9)) _)
#+END_SRC

*** IWebGLConvert

Since a GLMesh holds all its data in typed arrays, conversion into a
readily usable format for display purposes is reduced to a straight
forward re-formatting into WebGL spec map. By supplying an =:attribs=
map in the 2nd arg (options map), all mesh attributes can be renamed
in the spec map. The default attribute names are:

| *Key*       | *Default value* | *Description*     |
|-------------+-----------------+-------------------|
| =:position= | =:position=     | vertex positions  |
| =:fnorm=    | =:normal=       | face normals      |
| =:vnorm=    | =:normal=       | vertex normals    |
| =:uv=       | =:uv=           | UV texture coords |
| =:col=      | =:color=        | vertex colors     |

*Note:* As mentioned above, the =GLMesh= is *not* able to compute
 vertex normals itself.

If a shader requires that an attribute must be renamed in the
resulting spec map, call the function like this:

#+BEGIN_SRC clojure
  ;; rename :position & :uv attribs in result spec
  (gl/as-webgl-buffer-spec mesh {:attribs {:uv :texcoord, :position :pos}})
#+END_SRC

Furthermore, the options map also supports the following other keys:

- =:mode= - WebGL draw mode (default: =gl/triangles=)
- =:num-vertices= - number of vertices to draw (default: number mesh verts)

#+BEGIN_SRC clojure :noweb-ref impl
  gl/IWebGLConvert
  (as-webgl-buffer-spec
   [_ {:keys [attribs] :as opts}]
   {:attribs      (cond->    {(or (:position attribs) :position) {:data vertices :size 3}}
                    fnormals (assoc (or (:fnorm attribs) :normal) {:data fnormals :size 3})
                    vnormals (assoc (or (:vnorm attribs) :normal) {:data vnormals :size 3})
                    uvs      (assoc (or (:uv attribs) :uv) {:data uvs :size 2})
                    cols     (assoc (or (:col attribs) :color) {:data cols :size 4}))
    :indices      {:data indices}
    :num-items    fid
    :num-vertices (or (:num-vertices opts) id)
    :mode         (or (:mode opts) gl/triangles)})
#+END_SRC

*** End of implementation
#+BEGIN_SRC clojure :noweb-ref impl
  )
#+END_SRC

** Helpers

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn- index-vertex*
    [m f vertices fnormals vnormals cols uvs]
    (or (get (.-index m) f)
        (let [id  (.-id ^IndexedGLMesh m)
              idv (* id 3)
              [v fn vn col uv] f]
          (.set vertices (.-buf ^thi.ng.geom.core.vector.Vec3 v) idv)
          (if (and fnormals fn)
            (.set fnormals (.-buf ^thi.ng.geom.core.vector.Vec3 fn) idv)
            (if (and vnormals vn)
              (.set vnormals (.-buf ^thi.ng.geom.core.vector.Vec3 vn) idv)))
          (when (and cols col)
            (streams/into-buffer col cols 4 (* id 4)))
          (when (and uvs uv)
            (.set uvs (.-buf ^thi.ng.geom.core.vector.Vec2 uv) (* id 2)))
          (set! (.-index ^IndexedGLMesh m) (assoc (.-index ^IndexedGLMesh m) f id))
          (set! (.-id ^IndexedGLMesh m) (inc id))
          id)))

  (defn- add-face*
    [m [verts attribs :as f]]
    (if (> (count verts) 3)
      (->> f
           ((gu/tessellate-face gu/tessellate-with-first))
           (run! #(add-face* m %)))
      (let [{:keys [vertices fnormals vnormals uvs cols id fid indices]} m
            {:keys [vnorm uv col]} attribs
            fnorm (if fnormals (or (get attribs :fnorm) (gu/ortho-normal verts)))
            ida (index-vertex*
                 m [(nth verts 0) fnorm (nth vnorm 0 nil) (nth col 0 nil) (nth uv 0 nil)]
                 vertices fnormals vnormals cols uvs)
            idb (index-vertex*
                 m [(nth verts 1) fnorm (nth vnorm 1 nil) (nth col 1 nil) (nth uv 1 nil)]
                 vertices fnormals vnormals cols uvs)
            idc (index-vertex*
                 m [(nth verts 2) fnorm (nth vnorm 2 nil) (nth col 2 nil) (nth uv 2 nil)]
                 vertices fnormals vnormals cols uvs)]
        (aset indices fid ida)
        (aset indices (+ fid 1) idb)
        (aset indices (+ fid 2) idc)
        (set! (.-fid m) (+ fid 3))
        m)))

  (defn transform-vertices
    [f buf num]
    (let [tv (vec3 0 0 0)
          tb (.-buf ^thi.ng.geom.core.vector.Vec3 tv)]
      (loop [i 0]
        (when (< i num)
          (.set tb (.slice buf i (+ i 3)) 0)
          (.set buf (.-buf ^thi.ng.geom.core.vector.Vec3 (f tv)) i)
          (recur (+ i 3))))))

  (defn- into-iglmesh*
    [dest src]
    (let [s-id    (:id src)
          d-id    (:id dest)
          s-idv   (* s-id 9)
          d-idv   (* d-id 9)
          s-iduv  (* s-id 6)
          d-iduv  (* d-id 6)
          s-idcol (* s-id 12)
          d-idcol (* d-id 12)]
      (.set (:vertices dest) (.slice (:vertices src) 0 s-idv) d-idv)
      (when (and (:fnormals dest) (:fnormals src))
        (.set (:fnormals dest) (.slice (:fnormals src) 0 s-idv) d-idv))
      (when (and (:vnormals dest) (:vnormals src))
        (.set (:vnormals dest) (.slice (:vnormals src) 0 s-idv) d-idv))
      (when (and (:uvs dest) (:uvs src))
        (.set (:uvs dest) (.slice (:uvs src) 0 s-iduv) d-iduv))
      (when (and (:cols dest) (:cols src))
        (.set (:cols dest) (.slice (:cols src) 0 s-idcol) d-idcol))
      dest))
#+END_SRC

** Complete namespace definition

#+BEGIN_SRC clojure :tangle ../babel/src/thi/ng/geom/webgl/iglmesh.cljs :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.webgl.iglmesh
    (:require
     [thi.ng.math.core :as m]
     [thi.ng.geom.core :as g]
     [thi.ng.geom.core.vector :as v :refer [vec2 vec3]]
     [thi.ng.geom.core.utils :as gu]
     [thi.ng.geom.types.utils :as tu]
     [thi.ng.geom.webgl.core :as gl]
     [thi.ng.dstruct.streams :as streams]
     [thi.ng.typedarrays.core :as ta]))

  (declare igl-mesh)

  <<helpers>>

  <<impl>>

  <<ctors>>
#+END_SRC
