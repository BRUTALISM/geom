** Demo

#+BEGIN_SRC clojure :noweb-ref demo
  (defn ilios
    []
    (let [p   (-> (a/aabb [0.6 0.6 1.2]) (g/center (vec3 0 0 0.6)) (g/as-mesh))
          p1  (-> (a/aabb [0.5 0.5 1.2]) (g/center (vec3 0 0 0.55)) (g/as-mesh))
          p2  (-> (a/aabb [0.5 0.7 0.5]) (g/center (vec3 0 0 0.3)) (g/as-mesh))
          p2* (g/transform p2 (g/rotate-z M44 m/HALF_PI))
          p3  (-> (a/aabb [0.7 0.5 0.7]) (g/center (vec3 0 0.3 0.95)) (g/as-mesh))
          p3* (g/transform p3 (g/translate M44 0 -0.6 0))]
      (-> (->> [p p1 p2 p2* p3 p3*]
               (map csg/mesh->csg)
               (reduce csg/subtract)
               (csg/csg->mesh))
          (g/transform (g/rotate-x M44 (- m/HALF_PI))))))
  
  (defn csg-mesh1
    []
    (let [ma (-> (a/aabb 1) (g/as-mesh))
          mb (-> (s/sphere 1) (g/as-mesh {:res 10}))
          mc (-> (s/sphere 0.9) (g/as-mesh {:res 10}))
          mesh (-> ma
                   (csg/mesh->csg)
                   (csg/intersect (csg/mesh->csg mb))
                   (csg/subtract (csg/mesh->csg mc))
                   (csg/csg->mesh)
                   (g/center)
                   (g/transform (g/scale M44 0.75)))]
      ))
  
  (defn ^:export demo
    []
    (enable-console-print!)
    (let [gl           (gl/gl-context "main")
          light-shader (sh/make-shader-from-spec gl shadow/light-pass-spec)
          cam-shader   (sh/make-shader-from-spec gl shadow/cam-pass-spec)
          mesh         (ilios)
          room         (-> (a/aabb 5)
                           (g/center (vec3 0 2.4 0))
                           (g/as-mesh)
                           (g/flip))
          mesh         (g/into mesh room)
          spec         (gl/as-webgl-buffer-spec mesh {:tessellate true :fnormals true})
          model        {:attribs (buf/make-attribute-buffers
                                  gl gl/static-draw
                                  {:position {:data (:vertices spec) :size 3}
                                   :normal   {:data (:normals spec) :size 3}})
                        :mode gl/triangles
                        :count (:num-vertices spec)}
          view-rect    (gl/get-viewport-rect gl)
          cam-proj     (gl/perspective 45 view-rect 0.1 100.0)
          light-proj   (gl/perspective 45 1 0.01 100)
          light-fbo    (shadow/init-light-fbo gl 256)
          timer        (atom 0)
          fps          (.getElementById js/document "fps")]
  
      (anim/animate
       (fn [t]
         (let [y          (m/map-interval (Math/sin (* t 0.5)) -1 1 0 3)
               cam-view   (-> (vec3 0 y 2)
                              (g/rotate-y (* t 0.4))
                              (mat/look-at (vec3 0 0.6 0) (vec3 0 1 0)))
               model-tx        (-> M44 (g/translate 0 0 0) (g/rotate-x (* 0 0.15)))
               ;; model-tx-inv (-> tx1 (g/invert) (g/transpose))
               ;; light-pos (vec3 (* 0.2 (Math/sin t)) 1 0)
               cone-angle (m/map-interval (Math/cos (* t 0.3)) -1 1 20 150)
               l-rotx     (* (m/map-interval (Math/cos (* t 0.7)) -1 1 0.15 0.85) m/PI)
               light-view (-> M44 (g/translate 0 0 -2.5) (g/rotate-x l-rotx) (g/rotate-y -0.6))
               light-rot  (mat/matrix44->matrix33-rot light-view)]
  
           (shadow/draw-light-pass
            gl light-fbo
            #(buf/draw-arrays
              gl (assoc model
                   :shader  light-shader
                   :attribs (select-keys (:attribs model) [:position])
                   :uniforms {:model model-tx
                              :view  light-view
                              :proj  light-proj})))
           (gl/set-viewport gl view-rect)
           (gl/clear-color-buffer gl 0.08 0.1 0.12 1.0)
           (shadow/draw-cam-pass
            gl (:tex light-fbo)
            (fn [uniforms]
              (buf/draw-arrays
               gl (assoc model
                    :shader   cam-shader
                    :uniforms (assoc uniforms
                                :model     model-tx
                                :view      cam-view
                                :proj      cam-proj
                                :lightView light-view
                                :lightProj light-proj
                                :lightRot  light-rot
                                :coneAngle cone-angle)))))
  
           (set!
            (.-textContent fps)
            (str (.toFixed (js/Number. (/ 1 (- t @timer))) 2) "fps"))
           (reset! timer t)
           ;; keep animating...
           true)))
      {:ctx gl}))
  
  (demo)
#+END_SRC


** Complete namespace definition

#+BEGIN_SRC clojure :tangle ../babel/test/thi/ng/geom/webgl/example01.cljs :noweb yes :mkdirp yes :padline no
(ns thi.ng.geom.webgl.example01
  (:require
    [thi.ng.geom.webgl.core :as gl]
    [thi.ng.geom.webgl.arrays :as arrays]
    [thi.ng.geom.webgl.animator :as anim]
    [thi.ng.geom.webgl.buffers :as buf]
    [thi.ng.geom.webgl.shaders :as sh]
    [thi.ng.geom.webgl.shaders.phong :as phong]
    [thi.ng.geom.webgl.shaders.spotlight :as spotlight]
    [thi.ng.geom.webgl.shaders.shadow :as shadow]
    [thi.ng.geom.webgl.utils :as u]
    [thi.ng.geom.core :as g]
    [thi.ng.geom.core.vector :as v :refer [vec2 vec3]]
    [thi.ng.geom.core.matrix :as mat :refer [M44]]
    [thi.ng.geom.types]
    [thi.ng.geom.aabb :as a]
    [thi.ng.geom.sphere :as s]
    [thi.ng.geom.gmesh]
    [thi.ng.geom.mesh.csg :as csg]
    ;;[thi.ng.geom.mesh.subdivision :as sd]
    [thi.ng.common.math.core :as m]
    [thi.ng.common.error :as err])
  (:require-macros
    [thi.ng.macromath.core :as mm]))

  <<demo>>
#+END_SRC
