** Phong

#+BEGIN_SRC c :noweb-ref phong-vs
  void main(){
      gl_Position = proj * mv * vec4(aPos, 1.0);
      vec4 vp4 = mv * vec4(aPos, 1.0);
      vPos = vp4.xyz / vp4.w;
      vCol = aNorm * 0.5 + 0.5;
      vNormalMix = (normalMat * vec4(aNorm, 0.0)).xyz;
  }
#+END_SRC

#+BEGIN_SRC c :noweb-ref phong-fs
  vec3 colAmbient = vec3(0.05, 0.05, 0.1);
  vec3 colDiffuse = vCol;
  vec3 colSpec = vec3(1.0, 1.0, 0.9);

  void main() {

    vec3 normal = normalize(vNormalMix);
    vec3 lightDir = normalize(lightPos - vPos);

    float lambertian = max(dot(lightDir,normal), 0.0);
    float specular = 0.0;

    if(lambertian > 0.0) {

      vec3 viewDir = normalize(-vPos);

      // this is blinn phong
      vec3 halfDir = normalize(lightDir + viewDir);
      float specAngle = max(dot(halfDir, normal), 0.0);
      specular = pow(specAngle, specExp);         
    }

    gl_FragColor = vec4(colAmbient +
                        lambertian * colDiffuse +
                        specular * colSpec, 1.0);
  }
#+END_SRC

** Demo

#+BEGIN_SRC clojure :noweb-ref demo :noweb yes
  (def vs "
   <<phong-vs>>")

  (def fs "
   <<phong-fs>>")
#+END_SRC

#+BEGIN_SRC clojure :noweb-ref demo
  (defn ^:export demo
    []
    (enable-console-print!)
    (let [gl (gl/gl-context "main")
          shader (sh/make-shader-from-spec
                  gl {:vs vs
                      :fs fs
                      :uniforms {:mv :mat4
                                 :proj :mat4
                                 :normalMat :mat4
                                 :specExp :float
                                 :lightPos :vec3}
                      :attribs {:aPos :vec3
                                :aNorm :vec3}
                      :varying {:vNormalMix :vec3
                                :vPos :vec3
                                :vCol :vec3}})
          ;; mesh (-> (a/aabb) (g/center) (g/as-mesh))
          ;; mesh (-> (s/sphere 0.5) (g/as-mesh {:res 20}))
          ma (-> (a/aabb 1) (g/as-mesh))
          mb (-> (s/sphere [1 1 1] 1) (g/as-mesh {:res 10}))
          mc (-> (s/sphere [1 1 1] 0.9) (g/as-mesh {:res 10}))
          mesh (-> ma
                   (csg/mesh->csg)
                   (csg/intersect (csg/mesh->csg mb))
                   (csg/subtract (csg/mesh->csg mc))
                   (csg/csg->mesh)
                   (g/center)
                   ;;(g/transform (g/scale M44 0.75))
                   ;;(sd/catmull-clark)
                   )
          spec (gl/as-webgl-buffer-spec mesh {:tessellate true :fnormals true})
          _ (prn (:num-vertices spec))
          model {:shader shader
                 :attribs (buf/make-attribute-buffers
                           gl gl/static-draw
                           {:aPos {:data (:vertices spec) :comps 3}
                            :aNorm {:data (:normals spec) :comps 3}})
                 :uniforms {}
                 :mode gl/triangles
                 :count (:num-vertices spec)}
          timer (atom 0)]
      (anim/animate
       (fn [t]
         (let [mv (-> (mat/look-at (vec3 0 0 2) (vec3) (vec3 0 1 0))
                      (g/rotate-y (* 0 0.5)))
               tx1 (->> (g/translate M44 -0.5 0 0)
                        (g/* (g/rotate-x M44 (* t 0.15)))
                        (g/* mv))
               tx1inv (-> tx1 (g/invert) (g/transpose))
               tx2 (->> (g/translate M44 0.5 0 0)
                        (g/* (g/rotate-x M44 (* t -0.15)))
                        (g/* mv))
               tx2inv (-> tx2 (g/invert) (g/transpose))
               proj (gl/perspective (gl/get-viewport-rect gl) 45 0.1 100.0)
               light-pos (vec3 (* 2 (Math/sin t)) 0.0 1)
               tx3 (->> (g/scale (g/translate M44 light-pos) 0.2)
                        (g/* mv))
               tx3inv (-> tx3 (g/invert) (g/transpose))]
           (gl/clear-depth-buffer gl 1)
           (gl/clear-color-buffer gl 0 0 0 1.0)
           (.enable gl gl/depth-test)
           (buf/draw-arrays
            gl (merge model {:uniforms {:mv tx1 :proj proj :normalMat tx1inv
                                        :specExp 16
                                        :lightPos light-pos}}))
           (buf/draw-arrays
            gl (merge model {:uniforms {:mv tx2 :proj proj :normalMat tx2inv
                                        :specExp 16
                                        :lightPos light-pos}}))
           (buf/draw-arrays
            gl (merge model {:uniforms {:mv tx3 :proj proj :normalMat tx3inv
                                        :specExp 100
                                        :lightPos light-pos}}))
           (set! (.-textContent (.getElementById js/document "fps")) (str (/ 1 (- t @timer)) "fps"))
           (reset! timer t)
           true)))
      {:ctx gl
       :shader shader}))

  (demo)
#+END_SRC


** Complete namespace definition

#+BEGIN_SRC clojure :tangle ../babel/test/thi/ng/geom/webgl/example01.cljs :noweb yes :mkdirp yes :padline no
(ns thi.ng.geom.webgl.example01
  (:require
    [thi.ng.geom.webgl.core :as gl]
    [thi.ng.geom.webgl.arrays :as arrays]
    [thi.ng.geom.webgl.animator :as anim]
    [thi.ng.geom.webgl.buffers :as buf]
    [thi.ng.geom.webgl.shaders :as sh]
    [thi.ng.geom.webgl.utils :as u]
    [thi.ng.geom.core :as g]
    [thi.ng.geom.core.vector :as v :refer [vec2 vec3]]
    [thi.ng.geom.core.matrix :as mat :refer [M44]]
    [thi.ng.geom.types]
    [thi.ng.geom.aabb :as a]
    [thi.ng.geom.sphere :as s]
    [thi.ng.geom.gmesh]
    [thi.ng.geom.mesh.csg :as csg]
    [thi.ng.geom.mesh.subdivision :as sd]
    [thi.ng.common.error :as err])
  (:require-macros
    [thi.ng.macromath.core :as mm]))

  <<demo>>
#+END_SRC
