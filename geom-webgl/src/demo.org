** Demo

#+BEGIN_SRC clojure :noweb-ref demo
  (defn mg-hex-sphere
    []
    (let [hex (mg/apply-recursively (mg/reflect :dir :e) 5 [1] 1)
          reflected-hex (mg/reflect :dir :n :out [{} hex])
          inject #(-> hex
                      (assoc-in (mg/child-path [1 1 0]) %)
                      (assoc-in (mg/child-path [1 1 1 1 0]) %))
          seed-clone (mg/reflect :dir :s :out [{} (inject reflected-hex)])
          tree (mg/reflect :dir :s :out [(inject seed-clone) (inject reflected-hex)])]
      (-> (mg/seed (mg/sphere-lattice-seg 6 0.25 0.0955 0.2))
          (mg/walk tree)
          (mg/union-mesh)
          (g/transform (-> M44 (g/rotate-x (- m/HALF_PI)) (g/scale 0.5))))))
  
  (defn ^:export demo
    []
    (enable-console-print!)
    (let [gl           (gl/gl-context "main")
          light-shader (sh/make-shader-from-spec gl shadow/light-pass-spec)
          cam-shader   (sh/make-shader-from-spec gl shadow/cam-pass-spec)
          ;;mesh         (ilios)
          mesh         (mg-hex-sphere)
          room         (-> (a/aabb 5)
                           (g/center (vec3 0 2.4 0))
                           (g/as-mesh)
                           (g/flip))
          mesh         (g/into mesh room)
          spec         (gl/as-webgl-buffer-spec mesh {:tessellate true :fnormals true})
          model        {:attribs (buf/make-attribute-buffers
                                  gl gl/static-draw
                                  {:position {:data (:vertices spec) :size 3}
                                   :normal   {:data (:normals spec) :size 3}})
                        :mode gl/triangles
                        :count (:num-vertices spec)}
          view-rect    (gl/get-viewport-rect gl)
          cam-proj     (gl/perspective 45 view-rect 0.1 100.0)
          light-proj   (gl/perspective 45 1 0.01 100)
          light-fbo    (shadow/init-light-fbo gl 256)
          timer        (atom 0)
          fps          (.getElementById js/document "fps")]
  
      (anim/animate
       (fn [t]
         (let [y          (m/map-interval (Math/sin (* t 0.5)) -1 1 0 3)
               cam-view   (-> (vec3 0 y 2)
                              (g/rotate-y (* t 0.4))
                              (mat/look-at (vec3 0 0.6 0) (vec3 0 1 0)))
               model-tx   (-> M44 (g/translate 0 0 0) (g/rotate-x (* 0 0.15)))
               ;; model-tx-inv (-> tx1 (g/invert) (g/transpose))
               ;; light-pos (vec3 (* 0.2 (Math/sin t)) 1 0)
               cone-angle (m/map-interval (Math/cos (* t 0.3)) -1 1 20 150)
               lr         (* (m/map-interval (Math/cos (* t 0.7)) -1 1 -0.85 0.85) m/PI)
               light-view (mat/look-at (g/rotate-y (vec3 0 2 2.4) lr) (vec3 0 0.6 0) (vec3 0 1 0))
               light-rot  (mat/matrix44->matrix33-rot light-view)]
  
           (shadow/draw-light-pass
            gl light-fbo
            #(buf/draw-arrays
              gl (assoc model
                   :shader  light-shader
                   :attribs (select-keys (:attribs model) [:position])
                   :uniforms {:model model-tx
                              :view  light-view
                              :proj  light-proj})))
           (gl/set-viewport gl view-rect)
           (gl/clear-color-buffer gl 0.08 0.1 0.12 1.0)
           (shadow/draw-cam-pass
            gl (:tex light-fbo)
            (fn [uniforms]
              (buf/draw-arrays
               gl (assoc model
                    :shader   cam-shader
                    :uniforms (assoc uniforms
                                :model     model-tx
                                :view      cam-view
                                :proj      cam-proj
                                :lightView light-view
                                :lightProj light-proj
                                :lightRot  light-rot
                                :coneAngle cone-angle)))))
  
           (set!
            (.-textContent fps)
            (str (.toFixed (js/Number. (/ 1 (- t @timer))) 2) "fps"))
           (reset! timer t)
           ;; keep animating...
           true)))
      {:ctx gl}))
  
  (demo)
#+END_SRC


** Complete namespace definition

#+BEGIN_SRC clojure :tangle ../babel/test/thi/ng/geom/webgl/example01.cljs :noweb yes :mkdirp yes :padline no
(ns thi.ng.geom.webgl.example01
  (:require
    [thi.ng.geom.webgl.core :as gl]
    [thi.ng.geom.webgl.arrays :as arrays]
    [thi.ng.geom.webgl.animator :as anim]
    [thi.ng.geom.webgl.buffers :as buf]
    [thi.ng.geom.webgl.shaders :as sh]
    [thi.ng.geom.webgl.shaders.phong :as phong]
    [thi.ng.geom.webgl.shaders.spotlight :as spotlight]
    [thi.ng.geom.webgl.shaders.shadow :as shadow]
    [thi.ng.geom.webgl.utils :as u]
    [thi.ng.geom.core :as g]
    [thi.ng.geom.core.vector :as v :refer [vec2 vec3]]
    [thi.ng.geom.core.matrix :as mat :refer [M44]]
    [thi.ng.geom.types]
    [thi.ng.geom.aabb :as a]
    [thi.ng.geom.sphere :as s]
    [thi.ng.geom.gmesh]
    [thi.ng.geom.mesh.csg :as csg]
    ;;[thi.ng.geom.mesh.subdivision :as sd]
    [thi.ng.morphogen.core :as mg]
    [thi.ng.common.math.core :as m]
    [thi.ng.common.error :as err])
  (:require-macros
    [thi.ng.macromath.core :as mm]))

  <<demo>>
#+END_SRC
