#+SEQ_TODO:       TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:           Write(w) Update(u) Fix(f) Check(c) noexport(n)
#+EXPORT_EXCLUDE_TAGS: noexport

* thi.ng.geom.line
** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx :mkdirp yes :padline no
  (ns thi.ng.geom.line
    (:refer-clojure :exclude [+ - * min max])
    (:refer-clojure :rename {+ c+, - c-, * c*, min cmin, max cmax})
    (:require
     [thi.ng.common.data.core :as d]
     [thi.ng.common.math.core :as m :refer [*eps*]]
     [thi.ng.geom.core :as g :refer [+ - * vec2 vec3 min max]]
     [thi.ng.geom.mesh :as mesh]
     [thi.ng.geom.types :as types])
    ,#+clj
    (:import
     [thi.ng.geom.types Circle Line2 Line3 LineStrip2]))
#+END_SRC
** Constructors
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  (defn line2
    ([[p q]] (thi.ng.geom.types.Line2. (vec2 p) (vec2 q)))
    ([p q] (thi.ng.geom.types.Line2. (vec2 p) (vec2 q)))
    ([px py qx qy] (thi.ng.geom.types.Line2. (vec2 px py) (vec2 qx qy))))

  (defn line3
    ([[p q]] (thi.ng.geom.types.Line3. (vec3 p) (vec3 q)))
    ([p q] (thi.ng.geom.types.Line3. (vec3 p) (vec3 q)))
    ([px py qx qy] (thi.ng.geom.types.Line3. (vec3 px py) (vec3 qx qy)))
    ([px py pz qx qy qz] (thi.ng.geom.types.Line3. (vec3 px py pz) (vec3 qx qy qz))))

  (defn linestrip2
    ([points] (thi.ng.geom.types.LineStrip2. (mapv vec2 points)))
    ([p & more] (thi.ng.geom.types.LineStrip2. (mapv vec2 (cons p more)))))
#+END_SRC
** Shared helper functions
    This function is going to be used for both 2D/3D implementations:
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  (defn closest-point-coeff*
    [p a b]
    (let [d (- b a)]
      (/ (g/dot (- p a) d) (g/mag-squared d))))
  
  (defn closest-point*
    [p a b]
    (let [t (closest-point-coeff* p a b)]
      (cond
        (<= t 0.0) a
        (> t 1.0) b
        :default (g/mix a b t))))
  
  (defn sample-with-res*
    [a b res include-b?]
    (let [ls (for [t (m/norm-range res)] (g/mix a b t))]
      (if include-b? (concat ls [b]) ls)))
#+END_SRC
** Line2
*** Protocol implementations
**** TODO verify point equiv if arg is clj vector, not vec2/3
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  (extend-type thi.ng.geom.types.Line2
#+END_SRC
**** PGraph
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PGraph
  (vertices
   ([this] [(:p this) (:q this)])
   ([this res] (sample-with-res* (:p this) (:q this) res true)))
  (edges
   ([this] [this])
   ([this res] (g/edges* line2 (g/vertices this res))))
  (vertex-neighbors
   [{p :p q :q} v] (condp = v p q q p nil))
  (vertex-valence
   [this v] (if (or (= v (:p this)) (= v (:q this))) 1 0))
#+END_SRC
**** PArea
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PArea
  (area [this] 0)
#+END_SRC
**** PBounds
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PBounds
  (bounds
   [this] (g/bounding-rect* [(:p this) (:q this)]))
  (width  [this] (m/abs (c- ((:p this) 0) ((:q this) 0))))
  (height [this] (m/abs (c- ((:p this) 1) ((:q this) 1))))
  (depth  [this] 0)
#+END_SRC
**** PCenter
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PCenter
  (center
   ([{p :p q :q}]
      (let [c (g/mix p q)] (thi.ng.geom.types.Line2. (- p c) (- q c))))
   ([{p :p q :q} o]
      (let [c (- o (g/mix p q))] (thi.ng.geom.types.Line2. (+ p c) (+ q c)))))
  (centroid [this] (g/mix (:p this) (:q this)))
#+END_SRC
**** PBoundingCircle
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PBoundingCircle
  (bounding-circle
   [{p :p q :q}] (thi.ng.geom.types.Circle. (g/mix p q) (c* 0.5 (g/dist p q))))
#+END_SRC
**** PCircumference
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PCircumference
  (circumference [this] (g/dist (:p this) (:q this)))
#+END_SRC
**** PBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PBoundary
  (classify-point
   [{p :p q :q} v]
   (m/signum (g/dot (- (vec2 v) p) (g/normal (- q p))) *eps*))
  (closest-point
   [this a] (closest-point* (vec2 a) (:p this) (:q this)))
  (contains-point?
   [this a] (m/delta= (closest-point* (vec2 a) (:p this) (:q this)) a *eps*))
#+END_SRC
**** PSampleable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PSampleable
  (point-at
   [this t] (g/mix (:p this) (:q this) t))
  (random-point
   [this] (g/mix (:p this) (:q this) (m/random)))
  (random-point-inside
   [this] (g/mix (:p this) (:q this) (m/random)))
  (sample-uniform
   [this dist include-last?]
   (g/sample-uniform* dist include-last? [(:p this) (:q this)]))
#+END_SRC
**** PMagnitude
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PMagnitude
  (mag [this] (g/mag (- (:q this) (:p this))))
  (mag-squared [this] (g/mag-squared (- (:q this) (:p this))))
#+END_SRC
**** PNormalize
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PNormalize
  (normalize
   ([{p :p :as this}]
      (let [d (g/normalize (- (:q this) p))]
        (thi.ng.geom.types.Line2. p (+ p d))))
   ([{p :p :as this} n]
      (let [d (g/normalize (- (:q this) p) n)]
        (thi.ng.geom.types.Line2. p (+ p d)))))
  (normalized? [this] (m/delta= 1.0 (g/mag-squared this)))
#+END_SRC
**** PReflect
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PReflect
  (reflect
   [this r]
   (if (instance? thi.ng.geom.types.Line2 r)
     (let [ra (g/normalize (- (:q r) (:p r)))
           rc (g/centroid r)
           p* (g/reflect (- (:p this) rc) ra)
           q* (g/reflect (- (:q this) rc) ra)]
       (thi.ng.geom.types.Line2. (+ p* rc) (+ q* rc)))
     (thi.ng.geom.types.Line2. (g/reflect (:p this) r) (g/reflect (:q this) r))))
#+END_SRC
**** PIntersectable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PIntersectable
  (intersect-line
   [{[px1 py1 :as p] :p [qx1 qy1 :as q] :q :as this}
    {[px2 py2 :as lp] :p [qx2 qy2 :as lq] :q}]
   (let [denom (c- (c* (c- qy2 py2) (c- qx1 px1)) (c* (c- qx2 px2) (c- qy1 py1)))
         na (c- (c* (c- qx2 px2) (c- py1 py2)) (c* (c- qy2 py2) (c- px1 px2)))
         nb (c- (c* (c- qx1 px1) (c- py1 py2)) (c* (c- qy1 py1) (c- px1 px2)))]
     (if-not (zero? denom)
       (let [ua (/ na denom) ub (/ nb denom) ipos (g/mix p q ua)]
         (if (and (>= ua 0.0) (<= ua 1.0) (>= ub 0.0) (<= ub 1.0))
           {:type :intersect :p ipos :ua ua :ub ub}
           {:type :intersect-outside :p ipos :ua ua :ub ub}))
       (if (and (zero? na) (zero? nb))
         (let [ip (g/closest-point this lp)
               iq (g/closest-point this lq)]
           (if (or (m/delta= ip lp) (m/delta= iq lq))
             {:type :coincident :p ip :q iq}
             {:type :coincident-no-intersect :p ip :q iq}))
         {:type :parallel}))))
#+END_SRC
**** End of implementations                                        :noexport:
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  )
#+END_SRC
** Line3
*** Protocol implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  (extend-type thi.ng.geom.types.Line3
#+END_SRC
**** PGraph
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PGraph
  (vertices
   ([this] [(:p this) (:q this)])
   ([this res] (sample-with-res* (:p this) (:q this) res true)))
  (edges
   ([this] [this])
   ([this res] (g/edges* line3 (g/vertices this res))))
  (vertex-neighbors
   [{p :p q :q} v] (condp = v p q q p nil))
  (vertex-valence
   [this v] (if (or (= v (:p this)) (= v (:q this))) 1 0))
#+END_SRC
**** PArea
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
g/PArea
(area [this] 0)
#+END_SRC
**** PBounds
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
g/PBounds
(bounds [this] (g/bounding-box* [(:p this) (:q this)]))
(width  [this] (m/abs (c- ((:p this) 0) ((:q this) 0))))
(height [this] (m/abs (c- ((:p this) 1) ((:q this) 1))))
(depth  [this] (m/abs (c- ((:p this) 2) ((:q this) 2))))
#+END_SRC
**** PCenter
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
g/PCenter
(center
 ([{p :p q :q}]
    (let [c (g/mix p q)] (thi.ng.geom.types.Line3. (- p c) (- q c))))
 ([{p :p q :q} o]
    (let [c (- o (g/mix p q))]
      (thi.ng.geom.types.Line3. (+ p c) (+ q c)))))
(centroid [this] (g/mix (:p this) (:q this)))
#+END_SRC
**** PBoundingSphere
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PBoundingSphere
  (bounding-sphere
   [{p :p q :q}]
   (g/bounding-sphere* (g/mix p q) (c* 0.5 (g/dist p q))))
#+END_SRC
**** PVolume
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PVolume
  (volume [this] 0.0)
#+END_SRC
**** PBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PBoundary
  (classify-point
   [{p :p q :q} p] nil) ; TODO
  (closest-point
   [this a] (closest-point* (vec3 a) (:p this) (:q this)))
  (contains-point?
   [this a] (m/delta= (closest-point* (vec3 a) (:p this) (:q this)) a *eps*))
#+END_SRC
**** PSampleable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PSampleable
  (point-at
   [this t] (g/mix (:p this) (:q this) t))
  (random-point
   [this] (g/mix (:p this) (:q this) (m/random)))
  (random-point-inside
   [this] (g/mix (:p this) (:q this) (m/random)))
#+END_SRC
**** PMagnitude
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PMagnitude
  (mag [this] (g/mag (- (:q this) (:p this))))
  (mag-squared [this] (g/mag-squared (- (:q this) (:p this))))
#+END_SRC
**** PNormalize
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PNormalize
  (normalize
   ([{p :p :as this}]
      (let [d (g/normalize (- (:q this) p))]
        (thi.ng.geom.types.Line3. p (+ p d))))
   ([{p :p :as this} n]
      (let [d (g/normalize (- (:q this) p) n)]
        (thi.ng.geom.types.Line3. p (+ p d)))))
  (normalized? [this] (m/delta= 1.0 (g/mag-squared this)))
#+END_SRC
**** PReflect
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PReflect
  (reflect [this r]
   (thi.ng.geom.types.Line3. (g/reflect (:p this) r) (g/reflect (:q this) r)))
#+END_SRC
**** TODO PIntersectable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx

#+END_SRC
**** End of implementations                                        :noexport:
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  )
#+END_SRC
** TODO LineStrip2
*** Protocol implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  (extend-type thi.ng.geom.types.LineStrip2
#+END_SRC
**** PGraph
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PGraph
  (vertices
   ([this] (:points this))
   ([{points :points} res]
      (map #(g/point-at* % points) (m/norm-range res))))
  (edges
   ([this] (g/edges* line2 (g/vertices this)))
   ([this res] (g/edges* line2 (g/vertices this res))))
  (vertex-neighbors
   [this v] (d/neighbors v (:points this)))
  (vertex-valence
   [this v] (if-let [p (d/neighbors v (:points this))]
              (let [points (:points this)]
                (if (or (= p (first points)) (= p (peek points)))
                  1 2))
              0))
#+END_SRC
**** PArea
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
g/PArea
(area [this] 0)
#+END_SRC
**** PBounds
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
g/PBounds
(bounds [this] (g/bounding-rect* (:points this)))
(width [this] (g/axis-range* 0 (:points this)))
(height [this] (g/axis-range* 1 (:points this)))
(depth [this] 0)
#+END_SRC
**** PCenter
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
g/PCenter
(center
 ([this] (g/translate this (g/invert (g/centroid this))))
 ([this o] (g/translate this (g/sub (vec2 o) (g/centroid this)))))
(centroid [this] (g/centroid* (:points this)))
#+END_SRC
**** PBoundingCircle
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
g/PBoundingCircle
(bounding-circle
 [this] (g/bounding-circle* (g/centroid this) (:points this)))
#+END_SRC
**** PCircumference
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
g/PCircumference
(circumference
 [{points :points}] (d/reduce-pairs c+ g/dist (concat points [(first points)])))
#+END_SRC
**** TODO PBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PBoundary
  (classify-point [this v])
  (closest-point [this a])
  (contains-point? [this a])
#+END_SRC
**** PSampleable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PSampleable
  (point-at
   [this t] (g/point-at* t (:points this) nil))
  (random-point
   [this] (g/point-at* (m/random) (:points this) nil))
  (random-point-inside
   [this] (g/point-at* (m/random) (:points this) nil))
  (sample-uniform
   [this udist include-last?]
   (g/sample-uniform* udist include-last? (:points this)))
#+END_SRC
**** PMagnitude
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PMagnitude
  (mag
   [this]
   (->> (:points this)
        (d/successive-nth 2)
        (map #(g/dist (% 0) (% 1)))
        (reduce c+)))
  (mag-squared [this]
   (->> (:points this)
        (d/successive-nth 2)
        (map #(g/dist-squared (% 0) (% 1)))
        (reduce c+)))
#+END_SRC
**** PReflect
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PReflect
  (reflect
   [this r]
   (thi.ng.geom.types.LineStrip2. (mapv #(g/reflect % r) (:points this))))
#+END_SRC
**** TODO PIntersectable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PIntersectable
  (intersect-line [this l])
#+END_SRC
**** TODO PTransformable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PTransformable
  (scale
   ([this s] (thi.ng.geom.types.LineStrip2. (mapv #(* % s) (:points this))))
   ([this sx sy] (thi.ng.geom.types.LineStrip2. (mapv #(* % sx sy) (:points this)))))
  (scale-size
   [this s]
   (let [c (g/centroid this)]
     (thi.ng.geom.types.LineStrip2.
      (mapv #(-> % (- c) (g/madd s c)) (:points this)))))
  (translate
   [this t] (thi.ng.geom.types.LineStrip2. (mapv #(+ % t) (:points this))))
#+END_SRC
**** TODO PExtrudeable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PExtrudeable
  (extrude
   [{points :points :as this}
    {:keys [depth scale] :or {depth 1.0 scale 1.0}}]
   (let [tpoints (if (= 1.0 scale) points (:points (g/scale-size this scale)))
         off (vec3 0 0 depth)
         bottom (map vec3 points)
         top (map #(+ off %) tpoints)]
     (apply mesh/mesh3
            (mapcat
             (fn [[a1 a2] [b1 b2]] [[b1 a1 a2] [b2 b1 a2]])
             (d/successive-nth 2 bottom)
             (d/successive-nth 2 top)))))
#+END_SRC
**** End of implementations                                        :noexport:
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  )
#+END_SRC
