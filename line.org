* thi.ng.geom.line
** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  (ns thi.ng.geom.line
    (:require
     [thi.ng.common.data.core :as d]
     [thi.ng.common.math.core :as m :refer [*eps*]]
     [thi.ng.geom.core :as g :refer [vec2 vec3]]
     [thi.ng.geom.mesh :as mesh]
     [thi.ng.geom.types :as types])
    #+clj
    (:import
     [thi.ng.geom.types Circle Line2 Line3 LineStrip2]))
#+END_SRC
** Constructors
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  (defn line2
    ([[p q]] (thi.ng.geom.types.Line2. (vec2 p) (vec2 q)))
    ([p q] (thi.ng.geom.types.Line2. (vec2 p) (vec2 q)))
    ([px py qx qy] (thi.ng.geom.types.Line2. (vec2 px py) (vec2 qx qy))))

  (defn line3
    ([[p q]] (thi.ng.geom.types.Line3. (vec3 p) (vec3 q)))
    ([p q] (thi.ng.geom.types.Line3. (vec3 p) (vec3 q)))
    ([px py qx qy] (thi.ng.geom.types.Line3. (vec3 px py) (vec3 qx qy)))
    ([px py pz qx qy qz] (thi.ng.geom.types.Line3. (vec3 px py pz) (vec3 qx qy qz))))

  (defn linestrip2
    ([points] (thi.ng.geom.types.LineStrip2. (vec (map vec2 points))))
    ([p & more] (thi.ng.geom.types.LineStrip2. (vec (map vec2 (cons p more))))))
#+END_SRC
** Shared helper functions
    This function is going to be used for both 2D/3D implementations:
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  (defn closest-point-coeff*
    [p a b]
    (let [d (g/sub b a)]
      (/ (g/dot (g/sub p a) d) (g/mag-squared d))))

  (defn closest-point*
    [p a b]
    (let [t (closest-point-coeff* p a b)]
      (cond
        (<= t 0.0) a
        (> t 1.0) b
        :default (g/mix a b t))))

  (defn sample-with-res*
    [a b res include-b?]
    (let [ls (for [t (m/norm-range res)] (g/mix a b t))]
      (if include-b? (concat ls [b]) ls)))
#+END_SRC
** Line2
*** Protocol implementations
**** TODO verify point equiv if arg is clj vector, not vec2/3
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  (extend-type thi.ng.geom.types.Line2
#+END_SRC
**** PGraph
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PGraph
  (vertices
   ([this] [(:p this) (:q this)])
   ([this res] (sample-with-res* (:p this) (:q this) res true)))
  (edges
   ([this] [this])
   ([this res] (g/edges* line2 (g/vertices this res))))
  (vertex-neighbors
   [{p :p q :q} v] (condp = v p q q p nil))
  (vertex-valence
   [this v] (if (or (= v (:p this)) (= v (:q this))) 1 0))
#+END_SRC
**** PShape
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PShape
  (area [this] 0)
  (bounds
   [this] (g/bounding-rect* [(:p this) (:q this)]))
  (center
   ([{p :p q :q}]
      (let [c (g/mix p q)] (thi.ng.geom.types.Line2. (g/sub p c) (g/sub q c))))
   ([{p :p q :q} o]
      (let [c (g/sub o (g/mix p q))] (thi.ng.geom.types.Line2. (g/add p c) (g/add q c)))))
  (centroid
   [this] (g/mix (:p this) (:q this)))
  (width  [this] (m/abs (- ((:p this) 0) ((:q this) 0))))
  (height [this] (m/abs (- ((:p this) 1) ((:q this) 1))))
  (depth  [this] 0)
#+END_SRC
**** PShape2
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PShape2
  (bounding-circle
   [{p :p q :q}]
   (thi.ng.geom.types.Circle. (g/mix p q) (* 0.5 (g/dist p q))))
  (circumference
   [this] (g/dist (:p this) (:q this)))
#+END_SRC
**** PBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PBoundary
  (classify-point
   [{p :p q :q} v]
   (m/signum (g/dot (g/sub (vec2 v) p) (g/normal (g/sub q p))) *eps*))
  (closest-point
   [this a] (closest-point* (vec2 a) (:p this) (:q this)))
  (contains-point?
   [this a] (m/delta= (closest-point* (vec2 a) (:p this) (:q this)) a *eps*))
#+END_SRC
**** PSampleable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PSampleable
  (point-at
   [this t] (g/mix (:p this) (:q this) t))
  (random-point
   [this] (g/mix (:p this) (:q this) (m/random)))
  (random-point-inside
   [this] (g/mix (:p this) (:q this) (m/random)))
  (sample-uniform
   [this dist include-last?]
   (g/sample-uniform* dist include-last? [(:p this) (:q this)]))
#+END_SRC
**** PIntersectable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PIntersectable
  (intersect-line
   [{[px1 py1 :as p] :p [qx1 qy1 :as q] :q :as this}
    {[px2 py2 :as lp] :p [qx2 qy2 :as lq] :q}]
   (let [denom (- (* (- qy2 py2) (- qx1 px1)) (* (- qx2 px2) (- qy1 py1)))
         na (- (* (- qx2 px2) (- py1 py2)) (* (- qy2 py2) (- px1 px2)))
         nb (- (* (- qx1 px1) (- py1 py2)) (* (- qy1 py1) (- px1 px2)))]
     (if-not (zero? denom)
       (let [ua (/ na denom) ub (/ nb denom) ipos (g/mix p q ua)]
         (if (and (>= ua 0.0) (<= ua 1.0) (>= ub 0.0) (<= ub 1.0))
           {:type :intersect :p ipos :ua ua :ub ub}
           {:type :intersect-outside :p ipos :ua ua :ub ub}))
       (if (and (zero? na) (zero? nb))
         (let [ip (g/closest-point this lp)
               iq (g/closest-point this lq)]
           (if (or (m/delta= ip lp) (m/delta= iq lq))
             {:type :coincident :p ip :q iq}
             {:type :coincident-no-intersect :p ip :q iq}))
         {:type :parallel}))))
#+END_SRC
**** End of implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  )
#+END_SRC
** Line3
*** Protocol implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  (extend-type thi.ng.geom.types.Line3
#+END_SRC
**** PGraph
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PGraph
  (vertices
   ([this] [(:p this) (:q this)])
   ([this res] (sample-with-res* (:p this) (:q this) res true)))
  (edges
   ([this] [this])
   ([this res] (g/edges* line3 (g/vertices this res))))
  (vertex-neighbors
   [{p :p q :q} v] (condp = v p q q p nil))
  (vertex-valence
   [this v] (if (or (= v (:p this)) (= v (:q this))) 1 0))
#+END_SRC
**** PShape
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PShape
  (area [this] 0)
  (bounds
   [this] (g/bounding-box* [(:p this) (:q this)]))
  (center
   ([{p :p q :q}]
      (let [c (g/mix p q)] (thi.ng.geom.types.Line3. (g/sub p c) (g/sub q c))))
   ([{p :p q :q} o]
      (let [c (g/sub o (g/mix p q))]
        (thi.ng.geom.types.Line3. (g/add p c) (g/add q c)))))
  (centroid
   [this] (g/mix (:p this) (:q this)))
  (width  [this] (m/abs (- ((:p this) 0) ((:q this) 0))))
  (height [this] (m/abs (- ((:p this) 1) ((:q this) 1))))
  (depth  [this] (m/abs (- ((:p this) 2) ((:q this) 2))))
#+END_SRC
**** PShape3
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PShape3
  (bounding-sphere
   [{p :p q :q}]
   (g/bounding-sphere* (g/mix p q) (* 0.5 (g/dist p q))))
  (volume [this] 0.0)
#+END_SRC
**** PBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PBoundary
  (classify-point
   [{p :p q :q} p] nil) ; TODO
  (closest-point
   [this a] (closest-point* (vec3 a) (:p this) (:q this)))
  (contains-point?
   [this a] (m/delta= (closest-point* (vec3 a) (:p this) (:q this)) a *eps*))
#+END_SRC
**** PSampleable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PSampleable
  (point-at
   [this t] (g/mix (:p this) (:q this) t))
  (random-point
   [this] (g/mix (:p this) (:q this) (m/random)))
  (random-point-inside
   [this] (g/mix (:p this) (:q this) (m/random)))
#+END_SRC
**** TODO PIntersectable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx

#+END_SRC
**** End of implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  )
#+END_SRC
** TODO LineStrip2
*** Protocol implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  (extend-type thi.ng.geom.types.LineStrip2
#+END_SRC
**** PGraph
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PGraph
  (vertices
   ([this] (:points this))
   ([{points :points} res]
      (map #(g/point-at* % points) (m/norm-range res))))
  (edges
   ([this] (g/edges* line2 (g/vertices this)))
   ([this res] (g/edges* line2 (g/vertices this res))))
  (vertex-neighbors
   [this v] (d/neighbors v (:points this)))
  (vertex-valence
   [this v] (if-let [p (d/neighbors v (:points this))]
              (let [points (:points this)]
                (if (or (= p (first points)) (= p (peek points)))
                  1 2))
              0))
#+END_SRC
**** PShape
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PShape
  (area [this] 0)
  (bounds
   [this] (g/bounding-rect* (:points this)))
  (center
   ([this]
      (g/translate this (g/invert (g/centroid this))))
   ([this o]
      (g/translate this (g/sub (vec2 o) (g/centroid this)))))
  (centroid
   [this] (g/centroid* (:points this)))
  (width
   [this] (g/axis-range* 0 (:points this)))
  (height
   [this] (g/axis-range* 1 (:points this)))
  (depth [this] 0)
#+END_SRC
**** PShape2
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PShape2
  (bounding-circle
   [this]
   (g/bounding-circle* (g/centroid this) (:points this)))
  (circumference
   [{points :points}]
   (d/reduce-pairs + g/dist (concat points [(first points)])))
#+END_SRC
**** PBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PBoundary
  (classify-point [this v])
  (closest-point [this a])
  (contains-point? [this a])
#+END_SRC
**** PSampleable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PSampleable
  (point-at
   [this t] (g/point-at* t (:points this) nil))
  (random-point
   [this] (g/point-at* (m/random) (:points this) nil))
  (random-point-inside
   [this] (g/point-at* (m/random) (:points this) nil))
  (sample-uniform
   [this udist include-last?]
   (g/sample-uniform* udist include-last? (:points this)))
#+END_SRC
**** TODO PIntersectable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PIntersectable
  (intersect-line [this l])
#+END_SRC
**** TODO PTransformable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PTransformable
  (scale
   ([this s]
      (thi.ng.geom.types.LineStrip2. (vec (map #(g/scale % s) (:points this)))))
   ([this sx sy]
      (thi.ng.geom.types.LineStrip2. (vec (map #(g/scale % sx sy) (:points this))))))
  (scale-size
   [this s]
   (let [c (g/centroid this)]
     (thi.ng.geom.types.LineStrip2.
      (vec (map #(-> % (g/sub c) (g/madd s c)) (:points this))))))
  (translate
   [this t]
   (thi.ng.geom.types.LineStrip2. (vec (map #(g/add % t) (:points this)))))
#+END_SRC
**** TODO PExtrudeable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  g/PExtrudeable
  (extrude
   [{points :points :as this}
    {:keys [depth scale] :or {depth 1.0 scale 1.0}}]
   (let [tpoints (if (= 1.0 scale) points (:points (g/scale-size this scale)))
         off (vec3 0 0 depth)
         bottom (map vec3 points)
         top (map #(g/add off %) tpoints)]
     (apply mesh/mesh3
            (mapcat
             (fn [[a1 a2] [b1 b2]] [[b1 a1 a2] [b2 b1 a2]])
             (d/successive-nth 2 bottom)
             (d/successive-nth 2 top)))))
#+END_SRC
**** End of implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/line.cljx
  )
#+END_SRC
