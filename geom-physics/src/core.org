#+SETUPFILE: ../../src/setup.org

* Contents                                                         :toc_3_gh:
 - [[#namespace-thinggeomphysicscore][Namespace: thi.ng.geom.physics.core]]
     - [[#protocols][Protocols]]
     - [[#type-implementations][Type implementations]]
     - [[#constructors][Constructors]]
     - [[#complete-namespace-definition][Complete namespace definition]]

* Namespace: thi.ng.geom.physics.core

** Protocols

#+BEGIN_SRC clojure :noweb-ref protos
  (defprotocol PTimeStep
    (timestep [_] [_ delta]))

  (defprotocol PBehavioral
    (add-behavior [_ id b])
    (remove-behavior [_ id])
    (clear-behaviors [_])
    (apply-behaviors [_ delta]))

  (defprotocol PConstrained
    (add-constraint [_ id c])
    (remove-constraint [_ id])
    (clear-constraints [_])
    (apply-constraints [_ delta]))

  (defprotocol PParticle
    (add-force [_ f])
    (add-velocity [_ v])
    (apply-force [_ delta])
    (clear-force [_])
    (clear-velocity [_])
    (scale-velocity [_ s])
    (position [_])
    (set-position [_ p])
    (velocity [_])
    (lock [_])
    (unlock [_])
    (locked? [_]))

  (defprotocol PPhysics
    (update-particles [_])
    (update-springs [_]))
#+END_SRC

** Type implementations

#+BEGIN_SRC clojure :noweb-ref impl
  (defn apply-to-particle
    [p delta fns]
    (when-not (locked? p)
      (loop [f (seq fns)] (when f ((first f) p delta) (recur (next f))))))

  (defn apply-to-particles
    [src delta fns]
    (loop [coll (seq src)]
      (when coll
        (apply-to-particle (first coll) delta fns)
        (recur (next coll)))))

  (deftype VerletParticle
      ,#+clj
    [^:unsynchronized-mutable pos
     ^:unsynchronized-mutable prev
     ^:unsynchronized-mutable force
     ^:unsynchronized-mutable locked?
     ^:unsynchronized-mutable behaviors
     ^:unsynchronized-mutable constraints
     ^double weight
     ^double inv-weight]
    ,#+cljs
    [^:mutable pos
     ^:mutable prev
     ^:mutable force
     ^:mutable locked?
     ^:mutable behaviors
     ^:mutable constraints
     weight
     inv-weight]
    PBehavioral
    (add-behavior
      [_ id b] (set! behaviors (assoc behaviors id b)) _)
    (apply-behaviors
      [_ delta] (when (seq behaviors) (apply-to-particle _ delta (vals behaviors))) _)
    (remove-behavior
      [_ id] (set! behaviors (dissoc behaviors id)) _)
    PConstrained
    (add-constraint
      [_ id c] (set! constraints (assoc constraints id c)) _)
    (apply-constraints
      [_ delta] (when (seq constraints) (apply-to-particle _ delta (vals constraints))) _)
    (remove-constraint
      [_ id] (set! constraints (dissoc constraints id)) _)
    PParticle
    (lock
      [_] (set! locked? true) _)
    (unlock
      [_] (set! locked? false) _)
    (locked?
      [_] locked?)
    (position
      [_] pos)
    (set-position
      [_ p] (set! pos p) _)
    (velocity
      [_] (g/- pos prev))
    (add-force
      [_ f] (set! force (g/+ force f)) _)
    (clear-force
      [_] (set! force (g/clear* force)))
    (apply-force
      [_ delta]
      (let [pos' (g/madd force (* inv-weight (* delta delta)) (g/msub pos 2.0 prev))]
        ;;(prn :apply-force (g/* force (* delta delta)) :pos pos :-> pos')
        (set! prev pos)
        (set! pos pos')
        (set! force (g/clear* force)))
      _)
    (scale-velocity
      [_ s] (set! prev (g/mix prev pos s)) _)
    PTimeStep
    (timestep
      [_ delta]
      (if-not locked?
        (-> (apply-behaviors _ delta)
            (apply-force delta)
            (apply-constraints delta))
        _))
    Object
    (toString
      [_]
      (pr-str
       {:pos pos
        :prev prev
        :force force
        :locked? locked?
        :weight weight
        :behaviors behaviors
        :constraints constraints})))

  (defrecord VerletPhysics
      [particles springs behaviors constraints delta iter drag]
    PBehavioral
    (add-behavior
      [_ id b] (assoc-in _ [:behaviors id] (b delta)))
    (apply-behaviors
      [_ delta] (apply-to-particles particles delta (vals behaviors)) _)
    (remove-behavior
      [_ id] (update-in [:behaviors] dissoc id))
    PConstrained
    (add-constraint
      [_ id c] (assoc-in _ [:constraints id] (c delta)))
    (apply-constraints
      [_ delta] (apply-to-particles particles delta (vals constraints)) _)
    (remove-constraint
      [_ id] (update-in [:constraints] dissoc id))
    PPhysics
    (update-particles
      [_]
      (loop [ps (seq particles)]
        (when ps
          (-> ps first (scale-velocity drag) (timestep delta))
          (recur (next ps))))
      _)
    (update-springs
      [_] (loop [s (seq springs)] (when s (timestep (first s) delta) (recur (next s)))) _)
    PTimeStep
    (timestep
      [_]
      (loop [i iter]
        (when (pos? i)
          ;;(prn :iter (- iter i))
          (-> (apply-behaviors _ delta)
              (update-particles)
              (update-springs)
              (apply-constraints delta))
          (recur (dec i))))
      _))

  (defrecord VerletSpring
      [^VerletParticle a
       ^VerletParticle b
       ^double rlen
       ^double strength
       a-locked? b-locked?]
    PTimeStep
    (timestep
      [_ delta]
      (let [aw   (.-inv-weight a)
            bw   (.-inv-weight b)
            pa   (position a)
            pb   (position b)
            diff (g/- pb pa)
            dist (+ (g/mag diff) 1e-6)
            nd   (* (/ (- dist rlen) (* dist (+ aw bw))) (* strength delta))]
        (when-not (or a-locked? (locked? a))
          (set-position a (g/madd diff (* nd aw) pa)))
        (when-not (or  b-locked? (locked? b))
          (set-position b (g/madd diff (* (- nd) bw) pb))))))

  (defn gravity
    [force]
    (fn [p delta]
      ;;(prn :grav p delta force)
      (add-force p (g/* force delta))))

  (defn attract
    [pos r strength]
    (let [r2 (* r r)]
      (fn [p delta]
        (let [d (g/- pos (position p))
              l (g/mag-squared d)]
          ;;(prn :att p l)
          (if (< l r2)
            (let [f (g/* d (/ (* (- 1.0 (/ l r2)) (* strength delta))
                              (Math/sqrt l)))]
              ;;(prn :att l (position p) f)
              (add-force p f)))))))
#+END_SRC

** Constructors

#+BEGIN_SRC clojure :noweb-ref ctors
  (defn particle
    ([pos]
       (particle pos 1.0 false))
    ([pos weight]
       (particle pos weight false))
    ([pos weight lock?]
       (VerletParticle. pos pos (g/clear* pos) lock? nil nil weight (/ 1.0 weight))))

  (defn physics
    [{:keys [particles springs behaviors constraints iter drag]
      :or   {particles #{}, springs #{}, behaviors {} constraints {}
             iter 2, drag 0.0}}]
    (let [delta (/ 1.0 iter)]
      (map->VerletPhysics
       {:particles   (set particles)
        :springs     (set springs)
        :behaviors   behaviors
        :constraints constraints
        :iter        iter
        :delta       delta
        :drag        (* drag delta)})))
#+END_SRC

** Complete namespace definition                                   :noexport:

#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/physics/core.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.physics.core
    ,#+cljs (:require-macros [thi.ng.macromath.core :as mm])
    (:require
     [thi.ng.geom.core :as g]
     [thi.ng.geom.core.vector :as v :refer [vec2 vec3]]
     [thi.ng.common.data.core :as d]
     ,#+clj [thi.ng.macromath.core :as mm]))

  <<protos>>

  <<impl>>

  <<ctors>>
#+END_SRC

#+BEGIN_SRC clojure
  (require '[thi.ng.geom.physics.core :as ph] :reload)
  (def a (ph/particle (v/vec2) 1 true))
  (def b (ph/particle (v/vec2 1 0) 1))
  (def s (ph/map->VerletSpring {:a a :b b :rlen 10.0 :strength 0.1}))
  (def p (ph/physics {:particles [a b] :springs [s] :iter 2 :drag 0.0
                      :behaviors {:g (ph/gravity (v/vec2 0 -0.5))
                                  :a (ph/attract (v/vec2 10 0) 10 -2)}}))
  (dotimes [i 100] (ph/timestep p) (let [pa (ph/position a) pb (ph/position b)] (prn i pb (g/dist pa pb))))

#+END_SRC
