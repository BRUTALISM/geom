#+SETUPFILE: ../../src/setup.org

* Contents                                                         :toc_3_gh:
 - [[#namespace-thinggeomphysicscore][Namespace: thi.ng.geom.physics.core]]
     - [[#protocols][Protocols]]
     - [[#type-implementations][Type implementations]]
     - [[#constructors][Constructors]]
     - [[#complete-namespace-definition][Complete namespace definition]]

* Namespace: thi.ng.geom.physics.core

** Protocols

#+BEGIN_SRC clojure :noweb-ref protos
(defprotocol PUpdate
  (update [_]))

(defprotocol PBehavioral
  (add-behavior [_ b])
  (remove-behavior [_ b])
  (clear-behaviors [_])
  (apply-behaviors [_]))

(defprotocol PConstrained
  (add-constraint [_ c])
  (remove-constraint [_ c])
  (clear-constraints [_])
  (apply-constraints [_]))

(defprotocol PParticle
  (add-force [_ f])
  (add-velocity [_ v])
  (apply-force [_])
  (clear-force [_])
  (clear-velocity [_])
  (scale-velocity [_ v])
  (position [_])
  (set-position [_ p])
  (velocity [_])
  (lock [_])
  (unlock [_])
  (locked? [_]))

(defprotocol PPhysics
  (update-particles [_])
  (update-springs [_]))
#+END_SRC

** Type implementations

#+BEGIN_SRC clojure :noweb-ref impl
  (defn apply-fns!
    [fns src]
    (loop [fns fns, coll src]
      (if fns
        (if coll
          (do ((first fns) (first coll))
              (recur fns (next coll)))
          (recur (next fns) src)))))

  (deftype VerletParticle
      [^:unsynchronized-mutable pos
       ^:unsynchronized-mutable prev
       ^:unsynchronized-mutable force
       ^:unsynchronized-mutable locked?
       ^:unsynchronized-mutable behaviors
       ^:unsynchronized-mutable constraints
       ^double weight
       ^double inv-weight]
    PBehavioral
    (add-behavior
      [_ b] (set! behaviors (conj (or behaviors []) b)) _)
    (apply-behaviors
      [_] (loop [b behaviors] (when b ((first b) _) (recur (next b)))) _)
    (remove-behavior
      [_ b] ;; TODO
      )
    PConstrained
    (add-constraint
      [_ c] (set! constraints (conj (or constraints []) c)) _)
    (apply-constraints
      [_] (loop [c constraints] (when c ((first c) _) (recur (next c)))) _)
    (remove-constraint
      [_ c] ;; TODO
      )
    PParticle
    (lock
      [_] (set! locked? true) _)
    (unlock
      [_] (set! locked? false) _)
    (locked?
      [_] locked?)
    (position
      [_] pos)
    (set-position
      [_ p] (set! pos p) _)
    (velocity
      [_] (g/- pos prev))
    (add-force
      [_ f] (set! force (g/+ force f)) _)
    (apply-force
      [_]
      (let [p' pos]
        (set! pos (-> force
                      (g/madd weight (g/- pos prev))
                      (g/+ pos)))
        (set! prev p')
        (set! force (g/clear* force))
        _))
    (scale-velocity
      [_ s] (set! prev (g/mix pos prev s)) _)
    PUpdate
    (update
      [_] (if locked? _ (-> _ apply-behaviors apply-force apply-constraints)))
    Object
    (toString
      [_]
      (pr-str
       {:pos pos
        :prev prev
        :force force
        :locked? locked?
        :weight weight
        :behaviors behaviors
        :constraints constraints})))

  (defrecord VerletPhysics
      [particles springs behaviors constraints timestep iter drag]
    PBehavioral
    (add-behavior
      [_ b] (update-in _ [:behaviors] conj b))
    (apply-behaviors
      [_] (apply-fns! behaviors particles) _)
    PConstrained
    (add-constraint
      [_ c] (update-in _ [:constraints] conj c))
    (apply-constraints
      [_] (apply-fns! constraints particles) _)
    PPhysics
    (update-particles
      [_]
      (loop [ps particles]
        (when ps
          (-> ps first (scale-velocity drag) update)
          (recur (next ps))))
      _)
    (update-springs
      [_]
      (loop [i iter, s springs]
        (if (pos? i)
          (if s
            (do (update (first s)) (recur i (next s)))
            (recur (dec i) springs))))
      _)
    PUpdate
    (update
      [_]
      (-> _
          apply-behaviors
          update-particles
          update-springs
          apply-constraints)))

  (defrecord VerletSpring
      [^VerletParticle a
       ^VerletParticle b
       ^double rlen
       ^double strength
       a-locked? b-locked?]
    PUpdate
    (update
      [_]
      (let [aw    (.-inv-weight a)
            bw    (.-inv-weight b)
            pa    (position a)
            pb    (position b)
            delta (g/- pb pa)
            dist  (+ (g/mag delta) 1e-6)
            nd    (* (/ (- dist rlen) (* dist (+ aw bw))) strength)]
        (when-not (or a-locked? (locked? a))
          (set-position a (g/madd delta (* nd aw) pa)))
        (when-not (or  b-locked? (locked? b))
          (set-position b (g/madd delta (* (- nd) bw) pb))))))

  (defn gravity
    [force timestep]
    (let [f-scaled (g/* force (* timestep timestep))]
      #(add-force % f-scaled)))
#+END_SRC

** Constructors

#+BEGIN_SRC clojure :noweb-ref ctors
  (defn particle
    [p w] (VerletParticle. p p (g/clear* p) false nil nil w (/ 1.0 w)))
#+END_SRC

** Complete namespace definition                                   :noexport:

#+BEGIN_SRC clojure :tangle ../babel/src/cljx/thi/ng/geom/physics/core.cljx :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.physics.core
    ,#+cljs (:require-macros [thi.ng.macromath.core :as mm])
    (:require
     [thi.ng.geom.core :as g]
     [thi.ng.geom.core.vector :as v :refer [vec2 vec3]]
     [thi.ng.common.data.core :as d]
     ,#+clj [thi.ng.macromath.core :as mm]))

  <<protos>>

  <<impl>>

  <<ctors>>
#+END_SRC
