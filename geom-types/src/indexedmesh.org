#+SETUPFILE: ../../src/setup.org

* Contents                                                         :toc_4_gh:
 - [[#thinggeomindexmesh][thi.ng.geom.indexmesh]]
     - [[#helpers][Helpers]]
         - [[#indexing][Indexing]]
         - [[#constructors][Constructors]]
         - [[#attributes][Attributes]]
     - [[#protocol-implementations][Protocol implementations]]
         - [[#parea][PArea]]
         - [[#pbounds][PBounds]]
         - [[#pboundingsphere][PBoundingSphere]]
         - [[#pcenter][PCenter]]
         - [[#pflip][PFlip]]
         - [[#pgeomcontainer][PGeomContainer]]
         - [[#pvertexaccess-pedgeaccess--pfaceaccess][PVertexAccess, PEdgeAccess & PFaceAccess]]
         - [[#ptransform][PTransform]]
         - [[#pvolume][PVolume]]
         - [[#end-of-implementation][End of implementation]]
     - [[#complete-namespace-definition][Complete namespace definition]]

* thi.ng.geom.indexmesh

** Helpers
*** Indexing

#+BEGIN_SRC clojure :noweb-ref index
  (defn index-item
    [index item]
    (let [id (get (:index index) item)]
      (if-not id
        (let [id (:next index)]
          [{:index (assoc (:index index) item id)
            :items (conj (:items index) item)
            :next  (inc id)}
           id])
        [index id])))

  (defn make-index
    ([] {:index {} :items [] :next 0})
    ([items] (reduce #(first (index-item %1 %2)) (make-index) items))
    ([index items] {:index index :items items :next (count items)}))


  (defn unindex-item
    [index item]
    (let [id (get (:index index) item)]
      (if id
        {:index (dissoc (:index index) item)
         :items (into (subvec (:items index) 0 id) (subvec (:items index) (inc id)))
         :next  (:next index)}
        index)))

  (defn reindex-item
    [index item newitem]
    (let [id (get (:index index) item)]
      (if id
        {:index (assoc (dissoc (:index index) item) newitem id)
         :items (into (conj (subvec (:items index) 0 id) newitem) (subvec (:items index) (inc id)))
         :next  (:next index)}
        index)))

  (defn index-items
    [index verts]
    (reduce
     (fn [[idx ids] v]
       (let [[idx id] (index-item idx v)]
         [idx (conj ids id)]))
     [index []] verts))

  (defn index-attribs
    [aindex attribs]
    (reduce
     (fn [[attr aids] [id v]]
       (let [[idx ids] (index-items (or (get attr id) (make-index)) v)]
         [(assoc attr id idx) (assoc aids id ids)]))
     [aindex {}] attribs))

  (defn attrib-values
    [{:keys [items]} ids] (mapv items ids))
#+END_SRC

*** Constructors

#+BEGIN_SRC clojure :noweb-ref ctors
  (defn indexed-mesh
    [] (thi.ng.geom.types.IndexedMesh. (make-index) [] {}))
#+END_SRC

*** Attributes

#+BEGIN_SRC clojure :noweb-ref impl
  (defn- add-face*
    [mesh [verts attribs]]
    #_(prn :add-face verts :attr attribs)
    (let [[vindex vids] (index-items (:vertices mesh) verts)
          [aindex aids] (index-attribs (:attribs mesh) attribs)]
      (thi.ng.geom.types.IndexedMesh.
       vindex
       (conj (:faces mesh) (thi.ng.geom.meshface.IndexedMeshFace. vids aids))
       aindex)))

  (defn- flip-face
    [[verts attribs]]
    [(vec (rseq verts))
     (reduce-kv (fn [acc k v] (assoc acc k (vec (rseq v)))) attribs attribs)])
#+END_SRC

** Protocol implementations

#+BEGIN_SRC clojure :noweb-ref impl
  (extend-type thi.ng.geom.types.IndexedMesh
#+END_SRC

*** PArea
#+BEGIN_SRC clojure :noweb-ref impl
  g/PArea
  (area
   [_] (gu/total-area-3d (mf/xf-face-verts _) (:faces _)))
#+END_SRC

*** PBounds

#+BEGIN_SRC clojure :noweb-ref impl
  g/PBounds
  (bounds [_] (tu/bounding-box (g/vertices _)))
  (width [_] (gu/axis-range 0 (g/vertices _)))
  (height [_] (gu/axis-range 1 (g/vertices _)))
  (depth [_] (gu/axis-range 2 (g/vertices _)))
#+END_SRC

*** PBoundingSphere

#+BEGIN_SRC clojure :noweb-ref impl
  g/PBoundingSphere
  (bounding-sphere
   [_] (tu/bounding-sphere (g/centroid _) (g/vertices _)))
#+END_SRC

*** PCenter

#+BEGIN_SRC clojure :noweb-ref impl
  g/PCenter
  (center
   ([_] (g/center _ (vec3)))
   ([_ o] (g/transform _ (g/translate M44 (g/- o (g/centroid _))))))
  (centroid
   [_] (gu/centroid (g/vertices _)))
#+END_SRC

*** PFlip

#+BEGIN_SRC clojure :noweb-ref impl
  g/PFlip
  (flip
   [_]
   (thi.ng.geom.types.IndexedMesh.
    (:vertices _)
    (mapv flip-face (:faces _))
    (dissoc (:attribs _) :fnormals :vnormals)))
#+END_SRC

*** PGeomContainer

#+BEGIN_SRC clojure :noweb-ref impl
  g/PGeomContainer
  (into
   [_ faces] (tu/into-mesh _ add-face* faces))
  g/PClear
  (clear*
   [_] (indexed-mesh))
#+END_SRC

*** PVertexAccess, PEdgeAccess & PFaceAccess

#+BEGIN_SRC clojure :noweb-ref impl
  g/PVertexAccess
  (vertices
   [_] (-> _ :vertices :items))
  g/PEdgeAccess
  (edges
   [_] (err/unsupported!))
  g/PFaceAccess
  (faces
   ([_] (g/faces _ true))
   ([_ __] (map #(g/raw % _) (:faces _)))) ;; TODO also allow for indexed face repr
  (add-face
   [_ f] (add-face* _ f))
  #_(vertex-faces
   [_ v] (vertex-faces* _ v))
  #_(remove-face
   [{:keys [vertices edges faces fnormals vnormals] :as _} f]
   (if (get faces f)
     (loop [verts vertices
            vnorms vnormals
            edges edges
            fedges (d/successive-nth 2 (conj f (first f)))]
       (if fedges
         (let [[a b] (first fedges)
               e #{a b}
               efaces (disj (get edges e) f)
               edges (if (seq efaces)
                       (assoc edges e efaces)
                       (dissoc edges e))
               ve (filter #(not= (:f %) f) (get verts a))]
           (if (seq ve)
             (recur (assoc verts a (into #{} ve)) vnorms edges (next fedges))
             (recur (dissoc verts a) (dissoc vnorms a) edges (next fedges))))
         (assoc _
           :vertices verts
           :vnormals vnorms
           :edges edges
           :faces (disj faces f)
           :fnormals (dissoc fnormals f))))
     _))
#+END_SRC

*** PTransform

#+BEGIN_SRC clojure :noweb-ref impl
  g/PScale
  (scale
   ([_ s]
      (tu/transform-mesh _ add-face* #(g/* % s)))
   ([_ sx sy sz]
      (tu/transform-mesh _ add-face* #(g/* % sx sy sz))))
  (scale-size
   [_ s]
   (let [c (g/centroid _)]
     (tu/transform-mesh _ add-face* #(g/madd (g/- % c) s c))))
  g/PTranslate
  (translate
   [_ t] (tu/transform-mesh _ add-face* #(g/+ % t)))
  g/PTransform
  (transform
   [_ tx]
   (tu/transform-mesh _ add-face* tx))
#+END_SRC

*** PVolume

#+BEGIN_SRC clojure :noweb-ref impl
  g/PVolume
  (volume
   [_] (gu/total-volume (mf/xf-face-verts _) (:faces _)))
#+END_SRC

*** End of implementation                                          :noexport:

#+BEGIN_SRC clojure :noweb-ref impl
  )
#+END_SRC

** Complete namespace definition

#+BEGIN_SRC clojure :tangle ../babel/src/thi/ng/geom/indexmesh.cljc :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.indexmesh
    (:require
     [thi.ng.geom.core :as g]
     [thi.ng.geom.core.utils :as gu]
     [thi.ng.geom.core.vector :as v :refer [vec2 vec3]]
     [thi.ng.geom.core.matrix :refer [M44]]
     [thi.ng.geom.meshface :as mf]
     [thi.ng.geom.types]
     [thi.ng.geom.types.utils :as tu]
     [thi.ng.dstruct.core :as d]
     [thi.ng.math.core :as m :refer [*eps*]]
     [thi.ng.xerror.core :as err]
     [clojure.core.reducers :as r]
     [clojure.set :as set]))

  <<index>>

  <<ctors>>

  <<impl>>
#+END_SRC
