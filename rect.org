#+SEQ_TODO:       TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:           Write(w) Update(u) Fix(f) Check(c) noexport(n)
#+EXPORT_EXCLUDE_TAGS: noexport

* thi.ng.geom.rect
** Namespace declaration
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx :mkdirp yes :padline no
  (ns thi.ng.geom.rect
    (:refer-clojure :exclude [+ - * min max])
    (:refer-clojure :rename {+ c+, - c-, * c*, min cmin, max cmax})
    (:require
     [thi.ng.common.data.core :as d]
     [thi.ng.common.math.core :as m :refer [*eps*]]
     [thi.ng.geom.core :as g :refer [+ - * vec2 vec3 min max]]
     [thi.ng.geom.aabb :as aabb]
     [thi.ng.geom.mesh :as mesh]
     [thi.ng.geom.types :as types])
    ,#+clj
    (:import
     [thi.ng.geom.types Circle Line2 Polygon Rect]))
#+END_SRC
** Constructor
*** TODO replace sequential? w/ coll?
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  (defn rect
    ([] (thi.ng.geom.types.Rect. (vec2) 1.0 1.0))
    ([w] (thi.ng.geom.types.Rect. (vec2) w w))
    ([p q]
       (if (sequential? p)
         (if (sequential? q)
           (let [p (vec2 p) q (vec2 q)
                 [p q] [(min p q) (max p q)]
                 [w h] (- q p)]
             (thi.ng.geom.types.Rect. p w h))
           (thi.ng.geom.types.Rect. (vec2 p) q q))
         (thi.ng.geom.types.Rect. (vec2) p q)))
    ([x y w]
       (if (number? x)
         (thi.ng.geom.types.Rect. (vec2 x y) w w)
         (thi.ng.geom.types.Rect. (vec2 x) y w)))
    ([x y w h] (thi.ng.geom.types.Rect. (vec2 x y) w h)))
#+END_SRC
** Type specific functions
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  (defn union
    [{:keys[p w h]} {q :p qw :w qh :h}]
    (let [[x1 y1 :as p*] (min p q)
          x2 (cmax (c+ (p 0) w) (c+ (q 0) qw))
          y2 (cmax (c+ (p 1) h) (c+ (q 1) qh))
          w (c- x2 x1)
          h (c- y2 y1)]
      (thi.ng.geom.types.Rect. p* w h)))
  
  ;; FIXME shouldn't it return vec2?
  (defn map-uv
    [{:keys[p w h]} [qx qy]]
    [(/ (c- qx (p 0)) w) (/ (c- qy (p 1)) h)])
  
  (defn unmap-uv
    [{:keys[p w h]} [qx qy]]
    [(m/madd qx w (p 0)) (m/madd qy h (p 1))])
  
  (defn left [r] ((:p r) 0))
  (defn right [r] (c+ ((:p r) 0) (:w r)))
  (defn top [r] ((:p r) 1))
  (defn top-left [r] (:p r))
  (defn bottom [r] (c+ ((:p r) 1) (:h r)))
  (defn bottom-right [r] (+ (:p r) [(:w r) (:h r)]))
  
  (defn intersect-rect?
    [{[px py] :p w :w h :h} {[qx qy] :p w2 :w h2 :h}]
    (not (or (> px (c+ qx w2)) (> qx (c+ px w)) (> py (c+ qy h2)) (> qy (c+ py h)))))
  
  (defn intersect-circle?
    [{w :w h :h :as r} {c :p radius :r}]
    (let [p (g/centroid r)
          [dx dy :as d] (g/abs (- c p))
          w (c* w 0.5) h (c* h 0.5)]
      (if (and (<= dx (c+ w radius))
               (<= dy (c+ h radius)))
        (if (or (<= dx w) (<= dy h))
          true
          (<= (g/mag-squared (- d [w h])) (c* radius radius)))
        false)))
#+END_SRC
** Protocol implementations
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  (extend-type thi.ng.geom.types.Rect
#+END_SRC
*** PGraph
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  g/PGraph
  (vertices
   [{[x y :as p] :p w :w h :h}]
   (let [r (c+ x w) b (c+ y h)] [p (vec2 r y) (vec2 r b) (vec2 x b)]))
  (edges
   [{[x y :as p] :p w :w h :h}]
   (let [r (c+ x w) b (c+ y h)]
     [(thi.ng.geom.types.Line2. p (vec2 r y))
      (thi.ng.geom.types.Line2. (vec2 r y) (vec2 r b))
      (thi.ng.geom.types.Line2. (vec2 r b) (vec2 x b))
      (thi.ng.geom.types.Line2. (vec2 x b) p)]))
  (vertex-neighbors
   [_ v] (d/neighbors (vec2 v) (g/vertices _)))
  (vertex-valence
   [_ v] (if ((set (g/vertices _)) (vec2 v)) 2 0))
#+END_SRC
*** PArea
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  g/PArea
  (area [_] (c* (:w _) (:h _)))
#+END_SRC
*** PBounds
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  g/PBounds
  (bounds[_] _)
  (width  [_] (:w _))
  (height [_] (:h _))
  (depth  [_] 0)
#+END_SRC
*** PCenter
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  g/PCenter
  (center
   ([{w :w h :h}]
      (let [w2 (c* w 0.5) h2 (c* h 0.5)]
        (thi.ng.geom.types.Rect. (vec2 (- w2) (- h2)) w h)))
   ([{w :w h :h} o]
      (let [t [(c* w 0.5) (c* h 0.5)]]
        (thi.ng.geom.types.Rect. (- o t) w h))))
  (centroid [{p :p :as _}] (g/mix p (+ p (:w _) (:h _))))
#+END_SRC
*** PBoundingCircle
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  g/PBoundingCircle
  (bounding-circle
   [_]
   (let [c (g/centroid _)]
     (g/bounding-circle* c (g/dist c (:p _)))))
#+END_SRC
*** PCircumference
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  g/PCircumference
  (circumference [_] (c* 2.0 (c+ (:w _) (:h _))))
#+END_SRC
*** PBoundary
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  g/PClassify
  (classify-point
   [_ q] (reduce cmin (map #(g/classify-point % q) (g/edges _))))
  g/PProximity
  (closest-point
   [_ q] (g/closest-point* (g/edges _) q))
  g/PBoundary
  (contains-point?
   [{[px py] :p w :w h :h} [x y]]
   (and (m/in-range? 0.0 w (c- x px)) (m/in-range? 0.0 h (c- y py))))
#+END_SRC
*** PSampleable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  g/PSampleable
  (point-at
   [_ t] (g/point-at* t (conj (g/vertices _) (:p _))))
  (random-point
   [_] (g/point-at _ (m/random)))
  (random-point-inside
   [_] (+ (:p _) (m/random (:w _)) (m/random (:h _))))
  (sample-uniform
   [_ udist include-last?]
   (g/sample-uniform* udist include-last? (conj (g/vertices _) (:p _))))
#+END_SRC
*** PIntersectable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  g/PIntersectable
  (intersect-shape
   [_ s]
   (cond
    (instance? thi.ng.geom.types.Rect s) (intersect-rect? _ s)
    (instance? thi.ng.geom.types.Circle s) (intersect-circle? _ s)
    :default (g/type-error "Rect" s)))
#+END_SRC
*** PPolygonizable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  g/PPolygonizable
  (as-polygon
   [_] (thi.ng.geom.types.Polygon. (g/vertices _) []))
#+END_SRC
*** PSubdivideable
    A rectangle can be subdivided into smaller ones, i.e. to create a
    list of uniform grid cells. The following options can be given as
    a 2nd argument map:

    | Key     | Description                                                    | Default |
    |---------+----------------------------------------------------------------+---------|
    | =:num=  | number of cols/rows the rect will be uniformly subdivided into |       2 |
    | =:cols= | number of times the rect will be subdivided along the X-axis   |       2 |
    | =:rows= | number of times the rect will be subdivided along the Y-axis   |       2 |

    When =:num= is given, the resulting rects will retain the aspect
    ratio of the original rect. If specified, =:cols= and =:rows= will
    take precedence over =:num=, but the latter will be used as
    default for missing args. Rects are returned as a lazyseq with
    top-left to bottom-right ordering and inner sorting along X.

#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  g/PSubdivideable
  (subdivide
   ([_] (g/subdivide _ {}))
   ([_ {:keys [num cols rows] :or {num 2}}]
      (let [dx (/ 1.0 (or cols num))
            dy (/ 1.0 (or rows num))
            rx (range 0.0 1.0 dx)
            ry (range 0.0 1.0 dy)
            w (c* (:w _) dx)
            h (c* (:h _) dy)]
        (for [y ry x rx
              :let [[px py] (unmap-uv _ [x y])
                    px (m/roundto px *eps*)
                    py (m/roundto py *eps*)]]
          (thi.ng.geom.types.Rect. (vec2 px py) w h)))))
#+END_SRC
*** PTessellateable
    A rectangle can be tessellated into a number of triangles. When
    called without options map as 2nd argument, the rect will be split
    into 2 triangles, each in anti-clockwise orientation: =[tl br tr]=
    & =[tl bl br]=. When called *with* options, then these are used
    for a call to [[PSubdivideable][=subdivide=]] first and the function returns a lazyseq
    of triangles of the subdivided rects.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  g/PTessellateable
  (tessellate
   ([_]
      (let [[a b c d] (g/vertices _)]
        [(thi.ng.geom.types.Triangle2. a b c) (thi.ng.geom.types.Triangle2. a c d)]))
   ([_ opts]
      (mapcat g/tessellate (g/subdivide _ opts))))
#+END_SRC
*** PMeshable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  g/PMeshable
  (as-mesh
   [_]
   (let [[a b c d] (g/vertices _)]
     (mesh/mesh2 [a b c] [a c d])))
#+END_SRC
*** PExtrudeable
    Extruding a rectangle along the Z-axis results in a 3D mesh
    implementation. The =extrude= function supports the following
    options, given as parameter map:

    | Key       | Description                             | Default |
    |-----------+-----------------------------------------+---------|
    | =:depth=  | extrusion depth along positive Z        |     1.0 |
    | =:scale=  | scale factor of rect at extrusion depth |     1.0 |
    | =:offset= | extrusion vector (overrides :depth)     |     nil |

    The process results is bevelled forms for =:scale= values other
    than 1.0.
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  g/PExtrudeable
  (extrude
   [_ {:keys [depth scale offset] :or {depth 1.0 scale 1.0}}]
   (if (and (= scale 1.0) (nil? offset))
     (g/as-mesh
      (thi.ng.geom.types.AABB.
       (vec3 (:p _))
       (vec3 (:w _) (:h _) depth)))
     (let [offset (or offset (vec3 0 0 depth))
           [a b c d] (mapv vec3 (g/vertices _))
           [a2 b2 c2 d2] (->> (g/scale-size _ scale)
                              (g/vertices)
                              (map #(+ offset %)))]
       (mesh/mesh3
        [a c b] [a d c]       ;;back
        [a2 b2 c2] [a2 c2 d2] ;; front
        [a d2 d] [a a2 d2]    ;; left
        [b2 c c2] [b2 b c]    ;; right
        [a b2 a2] [a b b2]    ;; top
        [d d2 c2] [d c2 c]    ;; bottom
        ))))
#+END_SRC
*** TODO PTransformable
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  g/PTransformable
  (scale
   ([_ s]
      (if (number? s)
        (thi.ng.geom.types.Rect.
         (* (:p _) s) (c* (:w _) s) (c* (:h _) s))
        (thi.ng.geom.types.Rect.
         (* (:p _) s) (c* (:w _) (nth s 0 0)) (c* (:h _) (nth s 1 0)))))
   ([_ a b]
      (if (number? a)
        (thi.ng.geom.types.Rect.
         (* (:p _) a b) (c* (:w _) a) (c* (:h _) b))
        (thi.ng.geom.types.Rect.
         (* (:p _) a b)
         (c* (:w _) (nth a 0 0) (nth b 0 0))
         (c* (:h _) (nth a 1 0) (nth b 1 0))))))
  (scale-size
   [{w :w h :h :as _} s]
   (let [[w2 h2] (if (number? s)
                   [(c* w s) (c* h s)]
                   [(c* w (nth s 0 0)) (c* h (nth s 1 0))])]
     (thi.ng.geom.types.Rect.
       (g/madd (vec2 w2 h2) -0.5 (g/centroid _)) w2 h2)))
#+END_SRC
*** End of implementations                                         :noexport:
#+BEGIN_SRC clojure :tangle babel/src-cljx/thi/ng/geom/rect.cljx
  )
#+END_SRC
